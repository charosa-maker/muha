--- a/net/minecraft/world/inventory/AnvilMenu.java
+++ b/net/minecraft/world/inventory/AnvilMenu.java
@@ -1,25 +_,29 @@
 package net.minecraft.world.inventory;
 
+import com.mohistmc.youer.YouerConfig;
 import com.mojang.logging.LogUtils;
 import it.unimi.dsi.fastutil.objects.Object2IntMap.Entry;
 import javax.annotation.Nullable;
-import net.minecraft.core.BlockPos;
 import net.minecraft.core.Holder;
 import net.minecraft.core.component.DataComponents;
 import net.minecraft.network.chat.Component;
+import net.minecraft.network.protocol.game.ClientboundContainerSetDataPacket;
+import net.minecraft.network.protocol.game.ClientboundContainerSetSlotPacket;
+import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.tags.BlockTags;
 import net.minecraft.util.Mth;
 import net.minecraft.util.StringUtil;
 import net.minecraft.world.entity.player.Inventory;
 import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.item.ItemStack;
-import net.minecraft.world.item.Items;
 import net.minecraft.world.item.enchantment.Enchantment;
 import net.minecraft.world.item.enchantment.EnchantmentHelper;
 import net.minecraft.world.item.enchantment.ItemEnchantments;
-import net.minecraft.world.level.Level;
 import net.minecraft.world.level.block.AnvilBlock;
 import net.minecraft.world.level.block.state.BlockState;
+import org.bukkit.craftbukkit.event.CraftEventFactory;
+import org.bukkit.craftbukkit.inventory.CraftInventoryAnvil;
+import org.bukkit.craftbukkit.inventory.view.CraftAnvilView;
 import org.slf4j.Logger;
 
 public class AnvilMenu extends ItemCombinerMenu {
@@ -44,6 +_,30 @@
     private static final int ADDITIONAL_SLOT_X_PLACEMENT = 76;
     private static final int RESULT_SLOT_X_PLACEMENT = 134;
     private static final int SLOT_Y_PLACEMENT = 47;
+    // CraftBukkit start
+    public static final int DEFAULT_DENIED_COST = -1;
+    public int maximumRepairCost = Math.min(Short.MAX_VALUE, Math.max(41, YouerConfig.maximumRepairCost));
+    private CraftAnvilView bukkitEntity;
+    // CraftBukkit end
+    public boolean bypassEnchantmentLevelRestriction = false; // Paper - bypass anvil level restrictions
+    // Purpur start - Anvil API
+    public boolean bypassCost = false;
+    public boolean canDoUnsafeEnchants = false;
+    // Purpur end - Anvil API
+
+    @Override
+    public CraftAnvilView getBukkitView() {
+        if (bukkitEntity != null) {
+            return bukkitEntity;
+        }
+
+        CraftInventoryAnvil inventory = new CraftInventoryAnvil(
+                access.getLocation(), this.inputSlots, this.resultSlots);
+        bukkitEntity = new CraftAnvilView(this.player.getBukkitEntity(), inventory, this);
+        bukkitEntity.updateFromLegacy(inventory);
+        return bukkitEntity;
+    }
+    // CraftBukkit end
 
     public AnvilMenu(int p_39005_, Inventory p_39006_) {
         this(p_39005_, p_39006_, ContainerLevelAccess.NULL);
@@ -70,7 +_,7 @@
 
     @Override
     protected boolean mayPickup(Player p_39023_, boolean p_39024_) {
-        return (p_39023_.hasInfiniteMaterials() || p_39023_.experienceLevel >= this.cost.get()) && this.cost.get() > 0;
+        return (p_39023_.hasInfiniteMaterials() || p_39023_.experienceLevel >= this.cost.get()) && (this.bypassCost || this.cost.get() > AnvilMenu.DEFAULT_DENIED_COST) && p_39024_; // CraftBukkit - allow cost 0 like a free item
     }
 
     @Override
@@ -79,6 +_,8 @@
             p_150474_.giveExperienceLevels(-this.cost.get());
         }
 
+        float breakChance = net.neoforged.neoforge.common.CommonHooks.onAnvilRepair(p_150474_, p_150475_, AnvilMenu.this.inputSlots.getItem(0), AnvilMenu.this.inputSlots.getItem(1));
+
         this.inputSlots.setItem(0, ItemStack.EMPTY);
         if (this.repairItemCountCost > 0) {
             ItemStack itemstack = this.inputSlots.getItem(1);
@@ -92,11 +_,21 @@
             this.inputSlots.setItem(1, ItemStack.EMPTY);
         }
 
-        this.cost.set(0);
+        this.cost.set(DEFAULT_DENIED_COST); // CraftBukkit - use a variable for set a cost for denied item
         this.access.execute((p_150479_, p_150480_) -> {
             BlockState blockstate = p_150479_.getBlockState(p_150480_);
-            if (!p_150474_.hasInfiniteMaterials() && blockstate.is(BlockTags.ANVIL) && p_150474_.getRandom().nextFloat() < 0.12F) {
+            if (!p_150474_.getAbilities().instabuild && blockstate.is(BlockTags.ANVIL) && p_150474_.getRandom().nextFloat() < breakChance) {
                 BlockState blockstate1 = AnvilBlock.damage(blockstate);
+                // Paper start - AnvilDamageEvent
+                com.destroystokyo.paper.event.block.AnvilDamagedEvent event = new com.destroystokyo.paper.event.block.AnvilDamagedEvent(getBukkitView(), blockstate1 != null ? org.bukkit.craftbukkit.block.data.CraftBlockData.fromData(blockstate1) : null);
+                if (!event.callEvent()) {
+                    return;
+                } else if (event.getDamageState() == com.destroystokyo.paper.event.block.AnvilDamagedEvent.DamageState.BROKEN) {
+                    blockstate1 = null;
+                } else {
+                    blockstate1 = ((org.bukkit.craftbukkit.block.data.CraftBlockData) event.getDamageState().getMaterial().createBlockData()).getState().setValue(AnvilBlock.FACING, blockstate.getValue(AnvilBlock.FACING));
+                }
+                // Paper end - AnvilDamageEvent
                 if (blockstate1 == null) {
                     p_150479_.removeBlock(p_150480_, false);
                     p_150479_.levelEvent(1029, p_150480_, 0);
@@ -112,25 +_,36 @@
 
     @Override
     public void createResult() {
+        // Purpur start - Anvil API
+        this.bypassCost = false;
+        this.canDoUnsafeEnchants = false;
+        if (org.purpurmc.purpur.event.inventory.AnvilUpdateResultEvent.getHandlerList().getRegisteredListeners().length > 0) new org.purpurmc.purpur.event.inventory.AnvilUpdateResultEvent(getBukkitView()).callEvent();
+        // Purpur end - Anvil API
         ItemStack itemstack = this.inputSlots.getItem(0);
         this.cost.set(1);
         int i = 0;
         long j = 0L;
         int k = 0;
-        if (!itemstack.isEmpty() && EnchantmentHelper.canStoreEnchantments(itemstack)) {
+        if (!itemstack.isEmpty()) {  // don't fire the event if the left input slot is empty, because anvil shouldn't have recipes with an empty left slot
+            if (!net.neoforged.neoforge.common.CommonHooks.onAnvilChange(this, itemstack, this.inputSlots.getItem(1), resultSlots, itemName, j, this.player)) {
+                return;  // event is canceled or overrides the output item
+            }
+        }
+        if (!itemstack.isEmpty() && this.canDoUnsafeEnchants || EnchantmentHelper.canStoreEnchantments(itemstack)) {
             ItemStack itemstack1 = itemstack.copy();
             ItemStack itemstack2 = this.inputSlots.getItem(1);
             ItemEnchantments.Mutable itemenchantments$mutable = new ItemEnchantments.Mutable(EnchantmentHelper.getEnchantmentsForCrafting(itemstack1));
             j += (long)itemstack.getOrDefault(DataComponents.REPAIR_COST, Integer.valueOf(0)).intValue()
                 + (long)itemstack2.getOrDefault(DataComponents.REPAIR_COST, Integer.valueOf(0)).intValue();
             this.repairItemCountCost = 0;
+            boolean flag = false;
             if (!itemstack2.isEmpty()) {
-                boolean flag = itemstack2.has(DataComponents.STORED_ENCHANTMENTS);
+                flag = itemstack2.has(DataComponents.STORED_ENCHANTMENTS);
                 if (itemstack1.isDamageableItem() && itemstack1.getItem().isValidRepairItem(itemstack, itemstack2)) {
                     int l2 = Math.min(itemstack1.getDamageValue(), itemstack1.getMaxDamage() / 4);
                     if (l2 <= 0) {
-                        this.resultSlots.setItem(0, ItemStack.EMPTY);
-                        this.cost.set(0);
+                        CraftEventFactory.callPrepareAnvilEvent(getBukkitView(), ItemStack.EMPTY); // CraftBukkit
+                        this.cost.set(DEFAULT_DENIED_COST); // CraftBukkit - use a variable for set a cost for denied item
                         return;
                     }
 
@@ -145,8 +_,9 @@
                     this.repairItemCountCost = j3;
                 } else {
                     if (!flag && (!itemstack1.is(itemstack2.getItem()) || !itemstack1.isDamageableItem())) {
-                        this.resultSlots.setItem(0, ItemStack.EMPTY);
-                        this.cost.set(0);
+                        CraftEventFactory.callPrepareAnvilEvent(getBukkitView(), ItemStack.EMPTY); // CraftBukkit
+                        this.cost.set(DEFAULT_DENIED_COST); // CraftBukkit - use a variable for set a cost for denied item
+
                         return;
                     }
 
@@ -176,14 +_,16 @@
                         int j2 = entry.getIntValue();
                         j2 = i2 == j2 ? j2 + 1 : Math.max(j2, i2);
                         Enchantment enchantment = holder.value();
-                        boolean flag1 = enchantment.canEnchant(itemstack);
-                        if (this.player.getAbilities().instabuild || itemstack.is(Items.ENCHANTED_BOOK)) {
+                        // Neo: Respect IItemExtension#supportsEnchantment - we also delegate the logic for Enchanted Books to this method.
+                        // Though we still allow creative players to combine any item with any enchantment in the anvil here.
+                        boolean flag1 = itemstack.supportsEnchantment(holder);
+                        if (this.player.getAbilities().instabuild) {
                             flag1 = true;
                         }
 
                         for (Holder<Enchantment> holder1 : itemenchantments$mutable.keySet()) {
                             if (!holder1.equals(holder) && !Enchantment.areCompatible(holder, holder1)) {
-                                flag1 = false;
+                                flag1 = this.canDoUnsafeEnchants; // Purpur - Anvil API
                                 i++;
                             }
                         }
@@ -192,7 +_,7 @@
                             flag3 = true;
                         } else {
                             flag2 = true;
-                            if (j2 > enchantment.getMaxLevel()) {
+                            if (j2 > enchantment.getMaxLevel() && !this.bypassEnchantmentLevelRestriction) { // Paper - bypass anvil level restrictions
                                 j2 = enchantment.getMaxLevel();
                             }
 
@@ -210,8 +_,8 @@
                     }
 
                     if (flag3 && !flag2) {
-                        this.resultSlots.setItem(0, ItemStack.EMPTY);
-                        this.cost.set(0);
+                        CraftEventFactory.callPrepareAnvilEvent(getBukkitView(), ItemStack.EMPTY); // CraftBukkit
+                        this.cost.set(DEFAULT_DENIED_COST); // CraftBukkit - use a variable for set a cost for denied item
                         return;
                     }
                 }
@@ -228,6 +_,7 @@
                 i += k;
                 itemstack1.remove(DataComponents.CUSTOM_NAME);
             }
+            if (flag && !itemstack1.isBookEnchantable(itemstack2)) itemstack1 = ItemStack.EMPTY;
 
             int k2 = (int)Mth.clamp(j + (long)i, 0L, 2147483647L);
             this.cost.set(k2);
@@ -235,12 +_,30 @@
                 itemstack1 = ItemStack.EMPTY;
             }
 
-            if (k == i && k > 0 && this.cost.get() >= 40) {
-                this.cost.set(39);
-            }
-
-            if (this.cost.get() >= 40 && !this.player.getAbilities().instabuild) {
-                itemstack1 = ItemStack.EMPTY;
+            if (maximumRepairCost == 40) {
+                if (k == i && k > 0 && this.cost.get() >= 40) {
+                    this.cost.set(39);
+                }
+                // Purpur start - Anvil API
+                if (this.bypassCost && this.cost.get() >= this.maximumRepairCost) {
+                    this.cost.set(this.maximumRepairCost - 1);
+                }
+                // Purpur end - Anvil API
+                if (this.cost.get() >= 40 && !this.player.getAbilities().instabuild) { // CraftBukkit
+                    itemstack1 = ItemStack.EMPTY;
+                }
+            } else {
+                if (k == i && k > 0 && this.cost.get() >= maximumRepairCost) { // CraftBukkit
+                    this.cost.set(maximumRepairCost - 1); // CraftBukkit
+                }
+                // Purpur start - Anvil API
+                if (this.bypassCost && this.cost.get() >= this.maximumRepairCost) {
+                    this.cost.set(this.maximumRepairCost - 1);
+                }
+                // Purpur end - Anvil API
+                if (this.cost.get() >= maximumRepairCost && !this.player.getAbilities().instabuild) { // CraftBukkit
+                    itemstack1 = ItemStack.EMPTY;
+                }
             }
 
             if (!itemstack1.isEmpty()) {
@@ -257,11 +_,20 @@
                 EnchantmentHelper.setEnchantments(itemstack1, itemenchantments$mutable.toImmutable());
             }
 
-            this.resultSlots.setItem(0, itemstack1);
+            CraftEventFactory.callPrepareAnvilEvent(getBukkitView(), itemstack1); // CraftBukkit
+            sendAllDataToRemote(); // CraftBukkit - SPIGOT-6686: Always send completed inventory to stay in sync with client
             this.broadcastChanges();
+
+            // Purpur start - Anvil API
+            if ((this.canDoUnsafeEnchants || org.purpurmc.purpur.PurpurConfig.allowInapplicableEnchants || org.purpurmc.purpur.PurpurConfig.allowIncompatibleEnchants) && itemstack1 != ItemStack.EMPTY) { // Purpur - Config to allow unsafe enchants
+                ((ServerPlayer) this.player).connection.send(new ClientboundContainerSetSlotPacket(this.containerId, this.incrementStateId(), 2, itemstack1));
+                ((ServerPlayer) this.player).connection.send(new ClientboundContainerSetDataPacket(this.containerId, 0, this.cost.get()));
+            }
+            // Purpur end - Anvil API
         } else {
-            this.resultSlots.setItem(0, ItemStack.EMPTY);
-            this.cost.set(0);
+            CraftEventFactory.callPrepareAnvilEvent(getBukkitView(), ItemStack.EMPTY); // CraftBukkit
+            this.cost.set(DEFAULT_DENIED_COST); // CraftBukkit - use a variable for set a cost for denied item
+
         }
     }
 
@@ -283,6 +_,7 @@
             }
 
             this.createResult();
+            org.bukkit.craftbukkit.event.CraftEventFactory.callPrepareResultEvent(this, RESULT_SLOT); // Paper - Add PrepareResultEvent
             return true;
         } else {
             return false;
@@ -297,5 +_,12 @@
 
     public int getCost() {
         return this.cost.get();
+    }
+
+    /**
+     * Neo: Sets the cost. Will be clamped to an integer.
+     */
+    public void setMaximumCost(long value) {
+        this.cost.set((int)Mth.clamp(value, 0L, Integer.MAX_VALUE));
     }
 }
