--- a/net/minecraft/world/entity/monster/Zombie.java
+++ b/net/minecraft/world/entity/monster/Zombie.java
@@ -8,6 +_,7 @@
 import net.minecraft.core.BlockPos;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.nbt.NbtOps;
+import net.minecraft.nbt.Tag;
 import net.minecraft.network.syncher.EntityDataAccessor;
 import net.minecraft.network.syncher.EntityDataSerializers;
 import net.minecraft.network.syncher.SynchedEntityData;
@@ -63,12 +_,15 @@
 import net.minecraft.world.level.ServerLevelAccessor;
 import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.block.state.BlockState;
+import org.bukkit.event.entity.CreatureSpawnEvent;
+import org.bukkit.event.entity.EntityTransformEvent;
 
 public class Zombie extends Monster {
     private static final ResourceLocation SPEED_MODIFIER_BABY_ID = ResourceLocation.withDefaultNamespace("baby");
     private static final AttributeModifier SPEED_MODIFIER_BABY = new AttributeModifier(
         SPEED_MODIFIER_BABY_ID, 0.5, AttributeModifier.Operation.ADD_MULTIPLIED_BASE
     );
+    private final AttributeModifier babyModifier = new AttributeModifier(Zombie.SPEED_MODIFIER_BABY_ID, this.level().paperConfig().entities.behavior.babyZombieMovementModifier, AttributeModifier.Operation.ADD_MULTIPLIED_BASE); // Paper - Make baby speed configurable
     private static final ResourceLocation REINFORCEMENT_CALLER_CHARGE_ID = ResourceLocation.withDefaultNamespace("reinforcement_caller_charge");
     private static final AttributeModifier ZOMBIE_REINFORCEMENT_CALLEE_CHARGE = new AttributeModifier(
         ResourceLocation.withDefaultNamespace("reinforcement_callee_charge"), -0.05F, AttributeModifier.Operation.ADD_VALUE
@@ -84,14 +_,16 @@
     public static final int REINFORCEMENT_RANGE_MIN = 7;
     private static final EntityDimensions BABY_DIMENSIONS = EntityType.ZOMBIE.getDimensions().scale(0.5F).withEyeHeight(0.93F);
     private static final float BREAK_DOOR_CHANCE = 0.1F;
-    private static final Predicate<Difficulty> DOOR_BREAKING_PREDICATE = p_34284_ -> p_34284_ == Difficulty.HARD;
-    private final BreakDoorGoal breakDoorGoal = new BreakDoorGoal(this, DOOR_BREAKING_PREDICATE);
+    public static final Predicate<Difficulty> DOOR_BREAKING_PREDICATE = p_34284_ -> p_34284_ == Difficulty.HARD;
+    private final BreakDoorGoal breakDoorGoal;
     private boolean canBreakDoors;
     private int inWaterTime;
     public int conversionTime;
 
     public Zombie(EntityType<? extends Zombie> p_34271_, Level p_34272_) {
         super(p_34271_, p_34272_);
+        this.breakDoorGoal = new BreakDoorGoal(this, com.google.common.base.Predicates.in(p_34272_.paperConfig().entities.behavior.doorBreakingDifficulty.getOrDefault(p_34271_, p_34272_.paperConfig().entities.behavior.doorBreakingDifficulty.get(EntityType.ZOMBIE)))); // Paper - Configurable door breaking difficulty
+        this.setShouldBurnInDay(true); // Purpur - API for any mob to burn daylight
     }
 
     public Zombie(Level p_34274_) {
@@ -100,7 +_,7 @@
 
     @Override
     protected void registerGoals() {
-        this.goalSelector.addGoal(4, new Zombie.ZombieAttackTurtleEggGoal(this, 1.0, 3));
+        if (this.level().paperConfig().entities.behavior.zombiesTargetTurtleEggs) this.goalSelector.addGoal(4, new Zombie.ZombieAttackTurtleEggGoal(this, 1.0, 3));
         this.goalSelector.addGoal(8, new LookAtPlayerGoal(this, Player.class, 8.0F));
         this.goalSelector.addGoal(8, new RandomLookAroundGoal(this));
         this.addBehaviourGoals();
@@ -112,7 +_,7 @@
         this.goalSelector.addGoal(7, new WaterAvoidingRandomStrollGoal(this, 1.0));
         this.targetSelector.addGoal(1, new HurtByTargetGoal(this).setAlertOthers(ZombifiedPiglin.class));
         this.targetSelector.addGoal(2, new NearestAttackableTargetGoal<>(this, Player.class, true));
-        this.targetSelector.addGoal(3, new NearestAttackableTargetGoal<>(this, AbstractVillager.class, false));
+        if ( this.level().spigotConfig.zombieAggressiveTowardsVillager ) this.targetSelector.addGoal(3, new NearestAttackableTargetGoal<>(this, AbstractVillager.class, false)); // Spigot
         this.targetSelector.addGoal(3, new NearestAttackableTargetGoal<>(this, IronGolem.class, true));
         this.targetSelector.addGoal(5, new NearestAttackableTargetGoal<>(this, Turtle.class, 10, true, false, Turtle.BABY_ON_LAND_SELECTOR));
     }
@@ -159,7 +_,7 @@
         }
     }
 
-    protected boolean supportsBreakDoorGoal() {
+    public boolean supportsBreakDoorGoal() {
         return true;
     }
 
@@ -170,11 +_,16 @@
 
     @Override
     protected int getBaseExperienceReward() {
+        final int previousReward = this.xpReward; // Paper - store previous value to reset after calculating XP reward
         if (this.isBaby()) {
             this.xpReward = (int)((double)this.xpReward * 2.5);
         }
 
-        return super.getBaseExperienceReward();
+        // Paper start - store previous value to reset after calculating XP reward
+        int reward = super.getBaseExperienceReward();
+        this.xpReward = previousReward;
+        return reward;
+        // Paper end - store previous value to reset after calculating XP reward
     }
 
     @Override
@@ -182,9 +_,9 @@
         this.getEntityData().set(DATA_BABY_ID, p_34309_);
         if (this.level() != null && !this.level().isClientSide) {
             AttributeInstance attributeinstance = this.getAttribute(Attributes.MOVEMENT_SPEED);
-            attributeinstance.removeModifier(SPEED_MODIFIER_BABY_ID);
+            attributeinstance.removeModifier(this.babyModifier.id()); // Paper - Make baby speed configurable
             if (p_34309_) {
-                attributeinstance.addTransientModifier(SPEED_MODIFIER_BABY);
+                attributeinstance.addTransientModifier(this.babyModifier); // Paper - Make baby speed configurable
             }
         }
     }
@@ -206,7 +_,7 @@
     public void tick() {
         if (!this.level().isClientSide && this.isAlive() && !this.isNoAi()) {
             if (this.isUnderWaterConverting()) {
-                this.conversionTime--;
+                --this.conversionTime; // Paper - remove anti tick skipping measures / wall time
                 if (this.conversionTime < 0) {
                     this.doUnderWaterConversion();
                 }
@@ -227,38 +_,23 @@
 
     @Override
     public void aiStep() {
-        if (this.isAlive()) {
-            boolean flag = this.isSunSensitive() && this.isSunBurnTick();
-            if (flag) {
-                ItemStack itemstack = this.getItemBySlot(EquipmentSlot.HEAD);
-                if (!itemstack.isEmpty()) {
-                    if (itemstack.isDamageableItem()) {
-                        Item item = itemstack.getItem();
-                        itemstack.setDamageValue(itemstack.getDamageValue() + this.random.nextInt(2));
-                        if (itemstack.getDamageValue() >= itemstack.getMaxDamage()) {
-                            this.onEquippedItemBroken(item, EquipmentSlot.HEAD);
-                            this.setItemSlot(EquipmentSlot.HEAD, ItemStack.EMPTY);
-                        }
-                    }
-
-                    flag = false;
-                }
-
-                if (flag) {
-                    this.igniteForSeconds(8.0F);
-                }
-            }
-        }
-
         super.aiStep();
     }
 
+    // Paper start - Add more Zombie API
+    public void stopDrowning() {
+        this.conversionTime = -1;
+        this.getEntityData().set(Zombie.DATA_DROWNED_CONVERSION_ID, false);
+    }
+    // Paper end - Add more Zombie API
+
     public void startUnderWaterConversion(int p_34279_) {
         this.conversionTime = p_34279_;
         this.getEntityData().set(DATA_DROWNED_CONVERSION_ID, true);
     }
 
     protected void doUnderWaterConversion() {
+        if (!net.neoforged.neoforge.event.EventHooks.canLivingConvert(this, EntityType.DROWNED, (timer) -> this.conversionTime = timer)) return;
         this.convertToZombieType(EntityType.DROWNED);
         if (!this.isSilent()) {
             this.level().levelEvent(null, 1040, this.blockPosition(), 0);
@@ -266,16 +_,28 @@
     }
 
     protected void convertToZombieType(EntityType<? extends Zombie> p_34311_) {
-        Zombie zombie = this.convertTo(p_34311_, true);
+        Zombie zombie = this.convertTo(p_34311_, true, org.bukkit.event.entity.EntityTransformEvent.TransformReason.DROWNED, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.DROWNED);
         if (zombie != null) {
             zombie.handleAttributes(zombie.level().getCurrentDifficultyAt(zombie.blockPosition()).getSpecialMultiplier());
             zombie.setCanBreakDoors(zombie.supportsBreakDoorGoal() && this.canBreakDoors());
+            net.neoforged.neoforge.event.EventHooks.onLivingConvert(this, zombie);
+            // CraftBukkit start - SPIGOT-5208: End conversion to stop event spam
+        } else {
+            ((org.bukkit.entity.Zombie) getBukkitEntity()).setConversionTime(-1);
+            // CraftBukkit end
         }
     }
 
-    protected boolean isSunSensitive() {
-        return true;
-    }
+    public boolean shouldBurnInDay() { return this.isSunSensitive(); } // Purpur - for ABI compatibility - API for any mob to burn daylight
+    public boolean isSunSensitive() {
+        return this.shouldBurnInDay; // Paper - Add more Zombie API
+    }
+
+    // Paper start - Add more Zombie API
+    public void setShouldBurnInDay(boolean shouldBurnInDay) {
+        this.shouldBurnInDay = shouldBurnInDay;
+    }
+    // Paper end - Add more Zombie API
 
     @Override
     public boolean hurt(DamageSource p_34288_, float p_34289_) {
@@ -308,13 +_,14 @@
                     if (SpawnPlacements.isSpawnPositionOk(entitytype, this.level(), blockpos)
                         && SpawnPlacements.checkSpawnRules(entitytype, serverlevel, MobSpawnType.REINFORCEMENT, blockpos, this.level().random)) {
                         zombie.setPos((double)i1, (double)j1, (double)k1);
-                        if (!this.level().hasNearbyAlivePlayer((double)i1, (double)j1, (double)k1, 7.0)
+                        if (!this.level().hasNearbyAlivePlayerThatAffectsSpawning((double)i1, (double)j1, (double)k1, 7.0)
                             && this.level().isUnobstructed(zombie)
                             && this.level().noCollision(zombie)
                             && !this.level().containsAnyLiquid(zombie.getBoundingBox())) {
+                            zombie.setTargetReason(org.bukkit.event.entity.EntityTargetEvent.TargetReason.REINFORCEMENT_TARGET, true); // CraftBukkit
                             zombie.setTarget(livingentity);
                             zombie.finalizeSpawn(serverlevel, this.level().getCurrentDifficultyAt(zombie.blockPosition()), MobSpawnType.REINFORCEMENT, null);
-                            serverlevel.addFreshEntityWithPassengers(zombie);
+                            serverlevel.addFreshEntityWithPassengers(zombie, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.REINFORCEMENTS); // CraftBukkit
                             AttributeInstance attributeinstance = this.getAttribute(Attributes.SPAWN_REINFORCEMENTS_CHANCE);
                             AttributeModifier attributemodifier = attributeinstance.getModifier(REINFORCEMENT_CALLER_CHARGE_ID);
                             double d0 = attributemodifier != null ? attributemodifier.amount() : 0.0;
@@ -339,7 +_,14 @@
         if (flag) {
             float f = this.level().getCurrentDifficultyAt(this.blockPosition()).getEffectiveDifficulty();
             if (this.getMainHandItem().isEmpty() && this.isOnFire() && this.random.nextFloat() < f * 0.3F) {
-                p_34276_.igniteForSeconds((float)(2 * (int)f));
+                // CraftBukkit start
+                org.bukkit.event.entity.EntityCombustByEntityEvent event = new org.bukkit.event.entity.EntityCombustByEntityEvent(this.getBukkitEntity(), p_34276_.getBukkitEntity(), (float) (2 * (int) f)); // PAIL: fixme
+                this.level().getCraftServer().getPluginManager().callEvent(event);
+
+                if (!event.isCancelled()) {
+                    p_34276_.igniteForSeconds(event.getDuration(), false);
+                }
+                // CraftBukkit end
             }
         }
 
@@ -357,7 +_,7 @@
     }
 
     @Override
-    protected SoundEvent getDeathSound() {
+    public SoundEvent getDeathSound() {
         return SoundEvents.ZOMBIE_DEATH;
     }
 
@@ -406,32 +_,39 @@
     @Override
     public boolean killedEntity(ServerLevel p_219160_, LivingEntity p_219161_) {
         boolean flag = super.killedEntity(p_219160_, p_219161_);
-        if ((p_219160_.getDifficulty() == Difficulty.NORMAL || p_219160_.getDifficulty() == Difficulty.HARD) && p_219161_ instanceof Villager villager) {
+        final double fallbackChance = p_219160_.getDifficulty() == Difficulty.HARD ? 100d : p_219160_.getDifficulty() == Difficulty.NORMAL ? 50d : 0d; // Paper - Configurable chance of villager zombie infection
+        if (this.random.nextDouble() * 100 < p_219160_.paperConfig().entities.behavior.zombieVillagerInfectionChance.or(fallbackChance) && p_219161_ instanceof Villager villager && net.neoforged.neoforge.event.EventHooks.canLivingConvert(p_219161_, EntityType.ZOMBIE_VILLAGER, (timer) -> {})) {
             if (p_219160_.getDifficulty() != Difficulty.HARD && this.random.nextBoolean()) {
                 return flag;
             }
-
-            ZombieVillager zombievillager = villager.convertTo(EntityType.ZOMBIE_VILLAGER, false);
-            if (zombievillager != null) {
-                zombievillager.finalizeSpawn(
-                    p_219160_,
-                    p_219160_.getCurrentDifficultyAt(zombievillager.blockPosition()),
-                    MobSpawnType.CONVERSION,
-                    new Zombie.ZombieGroupData(false, true)
-                );
-                zombievillager.setVillagerData(villager.getVillagerData());
-                zombievillager.setGossips(villager.getGossips().store(NbtOps.INSTANCE));
-                zombievillager.setTradeOffers(villager.getOffers().copy());
-                zombievillager.setVillagerXp(villager.getVillagerXp());
-                if (!this.isSilent()) {
-                    p_219160_.levelEvent(null, 1026, this.blockPosition(), 0);
+            // CraftBukkit start
+            flag = zombifyVillager(p_219160_, villager, this.blockPosition(), this.isSilent(), org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.INFECTION) == null;
+        }
+        return flag;
+    }
+
+    public static ZombieVillager zombifyVillager(ServerLevel worldserver, Villager entityvillager, net.minecraft.core.BlockPos blockPosition, boolean silent, CreatureSpawnEvent.SpawnReason spawnReason) {
+        {
+            ZombieVillager entityzombievillager = (ZombieVillager) entityvillager.convertTo(EntityType.ZOMBIE_VILLAGER, false, EntityTransformEvent.TransformReason.INFECTION, spawnReason);
+            // CraftBukkit end
+
+            if (entityzombievillager != null) {
+                entityzombievillager.finalizeSpawn(worldserver, worldserver.getCurrentDifficultyAt(entityzombievillager.blockPosition()), MobSpawnType.CONVERSION, new Zombie.ZombieGroupData(false, true));
+                entityzombievillager.setVillagerData(entityvillager.getVillagerData());
+                entityzombievillager.setGossips((Tag) entityvillager.getGossips().store(NbtOps.INSTANCE));
+                entityzombievillager.setTradeOffers(entityvillager.getOffers().copy());
+                entityzombievillager.setVillagerXp(entityvillager.getVillagerXp());
+                // CraftBukkit start
+                if (!silent) {
+                    worldserver.levelEvent((Player) null, 1026, blockPosition, 0);
                 }
 
-                flag = false;
+                // flag = false;
             }
-        }
 
-        return flag;
+            return entityzombievillager;
+        }
+        // CraftBukkit end
     }
 
     @Override
@@ -455,7 +_,7 @@
         RandomSource randomsource = p_34297_.getRandom();
         p_34300_ = super.finalizeSpawn(p_34297_, p_34298_, p_34299_, p_34300_);
         float f = p_34298_.getSpecialMultiplier();
-        this.setCanPickUpLoot(randomsource.nextFloat() < 0.55F * f);
+        this.setCanPickUpLoot(this.level().paperConfig().entities.behavior.mobsCanAlwaysPickUpLoot.zombies || randomsource.nextFloat() < 0.55F * f);
         if (p_34300_ == null) {
             p_34300_ = new Zombie.ZombieGroupData(getSpawnAsBabyOdds(randomsource), true);
         }
@@ -480,7 +_,7 @@
                             chicken1.finalizeSpawn(p_34297_, p_34298_, MobSpawnType.JOCKEY, null);
                             chicken1.setChickenJockey(true);
                             this.startRiding(chicken1);
-                            p_34297_.addFreshEntity(chicken1);
+                            p_34297_.addFreshEntity(chicken1, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.MOUNT); // CraftBukkit
                         }
                     }
                 }
@@ -526,10 +_,14 @@
                 .addOrReplacePermanentModifier(
                     new AttributeModifier(LEADER_ZOMBIE_BONUS_ID, this.random.nextDouble() * 0.25 + 0.5, AttributeModifier.Operation.ADD_VALUE)
                 );
+            var damageTaken = getMaxHealth() - getHealth();
             this.getAttribute(Attributes.MAX_HEALTH)
                 .addOrReplacePermanentModifier(
                     new AttributeModifier(LEADER_ZOMBIE_BONUS_ID, this.random.nextDouble() * 3.0 + 1.0, AttributeModifier.Operation.ADD_MULTIPLIED_TOTAL)
                 );
+            // Neo: fix MC-219981 by resetting the leader zombie's health based on the new max health
+            // without disregarding damage already taken (if any)
+            setHealth(getMaxHealth() - damageTaken);
             this.setCanBreakDoors(this.supportsBreakDoorGoal());
         }
     }
