--- a/net/minecraft/world/level/block/BedBlock.java
+++ b/net/minecraft/world/level/block/BedBlock.java
@@ -2,7 +_,6 @@
 
 import com.mojang.serialization.MapCodec;
 import com.mojang.serialization.codecs.RecordCodecBuilder;
-import com.mojang.serialization.codecs.RecordCodecBuilder.Instance;
 import java.util.List;
 import java.util.Optional;
 import javax.annotation.Nullable;
@@ -22,6 +_,7 @@
 import net.minecraft.world.item.context.BlockPlaceContext;
 import net.minecraft.world.level.BlockGetter;
 import net.minecraft.world.level.CollisionGetter;
+import net.minecraft.world.level.ExplosionDamageCalculator;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.LevelAccessor;
 import net.minecraft.world.level.block.entity.BedBlockEntity;
@@ -102,6 +_,7 @@
                 p_49516_.explode(null, p_49516_.damageSources().badRespawnPointExplosion(vec3), null, vec3, 5.0F, true, Level.ExplosionInteraction.BLOCK);
                 return InteractionResult.SUCCESS;
             } else if (p_49515_.getValue(OCCUPIED)) {
+                if (!BedBlock.canSetSpawn(p_49516_)) return this.explodeBed(p_49515_, p_49516_, p_49517_); // Paper - check explode first
                 if (!this.kickVillagerOutOfBed(p_49516_, p_49517_)) {
                     p_49518_.displayClientMessage(Component.translatable("block.minecraft.bed.occupied"), true);
                 }
@@ -118,6 +_,27 @@
         }
     }
 
+    // CraftBukkit start
+    private InteractionResult explodeBed(BlockState iblockdata, Level world, BlockPos blockposition) {
+        {
+            {
+                org.bukkit.block.BlockState blockState = org.bukkit.craftbukkit.block.CraftBlock.at(world, blockposition).getState(); // CraftBukkit - capture BlockState before remove block
+                world.removeBlock(blockposition, false);
+                BlockPos blockposition1 = blockposition.relative(((Direction) iblockdata.getValue(BedBlock.FACING)).getOpposite());
+
+                if (world.getBlockState(blockposition1).getBlock() == this) {
+                    world.removeBlock(blockposition1, false);
+                }
+
+                Vec3 vec3d = blockposition.getCenter();
+
+                world.explode((Entity) null, world.damageSources().badRespawnPointExplosionCB(vec3d, blockState), (ExplosionDamageCalculator) null, vec3d, 5.0F, true, Level.ExplosionInteraction.BLOCK); // CraftBukkit - add state
+                return InteractionResult.SUCCESS;
+            }
+        }
+    }
+    // CraftBukkit end
+
     public static boolean canSetSpawn(Level p_49489_) {
         return p_49489_.dimensionType().bedWorks();
     }
@@ -134,7 +_,7 @@
 
     @Override
     public void fallOn(Level p_152169_, BlockState p_152170_, BlockPos p_152171_, Entity p_152172_, float p_152173_) {
-        super.fallOn(p_152169_, p_152170_, p_152171_, p_152172_, p_152173_ * 0.5F);
+        super.fallOn(p_152169_, p_152170_, p_152171_, p_152172_, p_152173_); // Purpur
     }
 
     @Override
@@ -308,6 +_,11 @@
         if (!p_49499_.isClientSide) {
             BlockPos blockpos = p_49500_.relative(p_49501_.getValue(FACING));
             p_49499_.setBlock(blockpos, p_49501_.setValue(PART, BedPart.HEAD), 3);
+            // CraftBukkit start - SPIGOT-7315: Don't updated if we capture block states
+            if (p_49499_.captureBlockStates) {
+                return;
+            }
+            // CraftBukkit end
             p_49499_.blockUpdated(p_49500_, Blocks.AIR);
             p_49501_.updateNeighbourShapes(p_49499_, p_49500_, 3);
         }
