--- a/net/minecraft/world/level/chunk/LevelChunk.java
+++ b/net/minecraft/world/level/chunk/LevelChunk.java
@@ -3,6 +_,8 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Maps;
 import com.mojang.logging.LogUtils;
+import com.destroystokyo.paper.event.server.ServerExceptionEvent;
+import com.destroystokyo.paper.exception.ServerInternalException;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
 import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
 import java.util.Map;
@@ -48,6 +_,7 @@
 import net.minecraft.world.level.material.Fluids;
 import net.minecraft.world.ticks.LevelChunkTicks;
 import net.minecraft.world.ticks.TickContainerAccess;
+import org.bukkit.craftbukkit.CraftChunk;
 import org.slf4j.Logger;
 
 public class LevelChunk extends ChunkAccess implements net.neoforged.neoforge.attachment.IAttachmentHolder {
@@ -82,6 +_,12 @@
     private final Int2ObjectMap<GameEventListenerRegistry> gameEventListenerRegistrySections;
     private final LevelChunkTicks<Block> blockTicks;
     private final LevelChunkTicks<Fluid> fluidTicks;
+    public ServerLevel r; // Youer
+	// CraftBukkit start
+    public boolean mustNotSave;
+    public boolean needsDecoration;
+    // CraftBukkit end
+
 
     public LevelChunk(Level p_187945_, ChunkPos p_187946_) {
         this(p_187945_, p_187946_, UpgradeData.EMPTY, new LevelChunkTicks<>(), new LevelChunkTicks<>(), 0L, null, null, null);
@@ -100,6 +_,9 @@
     ) {
         super(p_196855_, p_196856_, p_196854_, p_196854_.registryAccess().registryOrThrow(Registries.BIOME), p_196859_, p_196860_, p_196862_);
         this.level = p_196854_;
+        if (p_196854_ != null && p_196854_ instanceof ServerLevel) {
+            this.r = ((ServerLevel) p_196854_);
+        }
         this.gameEventListenerRegistrySections = new Int2ObjectOpenHashMap<>();
 
         for (Heightmap.Types heightmap$types : Heightmap.Types.values()) {
@@ -139,6 +_,7 @@
         this.setAllStarts(p_196851_.getAllStarts());
         this.setAllReferences(p_196851_.getAllReferences());
 
+        net.neoforged.neoforge.attachment.AttachmentInternals.copyChunkAttachmentsOnPromotion(p_196850_.registryAccess(), p_196851_.getAttachmentHolder(), this.getAttachmentHolder());
         for (Entry<Heightmap.Types, Heightmap> entry : p_196851_.getHeightmaps()) {
             if (ChunkStatus.FULL.heightmapsAfter().contains(entry.getKey())) {
                 this.setHeightmap(entry.getKey(), entry.getValue().getRawData());
@@ -148,7 +_,18 @@
         this.skyLightSources = p_196851_.skyLightSources;
         this.setLightCorrect(p_196851_.isLightCorrect());
         this.unsaved = true;
-    }
+        this.needsDecoration = true; // CraftBukkit
+        // CraftBukkit start
+        this.persistentDataContainer = p_196851_.persistentDataContainer; // SPIGOT-6814: copy PDC to account for 1.17 to 1.18 chunk upgrading.
+        // CraftBukkit end
+    }
+
+    // Paper start - If loaded util
+    @Override
+    public final BlockState getBlockStateIfLoaded(BlockPos blockposition) {
+        return this.getBlockState(blockposition);
+    }
+    // Paper end
 
     @Override
     public TickContainerAccess<Block> getBlockTicks() {
@@ -165,6 +_,16 @@
         return new ChunkAccess.TicksToSave(this.blockTicks, this.fluidTicks);
     }
 
+    // Paper start
+    @Override
+    public long getInhabitedTime() {
+        if (r != null) {
+            return this.r.paperConfig().chunks.fixedChunkInhabitedTime < 0 ? super.getInhabitedTime() : this.r.paperConfig().chunks.fixedChunkInhabitedTime;
+        }
+        return super.getInhabitedTime();
+    }
+    // Paper end
+
     @Override
     public GameEventListenerRegistry getListenerRegistry(int p_251193_) {
         return this.level instanceof ServerLevel serverlevel
@@ -220,7 +_,7 @@
             if (i >= 0 && i < this.sections.length) {
                 LevelChunkSection levelchunksection = this.sections[i];
                 if (!levelchunksection.hasOnlyAir()) {
-                    return levelchunksection.getFluidState(p_62815_ & 15, p_62816_ & 15, p_62817_ & 15);
+                    return levelchunksection.states.get((p_62816_ & 15) << 8 | (p_62817_ & 15) << 4 | p_62815_ & 15).getFluidState();
                 }
             }
 
@@ -233,6 +_,15 @@
         }
     }
 
+    public boolean setBlockState$doPlace = true;
+
+    // CraftBukkit start - ChunkMap#setBlockState() -> ChunkMap#setBlockState(BlockPos, IBlockData, boolean, boolean)
+    @Nullable
+    public BlockState setBlockStateCB(BlockPos p_62865_, BlockState p_62866_, boolean p_62867_, boolean doPlace) {
+        setBlockState$doPlace = doPlace;
+        return setBlockState(p_62865_, p_62866_, p_62867_);
+    }
+
     @Nullable
     @Override
     public BlockState setBlockState(BlockPos p_62865_, BlockState p_62866_, boolean p_62867_) {
@@ -278,7 +_,8 @@
                 if (!levelchunksection.getBlockState(j, k, l).is(block)) {
                     return null;
                 } else {
-                    if (!this.level.isClientSide) {
+                    // CraftBukkit - Don't place while processing the BlockPlaceEvent, unless it's a BlockContainer
+                    if (!this.level.isClientSide && setBlockState$doPlace && (!this.level.captureBlockStates || block instanceof EntityBlock)) {
                         p_62866_.onPlace(this.level, p_62865_, blockstate, p_62867_);
                     }
 
@@ -327,6 +_,10 @@
     @Nullable
     public BlockEntity getBlockEntity(BlockPos p_62868_, LevelChunk.EntityCreationType p_62869_) {
         BlockEntity blockentity = this.blockEntities.get(p_62868_);
+        if (blockentity != null && blockentity.isRemoved()) {
+            blockEntities.remove(p_62868_);
+            blockentity = null;
+        }
         if (blockentity == null) {
             CompoundTag compoundtag = this.pendingBlockEntities.remove(p_62868_);
             if (compoundtag != null) {
@@ -344,9 +_,6 @@
                     this.addAndRegisterBlockEntity(blockentity);
                 }
             }
-        } else if (blockentity.isRemoved()) {
-            this.blockEntities.remove(p_62868_);
-            return null;
         }
 
         return blockentity;
@@ -360,6 +_,7 @@
             }
 
             this.updateBlockEntityTicker(p_156391_);
+            this.level.addFreshBlockEntities(java.util.List.of(p_156391_));
         }
     }
 
@@ -383,6 +_,7 @@
         BlockState blockstate = this.getBlockState(blockpos);
         if (!blockstate.hasBlockEntity()) {
             LOGGER.warn("Trying to set block entity {} at position {}, but state {} does not allow it", p_156374_, blockpos, blockstate);
+            new Exception().printStackTrace(); // CraftBukkit
         } else {
             BlockState blockstate1 = p_156374_.getBlockState();
             if (blockstate != blockstate1) {
@@ -403,6 +_,7 @@
             BlockEntity blockentity = this.blockEntities.put(blockpos.immutable(), p_156374_);
             if (blockentity != null && blockentity != p_156374_) {
                 blockentity.setRemoved();
+                auxLightManager.removeLightAt(blockpos);
             }
         }
     }
@@ -412,9 +_,14 @@
     public CompoundTag getBlockEntityNbtForSaving(BlockPos p_62932_, HolderLookup.Provider p_323699_) {
         BlockEntity blockentity = this.getBlockEntity(p_62932_);
         if (blockentity != null && !blockentity.isRemoved()) {
+            try {
             CompoundTag compoundtag1 = blockentity.saveWithFullMetadata(this.level.registryAccess());
             compoundtag1.putBoolean("keepPacked", false);
             return compoundtag1;
+            } catch (Exception e) {
+                LOGGER.error("A BlockEntity type {} has thrown an exception trying to write state. It will not persist, Report this to the mod author", blockentity.getClass().getName(), e);
+                return null;
+            }
         } else {
             CompoundTag compoundtag = this.pendingBlockEntities.get(p_62932_);
             if (compoundtag != null) {
@@ -430,12 +_,20 @@
     public void removeBlockEntity(BlockPos p_62919_) {
         if (this.isInLevel()) {
             BlockEntity blockentity = this.blockEntities.remove(p_62919_);
+
+            // CraftBukkit start - SPIGOT-5561: Also remove from pending map
+            if (!pendingBlockEntities.isEmpty()) {
+                pendingBlockEntities.remove(p_62919_);
+            }
+            // CraftBukkit end
+
             if (blockentity != null) {
                 if (this.level instanceof ServerLevel serverlevel) {
                     this.removeGameEventListener(blockentity, serverlevel);
                 }
 
                 blockentity.setRemoved();
+                auxLightManager.removeLightAt(p_62919_);
             }
         }
 
@@ -496,7 +_,7 @@
         p_187974_.accept((p_338077_, p_338078_, p_338079_) -> {
             BlockEntity blockentity = this.getBlockEntity(p_338077_, LevelChunk.EntityCreationType.IMMEDIATE);
             if (blockentity != null && p_338079_ != null && blockentity.getType() == p_338078_) {
-                blockentity.loadWithComponents(p_338079_, this.level.registryAccess());
+                blockentity.handleUpdateTag(p_338079_, this.level.registryAccess());
             }
         });
     }
@@ -559,7 +_,7 @@
                 blockentity = ((EntityBlock)blockstate.getBlock()).newBlockEntity(p_62871_, blockstate);
             } else {
                 blockentity = null;
-                LOGGER.warn("Tried to load a DUMMY block entity @ {} but found not block entity block {} at location", p_62871_, blockstate);
+                if (Boolean.parseBoolean("false")) LOGGER.warn("Tried to load a DUMMY block entity @ {} but found not block entity block {} at location", p_62871_, blockstate);
             }
         } else {
             blockentity = BlockEntity.loadStatic(p_62871_, blockstate, p_62872_, this.level.registryAccess());
@@ -569,7 +_,7 @@
             blockentity.setLevel(this.level);
             this.addAndRegisterBlockEntity(blockentity);
         } else {
-            LOGGER.warn("Tried to load a block entity for block {} but failed at location {}", blockstate, p_62871_);
+            if (Boolean.parseBoolean("false")) LOGGER.warn("Tried to load a block entity for block {} but failed at location {}", blockstate, p_62871_);
         }
 
         return blockentity;
@@ -604,6 +_,7 @@
     }
 
     public void clearAllBlockEntities() {
+        this.blockEntities.values().forEach(BlockEntity::onChunkUnloaded);
         this.blockEntities.values().forEach(BlockEntity::setRemoved);
         this.blockEntities.clear();
         this.tickersInLevel.values().forEach(p_187966_ -> p_187966_.rebind(NULL_TICKER));
@@ -611,6 +_,7 @@
     }
 
     public void registerAllBlockEntitiesAfterLevelLoad() {
+        this.level.addFreshBlockEntities(this.blockEntities.values());
         this.blockEntities.values().forEach(p_187988_ -> {
             if (this.level instanceof ServerLevel serverlevel) {
                 this.addGameEventListener(p_187988_, serverlevel);
@@ -662,6 +_,70 @@
         return new LevelChunk.BoundTickingBlockEntity<>(p_156376_, p_156377_);
     }
 
+    // Neo: Threadsafe lighting system for BlockEntities that change lighting based on dynamic data changing.
+    private final net.neoforged.neoforge.common.world.LevelChunkAuxiliaryLightManager auxLightManager = new net.neoforged.neoforge.common.world.LevelChunkAuxiliaryLightManager(this);
+
+    @Override
+    public net.neoforged.neoforge.common.world.LevelChunkAuxiliaryLightManager getAuxLightManager(ChunkPos pos) {
+        return auxLightManager;
+    }
+
+    @Override
+    public final void syncData(net.neoforged.neoforge.attachment.AttachmentType<?> type) {
+        net.neoforged.neoforge.attachment.AttachmentSync.syncChunkUpdate(this, getAttachmentHolder(), type);
+    }
+
+    // CraftBukkit start
+    public void loadCallback() {
+        org.bukkit.Server server = this.level.getCraftServer();
+        if (server != null) {
+            /*
+             * If it's a new world, the first few chunks are generated inside
+             * the World constructor. We can't reliably alter that, so we have
+             * no way of creating a CraftWorld/CraftServer at that point.
+             */
+            org.bukkit.Chunk bukkitChunk = new CraftChunk(this);
+            server.getPluginManager().callEvent(new org.bukkit.event.world.ChunkLoadEvent(bukkitChunk, this.needsDecoration));
+
+            if (this.needsDecoration) {
+                this.needsDecoration = false;
+                java.util.Random random = new java.util.Random();
+                random.setSeed(r.getSeed());
+                long xRand = random.nextLong() / 2L * 2L + 1L;
+                long zRand = random.nextLong() / 2L * 2L + 1L;
+                random.setSeed((long) this.chunkPos.x * xRand + (long) this.chunkPos.z * zRand ^ r.getSeed());
+
+                org.bukkit.World world = this.level.getWorld();
+                if (world != null) {
+                    this.level.populating = true;
+                    try {
+                        for (org.bukkit.generator.BlockPopulator populator : world.getPopulators()) {
+                            populator.populate(world, random, bukkitChunk);
+                        }
+                    } finally {
+                        this.level.populating = false;
+                    }
+                }
+                server.getPluginManager().callEvent(new org.bukkit.event.world.ChunkPopulateEvent(bukkitChunk));
+            }
+        }
+    }
+
+    public void unloadCallback() {
+        org.bukkit.Server server = this.level.getCraftServer();
+        org.bukkit.Chunk bukkitChunk = new CraftChunk(this);
+        org.bukkit.event.world.ChunkUnloadEvent unloadEvent = new org.bukkit.event.world.ChunkUnloadEvent(bukkitChunk, this.isUnsaved());
+        server.getPluginManager().callEvent(unloadEvent);
+        // note: saving can be prevented, but not forced if no saving is actually required
+        this.mustNotSave = !unloadEvent.isSaveChunk();
+    }
+
+    @Override
+    public boolean isUnsaved() {
+        return super.isUnsaved() && !this.mustNotSave;
+    }
+    // CraftBukkit end
+
     class BoundTickingBlockEntity<T extends BlockEntity> implements TickingBlockEntity {
         private final T blockEntity;
         private final BlockEntityTicker<T> ticker;
@@ -679,20 +_,24 @@
                 if (LevelChunk.this.isTicking(blockpos)) {
                     try {
                         ProfilerFiller profilerfiller = LevelChunk.this.level.getProfiler();
+                        net.neoforged.neoforge.server.timings.TimeTracker.BLOCK_ENTITY_UPDATE.trackStart(blockEntity);
                         profilerfiller.push(this::getType);
                         BlockState blockstate = LevelChunk.this.getBlockState(blockpos);
                         if (this.blockEntity.getType().isValid(blockstate)) {
                             this.ticker.tick(LevelChunk.this.level, this.blockEntity.getBlockPos(), blockstate, this.blockEntity);
                             this.loggedInvalidBlockState = false;
-                        } else if (!this.loggedInvalidBlockState) {
-                            this.loggedInvalidBlockState = true;
-                            LevelChunk.LOGGER
-                                .warn(
-                                    "Block entity {} @ {} state {} invalid for ticking:",
-                                    LogUtils.defer(this::getType),
-                                    LogUtils.defer(this::getPos),
-                                    blockstate
-                                );
+                        } else {
+                            LevelChunk.this.removeBlockEntity(this.getPos());
+                            if (!this.loggedInvalidBlockState) {
+                                this.loggedInvalidBlockState = true;
+                                LevelChunk.LOGGER
+                                        .warn(
+                                                "Block entity {} @ {} state {} invalid for ticking:",
+                                                LogUtils.defer(this::getType),
+                                                LogUtils.defer(this::getPos),
+                                                blockstate
+                                        );
+                            }
                         }
 
                         profilerfiller.pop();
@@ -700,7 +_,13 @@
                         CrashReport crashreport = CrashReport.forThrowable(throwable, "Ticking block entity");
                         CrashReportCategory crashreportcategory = crashreport.addCategory("Block entity being ticked");
                         this.blockEntity.fillCrashReportCategory(crashreportcategory);
-                        throw new ReportedException(crashreport);
+                        final String msg = String.format("BlockEntity threw exception at %s:%s,%s,%s", LevelChunk.this.getLevel().getWorld().getName(), this.getPos().getX(), this.getPos().getY(), this.getPos().getZ());
+                        LOGGER.error(msg, throwable);
+                        blockEntity.setRemoved();
+                        net.minecraft.world.level.chunk.LevelChunk.this.level.getCraftServer().getPluginManager().callEvent(new ServerExceptionEvent(new ServerInternalException(msg, throwable))); // Paper - ServerExceptionEvent
+                        LevelChunk.this.removeBlockEntity(blockEntity.getBlockPos());
+                    } finally {
+                        net.neoforged.neoforge.server.timings.TimeTracker.BLOCK_ENTITY_UPDATE.trackEnd(blockEntity);
                     }
                 }
             }
