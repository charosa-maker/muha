--- a/net/minecraft/network/syncher/SynchedEntityData.java
+++ b/net/minecraft/network/syncher/SynchedEntityData.java
@@ -9,8 +_,11 @@
 import java.util.Objects;
 import javax.annotation.Nullable;
 import net.minecraft.network.RegistryFriendlyByteBuf;
+import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.util.ClassTreeIdRegistry;
+import net.minecraft.world.entity.LivingEntity;
 import org.apache.commons.lang3.ObjectUtils;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
 import org.slf4j.Logger;
 
 public class SynchedEntityData {
@@ -27,11 +_,13 @@
     }
 
     public static <T> EntityDataAccessor<T> defineId(Class<? extends SyncedDataHolder> p_135354_, EntityDataSerializer<T> p_135355_) {
-        if (LOGGER.isDebugEnabled()) {
+        if (LOGGER.isDebugEnabled()) { // Forge: This is very useful for mods that register keys on classes that are not their own
             try {
                 Class<?> oclass = Class.forName(Thread.currentThread().getStackTrace()[2].getClassName());
                 if (!oclass.equals(p_135354_)) {
-                    LOGGER.debug("defineId called for: {} from {}", p_135354_, oclass, new RuntimeException());
+                    // Forge: log at warn, mods should not add to classes that they don't own, and only add stacktrace when in debug is enabled as it is mostly not needed and consumes time
+                    if (LOGGER.isDebugEnabled()) LOGGER.warn("defineId called for: {} from {}", p_135354_, oclass, new RuntimeException());
+                    else LOGGER.warn("defineId called for: {} from {}", p_135354_, oclass);
                 }
             } catch (ClassNotFoundException classnotfoundexception) {
             }
@@ -58,6 +_,10 @@
     }
 
     public <T> void set(EntityDataAccessor<T> p_276368_, T p_276363_, boolean p_276370_) {
+        if (p_276368_ == LivingEntity.DATA_HEALTH_ID && this.entity instanceof ServerPlayer serverPlayer && serverPlayer.initialized) {
+            CraftPlayer player = serverPlayer.getBukkitEntity();
+            player.setRealHealth(((Float) p_276363_));
+        }
         SynchedEntityData.DataItem<T> dataitem = this.getItem(p_276368_);
         if (p_276370_ || ObjectUtils.notEqual(p_276363_, dataitem.getValue())) {
             dataitem.setValue(p_276363_);
@@ -67,6 +_,13 @@
         }
     }
 
+    // CraftBukkit start - add method from above
+    public <T> void markDirty(EntityDataAccessor<T> datawatcherobject) {
+        this.getItem(datawatcherobject).setDirty(true);
+        this.isDirty = true;
+    }
+    // CraftBukkit end
+
     public boolean isDirty() {
         return this.isDirty;
     }
@@ -169,6 +_,20 @@
             return new SynchedEntityData(this.entity, this.itemsById);
         }
     }
+
+    // Paper start
+    // We need to pack all as we cannot rely on "non default values" or "dirty" ones.
+    // Because these values can possibly be desynced on the client.
+    @Nullable
+    public List<SynchedEntityData.DataValue<?>> packAll() {
+        final List<SynchedEntityData.DataValue<?>> list = new ArrayList<>();
+        for (final DataItem<?> dataItem : this.itemsById) {
+            list.add(dataItem.value());
+        }
+
+        return list;
+    }
+    // Paper end
 
     public static class DataItem<T> {
         final EntityDataAccessor<T> accessor;
