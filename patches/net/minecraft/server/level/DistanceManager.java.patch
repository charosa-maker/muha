--- a/net/minecraft/server/level/DistanceManager.java
+++ b/net/minecraft/server/level/DistanceManager.java
@@ -23,16 +_,20 @@
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.nio.charset.StandardCharsets;
+import java.util.Collections;
+import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Set;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executor;
+import java.util.concurrent.atomic.AtomicBoolean;
 import javax.annotation.Nullable;
 import net.minecraft.core.SectionPos;
 import net.minecraft.util.SortedArraySet;
 import net.minecraft.util.thread.ProcessorHandle;
 import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.level.chunk.LevelChunk;
+import org.bukkit.plugin.Plugin;
 import org.slf4j.Logger;
 
 public abstract class DistanceManager {
@@ -45,7 +_,7 @@
     private final DistanceManager.FixedPlayerDistanceChunkTracker naturalSpawnChunkCounter = new DistanceManager.FixedPlayerDistanceChunkTracker(8);
     private final TickingTracker tickingTicketsTracker = new TickingTracker();
     private final DistanceManager.PlayerTicketTracker playerTicketManager = new DistanceManager.PlayerTicketTracker(32);
-    final Set<ChunkHolder> chunksToUpdateFutures = Sets.newHashSet();
+    final Set<ChunkHolder> chunksToUpdateFutures = Sets.newConcurrentHashSet();
     final ChunkTaskPriorityQueueSorter ticketThrottler;
     final ProcessorHandle<ChunkTaskPriorityQueueSorter.Message<Runnable>> ticketThrottlerInput;
     final ProcessorHandle<ChunkTaskPriorityQueueSorter.Release> ticketThrottlerReleaser;
@@ -54,6 +_,8 @@
     private long ticketTickCounter;
     public int simulationDistance = 10;
 
+    private final Long2ObjectOpenHashMap<SortedArraySet<Ticket<?>>> forcedTickets = new Long2ObjectOpenHashMap<>();
+
     protected DistanceManager(Executor p_140774_, Executor p_140775_) {
         ProcessorHandle<Runnable> processorhandle = ProcessorHandle.of("player ticket throttler", p_140775_::execute);
         ChunkTaskPriorityQueueSorter chunktaskpriorityqueuesorter = new ChunkTaskPriorityQueueSorter(ImmutableList.of(processorhandle), p_140774_, 4);
@@ -113,6 +_,9 @@
         }
 
         if (!this.chunksToUpdateFutures.isEmpty()) {
+            // CraftBukkit start - SPIGOT-7780: Call chunk unload events before updateHighestAllowedStatus
+            new HashSet<>(this.chunksToUpdateFutures).forEach((playerchunk) -> playerchunk.callEventIfUnloading(p_140806_));
+            // CraftBukkit end
             this.chunksToUpdateFutures.forEach(p_347062_ -> p_347062_.updateHighestAllowedStatus(p_140806_));
             this.chunksToUpdateFutures.forEach(p_183908_ -> p_183908_.updateFutures(p_140806_, this.mainThreadExecutor));
             this.chunksToUpdateFutures.clear();
@@ -144,6 +_,9 @@
         }
     }
 
+    public AtomicBoolean removeTicketCB = new AtomicBoolean(false);
+    public AtomicBoolean addTicketCB = new AtomicBoolean(false);
+
     void addTicket(long p_140785_, Ticket<?> p_140786_) {
         SortedArraySet<Ticket<?>> sortedarrayset = this.getTickets(p_140785_);
         int i = getTicketLevelAt(sortedarrayset);
@@ -152,11 +_,26 @@
         if (p_140786_.getTicketLevel() < i) {
             this.ticketTracker.update(p_140785_, p_140786_.getTicketLevel(), true);
         }
-    }
+        if (p_140786_.isForceTicks()) {
+             SortedArraySet<Ticket<?>> tickets = forcedTickets.computeIfAbsent(p_140785_, e -> SortedArraySet.create(4));
+             tickets.addOrGet(ticket);
+        }
+        addTicketCB.set(p_140786_ == ticket);
+    }
+
+    // CraftBukkit start
+    boolean addTicketCB(long p_140785_, Ticket<?> p_140786_) {
+        addTicket(p_140785_, p_140786_);
+        return addTicketCB.getAndSet(false);
+    }
+    // CraftBukkit end
+
 
     void removeTicket(long p_140819_, Ticket<?> p_140820_) {
         SortedArraySet<Ticket<?>> sortedarrayset = this.getTickets(p_140819_);
+        boolean removed = false; // CraftBukkit
         if (sortedarrayset.remove(p_140820_)) {
+            removed = true; // CraftBukkit
         }
 
         if (sortedarrayset.isEmpty()) {
@@ -164,7 +_,22 @@
         }
 
         this.ticketTracker.update(p_140819_, getTicketLevelAt(sortedarrayset), false);
-    }
+
+        if (p_140820_.isForceTicks()) {
+             SortedArraySet<Ticket<?>> tickets = forcedTickets.get(p_140819_);
+             if (tickets != null) {
+                  tickets.remove(p_140820_);
+             }
+        }
+        removeTicketCB.set(removed);
+    }
+
+    // CraftBukkit start
+    boolean removeTicketCB(long p_140819_, Ticket<?> p_140820_) {
+        removeTicket(p_140819_, p_140820_);
+        return removeTicketCB.getAndSet(false);
+    }
+    // CraftBukkit end
 
     public <T> void addTicket(TicketType<T> p_140793_, ChunkPos p_140794_, int p_140795_, T p_140796_) {
         this.addTicket(p_140794_.toLong(), new Ticket<>(p_140793_, p_140795_, p_140796_));
@@ -176,17 +_,45 @@
     }
 
     public <T> void addRegionTicket(TicketType<T> p_140841_, ChunkPos p_140842_, int p_140843_, T p_140844_) {
-        Ticket<T> ticket = new Ticket<>(p_140841_, ChunkLevel.byStatus(FullChunkStatus.FULL) - p_140843_, p_140844_);
+        addRegionTicket(p_140841_, p_140842_, p_140843_, p_140844_, false);
+    }
+    public <T> void addRegionTicket(TicketType<T> p_140841_, ChunkPos p_140842_, int p_140843_, T p_140844_, boolean forceTicks) {
+        // CraftBukkit start
+        addRegionTicketAtDistance(p_140841_, p_140842_, p_140843_, p_140844_, forceTicks);
+    }
+
+    public <T> boolean addRegionTicketAtDistance(TicketType<T> p_140841_, ChunkPos p_140842_, int p_140843_, T p_140844_) {
+        return addRegionTicketAtDistance(p_140841_, p_140842_, p_140843_, p_140844_, false);
+    }
+
+    public <T> boolean addRegionTicketAtDistance(TicketType<T> p_140841_, ChunkPos p_140842_, int p_140843_, T p_140844_, boolean forceTicks) {
+        // CraftBukkit end
+        Ticket<T> ticket = new Ticket<>(p_140841_, ChunkLevel.byStatus(FullChunkStatus.FULL) - p_140843_, p_140844_, forceTicks);
         long i = p_140842_.toLong();
-        this.addTicket(i, ticket);
+        boolean added = this.addTicketCB(i, ticket); // CraftBukkit
         this.tickingTicketsTracker.addTicket(i, ticket);
+        return added; // CraftBukkit
     }
 
     public <T> void removeRegionTicket(TicketType<T> p_140850_, ChunkPos p_140851_, int p_140852_, T p_140853_) {
-        Ticket<T> ticket = new Ticket<>(p_140850_, ChunkLevel.byStatus(FullChunkStatus.FULL) - p_140852_, p_140853_);
+        removeRegionTicket(p_140850_, p_140851_, p_140852_, p_140853_, false);
+    }
+    public <T> void removeRegionTicket(TicketType<T> p_140850_, ChunkPos p_140851_, int p_140852_, T p_140853_, boolean forceTicks) {
+        // CraftBukkit start
+        removeRegionTicketAtDistance(p_140850_, p_140851_, p_140852_, p_140853_, forceTicks);
+    }
+
+    public <T> boolean removeRegionTicketAtDistance(TicketType<T> p_140850_, ChunkPos p_140851_, int p_140852_, T p_140853_) {
+        return removeRegionTicketAtDistance(p_140850_, p_140851_, p_140852_, p_140853_, false);
+    }
+
+    public <T> boolean removeRegionTicketAtDistance(TicketType<T> p_140850_, ChunkPos p_140851_, int p_140852_, T p_140853_, boolean forceTicks) {
+        // CraftBukkit end
+        Ticket<T> ticket = new Ticket<>(p_140850_, ChunkLevel.byStatus(FullChunkStatus.FULL) - p_140852_, p_140853_, forceTicks);
         long i = p_140851_.toLong();
-        this.removeTicket(i, ticket);
+        boolean removed = this.removeTicketCB(i, ticket); // CraftBukkit
         this.tickingTicketsTracker.removeTicket(i, ticket);
+        return removed; // CraftBukkit
     }
 
     private SortedArraySet<Ticket<?>> getTickets(long p_140858_) {
@@ -218,8 +_,9 @@
         ChunkPos chunkpos = p_140829_.chunk();
         long i = chunkpos.toLong();
         ObjectSet<ServerPlayer> objectset = this.playersPerChunk.get(i);
-        objectset.remove(p_140830_);
-        if (objectset.isEmpty()) {
+        if (objectset == null) return; // CraftBukkit - SPIGOT-6208
+        if (objectset != null) objectset.remove(p_140830_); // Paper - some state corruption happens here, don't crash, clean up gracefully
+        if (objectset == null || objectset.isEmpty()) { // Paper
             this.playersPerChunk.remove(i);
             this.naturalSpawnChunkCounter.update(i, Integer.MAX_VALUE, false);
             this.playerTicketManager.update(i, Integer.MAX_VALUE, false);
@@ -269,6 +_,11 @@
         return this.ticketThrottler.getDebugStatus();
     }
 
+    public boolean shouldForceTicks(long chunkPos) {
+         SortedArraySet<Ticket<?>> tickets = forcedTickets.get(chunkPos);
+         return tickets != null && !tickets.isEmpty();
+    }
+
     private void dumpTickets(String p_143208_) {
         try (FileOutputStream fileoutputstream = new FileOutputStream(new File(p_143208_))) {
             for (Entry<SortedArraySet<Ticket<?>>> entry : this.tickets.long2ObjectEntrySet()) {
@@ -322,7 +_,27 @@
         return !this.tickets.isEmpty();
     }
 
-    public class ChunkTicketTracker extends ChunkTracker {
+    // CraftBukkit start
+    public <T> void removeAllTicketsFor(TicketType<T> ticketType, int ticketLevel, T ticketIdentifier) {
+        Ticket<T> target = new Ticket<>(ticketType, ticketLevel, ticketIdentifier);
+
+        for (java.util.Iterator<Entry<SortedArraySet<Ticket<?>>>> iterator = this.tickets.long2ObjectEntrySet().fastIterator(); iterator.hasNext();) {
+            Entry<SortedArraySet<Ticket<?>>> entry = iterator.next();
+            SortedArraySet<Ticket<?>> tickets = entry.getValue();
+            if (tickets.remove(target)) {
+                // copied from removeTicket
+                this.ticketTracker.update(entry.getLongKey(), getTicketLevelAt(tickets), false);
+                // can't use entry after it's removed
+
+                if (tickets.isEmpty()) {
+                    iterator.remove();
+                }
+            }
+        }
+    }
+    // CraftBukkit end
+
+    class ChunkTicketTracker extends ChunkTracker {
         private static final int MAX_LEVEL = ChunkLevel.MAX_LEVEL + 1;
 
         public ChunkTicketTracker() {
