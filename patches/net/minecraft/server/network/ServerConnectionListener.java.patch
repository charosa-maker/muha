--- a/net/minecraft/server/network/ServerConnectionListener.java
+++ b/net/minecraft/server/network/ServerConnectionListener.java
@@ -3,6 +_,7 @@
 import com.google.common.base.Suppliers;
 import com.google.common.collect.Lists;
 import com.google.common.util.concurrent.ThreadFactoryBuilder;
+import com.mohistmc.youer.util.I18n;
 import com.mojang.logging.LogUtils;
 import io.netty.bootstrap.ServerBootstrap;
 import io.netty.channel.Channel;
@@ -48,35 +_,69 @@
 
 public class ServerConnectionListener {
     private static final Logger LOGGER = LogUtils.getLogger();
+    private static final int READ_TIMEOUT = Integer.parseInt(System.getProperty("neoforge.readTimeout", "30"));
     public static final Supplier<NioEventLoopGroup> SERVER_EVENT_GROUP = Suppliers.memoize(
-        () -> new NioEventLoopGroup(0, new ThreadFactoryBuilder().setNameFormat("Netty Server IO #%d").setDaemon(true).build())
+        () -> new NioEventLoopGroup(0, (new ThreadFactoryBuilder()).setNameFormat("Netty Server IO #%d").setDaemon(true).setThreadFactory(net.neoforged.fml.util.thread.SidedThreadGroups.SERVER).build())
     );
     public static final Supplier<EpollEventLoopGroup> SERVER_EPOLL_EVENT_GROUP = Suppliers.memoize(
-        () -> new EpollEventLoopGroup(0, new ThreadFactoryBuilder().setNameFormat("Netty Epoll Server IO #%d").setDaemon(true).build())
+        () -> new EpollEventLoopGroup(0, (new ThreadFactoryBuilder()).setNameFormat("Netty Epoll Server IO #%d").setDaemon(true).setThreadFactory(net.neoforged.fml.util.thread.SidedThreadGroups.SERVER).build())
     );
     final MinecraftServer server;
     public volatile boolean running;
     private final List<ChannelFuture> channels = Collections.synchronizedList(Lists.newArrayList());
     final List<Connection> connections = Collections.synchronizedList(Lists.newArrayList());
+    // Paper start - prevent blocking on adding a new connection while the server is ticking
+    private final java.util.Queue<Connection> pending = new java.util.concurrent.ConcurrentLinkedQueue<>();
+    private final void addPending() {
+        Connection connection;
+        while ((connection = pending.poll()) != null) {
+            connections.add(connection);
+        }
+    }
+    // Paper end - prevent blocking on adding a new connection while the server is ticking
 
     public ServerConnectionListener(MinecraftServer p_9707_) {
         this.server = p_9707_;
         this.running = true;
     }
 
-    public void startTcpServerListener(@Nullable InetAddress p_9712_, int p_9713_) throws IOException {
+    // Paper start - Unix domain socket support
+    public void startTcpServerListener(@Nullable InetAddress address, int port) throws IOException {
+        if (address == null) address = new java.net.InetSocketAddress(port).getAddress();
+        net.neoforged.neoforge.network.DualStackUtils.checkIPv6(address);
+        bind(new java.net.InetSocketAddress(address, port));
+    }
+    public void bind(java.net.SocketAddress address) throws IOException {
+        // Paper end - Unix domain socket support
         synchronized (this.channels) {
-            Class<? extends ServerSocketChannel> oclass;
+            Class oclass;
             EventLoopGroup eventloopgroup;
             if (Epoll.isAvailable() && this.server.isEpollEnabled()) {
-                oclass = EpollServerSocketChannel.class;
+                // Paper start - Unix domain socket support
+                if (address instanceof io.netty.channel.unix.DomainSocketAddress) {
+                    oclass = io.netty.channel.epoll.EpollServerDomainSocketChannel.class;
+                } else {
+                    oclass = EpollServerSocketChannel.class;
+                }
+                // Paper end - Unix domain socket support
                 eventloopgroup = SERVER_EPOLL_EVENT_GROUP.get();
-                LOGGER.info("Using epoll channel type");
+                LOGGER.info(I18n.as("serverconnectionlistener.1"));
             } else {
                 oclass = NioServerSocketChannel.class;
                 eventloopgroup = SERVER_EVENT_GROUP.get();
-                LOGGER.info("Using default channel type");
-            }
+                LOGGER.info(I18n.as("serverconnectionlistener.2"));
+            }
+
+            // Paper start - Warn people with console access that HAProxy is in use.
+            if (io.papermc.paper.configuration.GlobalConfiguration.get().proxies.proxyProtocol) {
+                ServerConnectionListener.LOGGER.warn("Using HAProxy, please ensure the server port is adequately firewalled.");
+            }
+            // Paper end - Warn people with console access that HAProxy is in use.
+
+            // Paper start - Use Velocity cipher
+            ServerConnectionListener.LOGGER.info("Paper: Using " + com.velocitypowered.natives.util.Natives.compress.getLoadedVariant() + " compression from Velocity.");
+            ServerConnectionListener.LOGGER.info("Paper: Using " + com.velocitypowered.natives.util.Natives.cipher.getLoadedVariant() + " cipher from Velocity.");
+            // Paper end - Use Velocity cipher
 
             this.channels.add(new ServerBootstrap().channel(oclass).childHandler(new ChannelInitializer<Channel>() {
                 @Override
@@ -86,7 +_,7 @@
                     } catch (ChannelException channelexception) {
                     }
 
-                    ChannelPipeline channelpipeline = p_9729_.pipeline().addLast("timeout", new ReadTimeoutHandler(30));
+                    ChannelPipeline channelpipeline = p_9729_.pipeline().addLast("timeout", new ReadTimeoutHandler(READ_TIMEOUT));
                     if (ServerConnectionListener.this.server.repliesToStatus()) {
                         channelpipeline.addLast("legacy_query", new LegacyQueryHandler(ServerConnectionListener.this.getServer()));
                     }
@@ -94,11 +_,43 @@
                     Connection.configureSerialization(channelpipeline, PacketFlow.SERVERBOUND, false, null);
                     int i = ServerConnectionListener.this.server.getRateLimitPacketsPerSecond();
                     Connection connection = (Connection)(i > 0 ? new RateKickingConnection(i) : new Connection(PacketFlow.SERVERBOUND));
-                    ServerConnectionListener.this.connections.add(connection);
+                    // Paper start - Add support for Proxy Protocol
+                    if (io.papermc.paper.configuration.GlobalConfiguration.get().proxies.proxyProtocol) {
+                        p_9729_.pipeline().addAfter("timeout", "haproxy-decoder", new io.netty.handler.codec.haproxy.HAProxyMessageDecoder());
+                        p_9729_.pipeline().addAfter("haproxy-decoder", "haproxy-handler", new ChannelInboundHandlerAdapter() {
+                            @Override
+                            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
+                                if (msg instanceof io.netty.handler.codec.haproxy.HAProxyMessage message) {
+                                    if (message.command() == io.netty.handler.codec.haproxy.HAProxyCommand.PROXY) {
+                                        String realaddress = message.sourceAddress();
+                                        int realport = message.sourcePort();
+
+                                        SocketAddress socketaddr = new java.net.InetSocketAddress(realaddress, realport);
+
+                                        Connection connection = (Connection) p_9729_.pipeline().get("packet_handler");
+                                        connection.address = socketaddr;
+
+                                        // Paper start - Add API to get player's proxy address
+                                        final String proxyAddress = message.destinationAddress();
+                                        final int proxyPort = message.destinationPort();
+
+                                        connection.haProxyAddress = new java.net.InetSocketAddress(proxyAddress, proxyPort);
+                                        // Paper end - Add API to get player's proxy address
+                                    }
+                                } else {
+                                    super.channelRead(ctx, msg);
+                                }
+                            }
+                        });
+                    }
+                    // Paper end - Add support for proxy protocol
+                    pending.add(connection); // Paper - prevent blocking on adding a new connection while the server is ticking
+                    // ServerConnectionListener.this.connections.add(connection); // Paper
                     connection.configurePacketHandler(channelpipeline);
                     connection.setListenerForServerboundHandshake(new ServerHandshakePacketListenerImpl(ServerConnectionListener.this.server, connection));
+                    io.papermc.paper.network.ChannelInitializeListenerHolder.callListeners(p_9729_); // Paper - Add Channel initialization listeners
                 }
-            }).group(eventloopgroup).localAddress(p_9712_, p_9713_).bind().syncUninterruptibly());
+            }).group(eventloopgroup).localAddress(address).option(ChannelOption.AUTO_READ, false).bind().syncUninterruptibly()); // CraftBukkit // Paper - Unix domain socket support
         }
     }
 
@@ -146,6 +_,14 @@
 
     public void tick() {
         synchronized (this.connections) {
+            // Spigot Start
+            this.addPending(); // Paper - prevent blocking on adding a new connection while the server is ticking
+            // This prevents players from 'gaming' the server, and strategically relogging to increase their position in the tick order
+            if ( org.spigotmc.SpigotConfig.playerShuffle > 0 && MinecraftServer.currentTick % org.spigotmc.SpigotConfig.playerShuffle == 0 )
+            {
+                Collections.shuffle( this.connections );
+            }
+            // Spigot End
             Iterator<Connection> iterator = this.connections.iterator();
 
             while (iterator.hasNext()) {
@@ -180,6 +_,16 @@
     public List<Connection> getConnections() {
         return this.connections;
     }
+
+    // CraftBukkit start
+    public void acceptConnections() {
+        synchronized (this.channels) {
+            for (final ChannelFuture future : this.channels) {
+                future.channel().config().setAutoRead(true);
+            }
+        }
+    }
+    // CraftBukkit end
 
     static class LatencySimulator extends ChannelInboundHandlerAdapter {
         private static final Timer TIMER = new HashedWheelTimer();
