--- a/net/minecraft/world/level/chunk/storage/ChunkSerializer.java
+++ b/net/minecraft/world/level/chunk/storage/ChunkSerializer.java
@@ -12,6 +_,8 @@
 import java.util.Map;
 import java.util.Objects;
 import java.util.Map.Entry;
+import java.util.Set;
+import java.util.concurrent.atomic.AtomicReference;
 import javax.annotation.Nullable;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Holder;
@@ -67,6 +_,18 @@
 import org.slf4j.Logger;
 
 public class ChunkSerializer {
+    // Paper start - Attempt to recalculate regionfile header if it is corrupt
+    // TODO: Check on update
+    public static long getLastWorldSaveTime(CompoundTag chunkData) {
+        final int dataVersion = ChunkStorage.getVersion(chunkData);
+        if (dataVersion < 2842) { // Level tag is removed after this version
+            final CompoundTag levelData = chunkData.getCompound("Level");
+            return levelData.getLong("LastUpdate");
+        } else {
+            return chunkData.getLong("LastUpdate");
+        }
+    }
+    // Paper end - Attempt to recalculate regionfile header if it is corrupt
     public static final Codec<PalettedContainer<BlockState>> BLOCK_STATE_CODEC = PalettedContainer.codecRW(
         Block.BLOCK_STATE_REGISTRY, BlockState.CODEC, PalettedContainer.Strategy.SECTION_STATES, Blocks.AIR.defaultBlockState()
     );
@@ -82,6 +_,19 @@
     public static final String BLOCK_LIGHT_TAG = "BlockLight";
     public static final String SKY_LIGHT_TAG = "SkyLight";
 
+    // Paper start - guard against serializing mismatching coordinates
+    // TODO Note: This needs to be re-checked each update
+    public static ChunkPos getChunkCoordinate(final CompoundTag chunkData) {
+        final int dataVersion = ChunkStorage.getVersion(chunkData);
+        if (dataVersion < 2842) { // Level tag is removed after this version
+            final CompoundTag levelData = chunkData.getCompound("Level");
+            return new ChunkPos(levelData.getInt("xPos"), levelData.getInt("zPos"));
+        } else {
+            return new ChunkPos(chunkData.getInt("xPos"), chunkData.getInt("zPos"));
+        }
+    }
+    // Paper end - guard against serializing mismatching coordinates
+
     public static ProtoChunk read(ServerLevel p_188231_, PoiManager p_188232_, RegionStorageInfo p_352213_, ChunkPos p_188233_, CompoundTag p_188234_) {
         ChunkPos chunkpos = new ChunkPos(p_188234_.getInt("xPos"), p_188234_.getInt("zPos"));
         if (!Objects.equals(p_188233_, chunkpos)) {
@@ -183,6 +_,8 @@
                 postLoadChunk(p_188231_, p_188234_),
                 blendingdata
             );
+            if (p_188234_.contains(net.neoforged.neoforge.common.world.LevelChunkAuxiliaryLightManager.LIGHT_NBT_KEY, net.minecraft.nbt.Tag.TAG_LIST))
+                Objects.requireNonNull(((LevelChunk)chunkaccess).getAuxLightManager(p_188233_)).deserializeNBT(p_188231_.registryAccess(), p_188234_.getList(net.neoforged.neoforge.common.world.LevelChunkAuxiliaryLightManager.LIGHT_NBT_KEY, net.minecraft.nbt.Tag.TAG_COMPOUND));
         } else {
             ProtoChunkTicks<Block> protochunkticks = ProtoChunkTicks.load(
                 p_188234_.getList("block_ticks", 10), p_258992_ -> BuiltInRegistries.BLOCK.getOptional(ResourceLocation.tryParse(p_258992_)), p_188233_
@@ -209,6 +_,15 @@
             }
         }
 
+        // CraftBukkit start - load chunk persistent data from nbt
+        CompoundTag persistentBase = p_188234_.getCompound("ChunkBukkitValues");
+        if (persistentBase != null) {
+            chunkaccess.persistentDataContainer.putAll(persistentBase);
+        }
+        // CraftBukkit end
+
+        if (p_188234_.contains(net.neoforged.neoforge.attachment.AttachmentHolder.ATTACHMENTS_NBT_KEY, net.minecraft.nbt.Tag.TAG_COMPOUND))
+            chunkaccess.readAttachmentsFromNBT(p_188231_.registryAccess(), p_188234_.getCompound(net.neoforged.neoforge.attachment.AttachmentHolder.ATTACHMENTS_NBT_KEY));
         chunkaccess.setLightCorrect(flag);
         CompoundTag compoundtag2 = p_188234_.getCompound("Heightmaps");
         EnumSet<Heightmap.Types> enumset = EnumSet.noneOf(Heightmap.Types.class);
@@ -241,6 +_,7 @@
         }
 
         if (chunktype == ChunkType.LEVELCHUNK) {
+            net.neoforged.neoforge.common.NeoForge.EVENT_BUS.post(new net.neoforged.neoforge.event.level.ChunkDataEvent.Load(chunkaccess, p_188234_, chunktype));
             return new ImposterProtoChunk((LevelChunk)chunkaccess, false);
         } else {
             ProtoChunk protochunk1 = (ProtoChunk)chunkaccess;
@@ -264,11 +_,13 @@
                 protochunk1.setCarvingMask(generationstep$carving, new CarvingMask(compoundtag4.getLongArray(s1), chunkaccess.getMinBuildHeight()));
             }
 
+            net.neoforged.neoforge.common.NeoForge.EVENT_BUS.post(new net.neoforged.neoforge.event.level.ChunkDataEvent.Load(chunkaccess, p_188234_, chunktype));
             return protochunk1;
         }
     }
 
     private static void logErrors(ChunkPos p_188240_, int p_188241_, String p_188242_) {
+        if (Boolean.parseBoolean("false"))
         LOGGER.error("Recoverable errors when loading section [{}, {}, {}]: {}", p_188240_.x, p_188241_, p_188240_.z, p_188242_);
     }
 
@@ -278,6 +_,14 @@
         );
     }
 
+    // CraftBukkit start - read/write
+    private static Codec<PalettedContainer<Holder<Biome>>> makeBiomeCodecRW(Registry<Biome> p_188261_) {
+        return PalettedContainer.codecRW(
+            p_188261_.asHolderIdMap(), p_188261_.holderByNameCodec(), PalettedContainer.Strategy.SECTION_BIOMES, p_188261_.getHolderOrThrow(Biomes.PLAINS)
+        );
+    }
+    // CraftBukkit end
+
     public static CompoundTag write(ServerLevel p_63455_, ChunkAccess p_63456_) {
         ChunkPos chunkpos = p_63456_.getPos();
         CompoundTag compoundtag = NbtUtils.addCurrentDataVersion(new CompoundTag());
@@ -374,6 +_,11 @@
 
             compoundtag.put("CarvingMasks", compoundtag4);
         }
+        else if (p_63456_ instanceof LevelChunk levelChunk){
+
+             Tag lightTag = levelChunk.getAuxLightManager(chunkpos).serializeNBT(p_63455_.registryAccess());
+             if (lightTag != null) compoundtag.put(net.neoforged.neoforge.common.world.LevelChunkAuxiliaryLightManager.LIGHT_NBT_KEY, lightTag);
+        }
 
         saveTicks(p_63455_, compoundtag, p_63456_.getTicksForSerialization());
         compoundtag.put("PostProcessing", packOffsets(p_63456_.getPostProcessing()));
@@ -385,11 +_,24 @@
             }
         }
 
+        try {
+            final CompoundTag capTag = p_63456_.writeAttachmentsToNBT(p_63455_.registryAccess());
+            if (capTag != null) compoundtag.put(net.neoforged.neoforge.attachment.AttachmentHolder.ATTACHMENTS_NBT_KEY, capTag);
+        } catch (Exception exception) {
+            LOGGER.error("Failed to write chunk attachments. An attachment has likely thrown an exception trying to write state. It will not persist. Report this to the mod author", exception);
+        }
         compoundtag.put("Heightmaps", compoundtag2);
         compoundtag.put(
             "structures",
             packStructureData(StructurePieceSerializationContext.fromLevel(p_63455_), chunkpos, p_63456_.getAllStarts(), p_63456_.getAllReferences())
         );
+
+        // CraftBukkit start - store chunk persistent data in nbt
+        if (!p_63456_.persistentDataContainer.isEmpty()) {
+            compoundtag.put("ChunkBukkitValues", p_63456_.persistentDataContainer.toTagCompound());
+        }
+        // CraftBukkit end
+
         return compoundtag;
     }
 
@@ -475,6 +_,12 @@
             } else {
                 StructureStart structurestart = StructureStart.loadStaticStart(p_188255_, compoundtag.getCompound(s), p_188257_);
                 if (structurestart != null) {
+                    // CraftBukkit start - load persistent data for structure start
+                    net.minecraft.nbt.Tag persistentBase = compoundtag.getCompound(s).get("StructureBukkitValues");
+                    if (persistentBase instanceof CompoundTag) {
+                        structurestart.persistentDataContainer.putAll((CompoundTag) persistentBase);
+                    }
+                    // CraftBukkit end
                     map.put(structure, structurestart);
                 }
             }
