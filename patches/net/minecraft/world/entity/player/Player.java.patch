--- a/net/minecraft/world/entity/player/Player.java
+++ b/net/minecraft/world/entity/player/Player.java
@@ -1,8 +_,12 @@
 package net.minecraft.world.entity.player;
 
+import com.mohistmc.youer.api.event.block.PlayerMayUseItemAtEvent;
+import com.mohistmc.youer.bukkit.inventory.InventoryOwner;
+import com.mohistmc.youer.plugins.KeepInventory;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Lists;
+import com.mohistmc.youer.plugins.ban.bans.BanItem;
 import com.mojang.authlib.GameProfile;
 import com.mojang.datafixers.util.Either;
 import com.mojang.logging.LogUtils;
@@ -11,6 +_,8 @@
 import java.util.Map;
 import java.util.Optional;
 import java.util.OptionalInt;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.Predicate;
 import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
@@ -24,11 +_,9 @@
 import net.minecraft.nbt.ListTag;
 import net.minecraft.nbt.NbtOps;
 import net.minecraft.nbt.NbtUtils;
-import net.minecraft.nbt.Tag;
 import net.minecraft.network.chat.ClickEvent;
 import net.minecraft.network.chat.Component;
 import net.minecraft.network.chat.MutableComponent;
-import net.minecraft.network.chat.Style;
 import net.minecraft.network.protocol.game.ClientboundSetEntityMotionPacket;
 import net.minecraft.network.syncher.EntityDataAccessor;
 import net.minecraft.network.syncher.EntityDataSerializers;
@@ -72,7 +_,6 @@
 import net.minecraft.world.entity.ai.attributes.Attributes;
 import net.minecraft.world.entity.animal.Parrot;
 import net.minecraft.world.entity.animal.horse.AbstractHorse;
-import net.minecraft.world.entity.boss.EnderDragonPart;
 import net.minecraft.world.entity.decoration.ArmorStand;
 import net.minecraft.world.entity.item.ItemEntity;
 import net.minecraft.world.entity.monster.warden.WardenSpawnTracker;
@@ -85,12 +_,10 @@
 import net.minecraft.world.inventory.ClickAction;
 import net.minecraft.world.inventory.InventoryMenu;
 import net.minecraft.world.inventory.PlayerEnderChestContainer;
-import net.minecraft.world.item.ElytraItem;
 import net.minecraft.world.item.ItemCooldowns;
 import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.item.Items;
 import net.minecraft.world.item.ProjectileWeaponItem;
-import net.minecraft.world.item.SwordItem;
 import net.minecraft.world.item.crafting.RecipeHolder;
 import net.minecraft.world.item.enchantment.EnchantmentEffectComponents;
 import net.minecraft.world.item.enchantment.EnchantmentHelper;
@@ -110,10 +_,17 @@
 import net.minecraft.world.phys.Vec3;
 import net.minecraft.world.scores.PlayerTeam;
 import net.minecraft.world.scores.Scoreboard;
-import net.minecraft.world.scores.Team;
+import org.bukkit.Location;
+import org.bukkit.craftbukkit.entity.CraftHumanEntity;
+import org.bukkit.craftbukkit.event.CraftEventFactory;
+import org.bukkit.craftbukkit.util.CraftLocation;
+import org.bukkit.craftbukkit.util.CraftVector;
+import org.bukkit.event.entity.EntityExhaustionEvent;
+import org.bukkit.event.entity.EntityExhaustionEvent.ExhaustionReason;
 import org.slf4j.Logger;
 
 public abstract class Player extends LivingEntity implements net.neoforged.neoforge.common.extensions.IPlayerExtension {
+    public static final String PERSISTED_NBT_TAG = "PlayerPersisted";
     private static final Logger LOGGER = LogUtils.getLogger();
     public static final HumanoidArm DEFAULT_MAIN_HAND = HumanoidArm.RIGHT;
     public static final int DEFAULT_MODEL_CUSTOMIZATION = 0;
@@ -150,7 +_,7 @@
         .build();
     private static final EntityDataAccessor<Float> DATA_PLAYER_ABSORPTION_ID = SynchedEntityData.defineId(Player.class, EntityDataSerializers.FLOAT);
     private static final EntityDataAccessor<Integer> DATA_SCORE_ID = SynchedEntityData.defineId(Player.class, EntityDataSerializers.INT);
-    protected static final EntityDataAccessor<Byte> DATA_PLAYER_MODE_CUSTOMISATION = SynchedEntityData.defineId(Player.class, EntityDataSerializers.BYTE);
+    public static final EntityDataAccessor<Byte> DATA_PLAYER_MODE_CUSTOMISATION = SynchedEntityData.defineId(Player.class, EntityDataSerializers.BYTE);
     protected static final EntityDataAccessor<Byte> DATA_PLAYER_MAIN_HAND = SynchedEntityData.defineId(Player.class, EntityDataSerializers.BYTE);
     protected static final EntityDataAccessor<CompoundTag> DATA_SHOULDER_LEFT = SynchedEntityData.defineId(Player.class, EntityDataSerializers.COMPOUND_TAG);
     protected static final EntityDataAccessor<CompoundTag> DATA_SHOULDER_RIGHT = SynchedEntityData.defineId(Player.class, EntityDataSerializers.COMPOUND_TAG);
@@ -159,7 +_,7 @@
     protected PlayerEnderChestContainer enderChestInventory = new PlayerEnderChestContainer();
     public final InventoryMenu inventoryMenu;
     public AbstractContainerMenu containerMenu;
-    protected FoodData foodData = new FoodData();
+    protected FoodData foodData = new FoodData().player(this);
     protected int jumpTriggerTime;
     public float oBob;
     public float bob;
@@ -179,25 +_,65 @@
     public int enchantmentSeed;
     protected final float defaultFlySpeed = 0.02F;
     private int lastLevelUpTime;
-    private final GameProfile gameProfile;
+    public GameProfile gameProfile;
     private boolean reducedDebugInfo;
     private ItemStack lastItemInMainHand = ItemStack.EMPTY;
     private final ItemCooldowns cooldowns = this.createItemCooldowns();
     private Optional<GlobalPos> lastDeathLocation = Optional.empty();
     @Nullable
     public FishingHook fishing;
-    protected float hurtDir;
+    public float hurtDir;
     @Nullable
     public Vec3 currentImpulseImpactPos;
     @Nullable
     public Entity currentExplosionCause;
     private boolean ignoreFallDamageFromCurrentImpulse;
     private int currentImpulseContextResetGraceTime;
+    private final java.util.Collection<MutableComponent> prefixes = new java.util.LinkedList<>();
+    private final java.util.Collection<MutableComponent> suffixes = new java.util.LinkedList<>();
+    @Nullable private Pose forcedPose;
+    private long lastDayTimeTick = -1L; // Neo: Used to limit TIME_SINCE_REST increases when day length is non-standard. No need to persist, at most Phantoms will spawn one tick too early for each save/load cycle.
+    public boolean affectsSpawning = true; // Paper - Affects Spawning API
+    public net.kyori.adventure.util.TriState flyingFallDamage = net.kyori.adventure.util.TriState.NOT_SET; // Paper - flying fall damage
+
+    // CraftBukkit start
+    public boolean fauxSleeping;
+    public int oldLevel = -1;
+
+    public void setAfk(boolean afk) {
+    }
+
+    public boolean isAfk() {
+        return false;
+    }
+
+    @Override
+    public CraftHumanEntity getBukkitEntity() {
+        return (CraftHumanEntity) super.getBukkitEntity();
+    }
+    // CraftBukkit end
+
+    // Purpur start
+    public abstract void resetLastActionTime();
+
+    @Override
+    public boolean processClick(InteractionHand hand) {
+        Entity vehicle = getRootVehicle();
+        if (vehicle != null && vehicle.getRider() == this) {
+            return vehicle.onClick(hand);
+        }
+        return false;
+    }
+    // Purpur end
+
+    // Youer start
+    private EntityExhaustionEvent.ExhaustionReason causeFoodExhaustion$reason = ExhaustionReason.UNKNOWN;
 
     public Player(Level p_250508_, BlockPos p_250289_, float p_251702_, GameProfile p_252153_) {
         super(EntityType.PLAYER, p_250508_);
         this.setUUID(p_252153_.getId());
         this.gameProfile = p_252153_;
+        this.enderChestInventory.setOwner(this); // Youer
         this.inventoryMenu = new InventoryMenu(this.inventory, !p_250508_.isClientSide, this);
         this.containerMenu = this.inventoryMenu;
         this.moveTo((double)p_250289_.getX() + 0.5, (double)(p_250289_.getY() + 1), (double)p_250289_.getZ() + 0.5, p_251702_, 0.0F);
@@ -229,7 +_,8 @@
             .add(Attributes.SUBMERGED_MINING_SPEED)
             .add(Attributes.SNEAKING_SPEED)
             .add(Attributes.MINING_EFFICIENCY)
-            .add(Attributes.SWEEPING_DAMAGE_RATIO);
+            .add(Attributes.SWEEPING_DAMAGE_RATIO)
+            .add(net.neoforged.neoforge.common.NeoForgeMod.CREATIVE_FLIGHT);
     }
 
     @Override
@@ -245,6 +_,7 @@
 
     @Override
     public void tick() {
+        net.neoforged.neoforge.event.EventHooks.firePlayerTickPre(this);
         this.noPhysics = this.isSpectator();
         if (this.isSpectator()) {
             this.setOnGround(false);
@@ -256,11 +_,18 @@
 
         if (this.isSleeping()) {
             this.sleepCounter++;
+            // Paper start - Add PlayerDeepSleepEvent
+            if (this.sleepCounter == SLEEP_DURATION) {
+                if (!new io.papermc.paper.event.player.PlayerDeepSleepEvent((org.bukkit.entity.Player) getBukkitEntity()).callEvent()) {
+                    this.sleepCounter = Integer.MIN_VALUE;
+                }
+            }
+            // Paper end - Add PlayerDeepSleepEvent
             if (this.sleepCounter > 100) {
                 this.sleepCounter = 100;
             }
 
-            if (!this.level().isClientSide && this.level().isDay()) {
+            if (!this.level().isClientSide && !net.neoforged.neoforge.event.EventHooks.canEntityContinueSleeping(this, this.level().isDay() ? BedSleepingProblem.NOT_POSSIBLE_NOW : null)) {
                 this.stopSleepInBed(false, true);
             }
         } else if (this.sleepCounter > 0) {
@@ -273,6 +_,7 @@
         this.updateIsUnderwater();
         super.tick();
         if (!this.level().isClientSide && this.containerMenu != null && !this.containerMenu.stillValid(this)) {
+            InventoryOwner.setClose$Reason(org.bukkit.event.inventory.InventoryCloseEvent.Reason.CANT_USE); // Paper - Inventory close reason
             this.closeContainer();
             this.containerMenu = this.inventoryMenu;
         }
@@ -291,7 +_,11 @@
             }
 
             if (!this.isSleeping()) {
-                this.awardStat(Stats.TIME_SINCE_REST);
+                // Neo: Advance TIME_SINCE_REST if (a) vanilla daytime handling in effect, or (b) days are shorter, or (c) dayTime has ticked, or (d) dayTime advances are off and we need to ignore day length
+                if (level().getDayTimeFraction() < 0 || level().getDayTimeFraction() >= 1 || lastDayTimeTick != level().getDayTime() || !level().getGameRules().getRule(GameRules.RULE_DAYLIGHT).get()) {
+                    lastDayTimeTick = level().getDayTime();
+                    this.awardStat(Stats.TIME_SINCE_REST);
+                }
             }
         }
 
@@ -318,6 +_,7 @@
         if (this.currentImpulseContextResetGraceTime > 0) {
             this.currentImpulseContextResetGraceTime--;
         }
+        net.neoforged.neoforge.event.EventHooks.firePlayerTickPost(this);
     }
 
     @Override
@@ -345,7 +_,7 @@
     private void turtleHelmetTick() {
         ItemStack itemstack = this.getItemBySlot(EquipmentSlot.HEAD);
         if (itemstack.is(Items.TURTLE_HELMET) && !this.isEyeInFluid(FluidTags.WATER)) {
-            this.addEffect(new MobEffectInstance(MobEffects.WATER_BREATHING, 200, 0, false, false, true));
+            this.addEffect(new MobEffectInstance(MobEffects.WATER_BREATHING, 200, 0, false, false, true), org.bukkit.event.entity.EntityPotionEffectEvent.Cause.TURTLE_HELMET); // CraftBukkit
         }
     }
 
@@ -397,6 +_,10 @@
     }
 
     protected void updatePlayerPose() {
+        if(forcedPose != null) {
+            this.setPose(forcedPose);
+            return;
+        }
         if (this.canPlayerFitWithinBlocksAndEntitiesWhen(Pose.SWIMMING)) {
             Pose pose;
             if (this.isFallFlying()) {
@@ -481,6 +_,19 @@
         }
     }
 
+    // Paper start - Inventory close reason; unused code, but to keep signatures aligned
+    public void closeContainer(org.bukkit.event.inventory.InventoryCloseEvent.Reason reason) {
+        closeContainer();
+        this.containerMenu = this.inventoryMenu;
+    }
+    // Paper end - Inventory close reason
+
+    // Paper start - special close for unloaded inventory
+    public void closeUnloadedInventory(org.bukkit.event.inventory.InventoryCloseEvent.Reason reason) {
+        this.containerMenu = this.inventoryMenu;
+    }
+    // Paper end - special close for unloaded inventory
+
     public void closeContainer() {
         this.containerMenu = this.inventoryMenu;
     }
@@ -492,8 +_,14 @@
     public void rideTick() {
         if (!this.level().isClientSide && this.wantsToStopRiding() && this.isPassenger()) {
             this.stopRiding();
-            this.setShiftKeyDown(false);
-        } else {
+            // CraftBukkit start - SPIGOT-7316: no longer passenger, dismount and return
+            if (!this.isPassenger()) {
+                this.setShiftKeyDown(false);
+                return;
+            }
+        }
+        {
+            // CraftBukkit end
             super.rideTick();
             this.oBob = this.bob;
             this.bob = 0.0F;
@@ -515,7 +_,8 @@
 
         if (this.level().getDifficulty() == Difficulty.PEACEFUL && this.level().getGameRules().getBoolean(GameRules.RULE_NATURAL_REGENERATION)) {
             if (this.getHealth() < this.getMaxHealth() && this.tickCount % 20 == 0) {
-                this.heal(1.0F);
+                // CraftBukkit - added regain reason of "REGEN" for filtering purposes.
+                this.heal(1.0F, org.bukkit.event.entity.EntityRegainHealthEvent.RegainReason.REGEN);
             }
 
             if (this.foodData.getSaturationLevel() < 20.0F && this.tickCount % 20 == 0) {
@@ -566,6 +_,7 @@
         this.playShoulderEntityAmbientSound(this.getShoulderEntityLeft());
         this.playShoulderEntityAmbientSound(this.getShoulderEntityRight());
         if (!this.level().isClientSide && (this.fallDistance > 0.5F || this.isInWater()) || this.abilities.flying || this.isSleeping() || this.isInPowderSnow) {
+            if (!this.level().paperConfig().entities.behavior.parrotsAreUnaffectedByPlayerMovement) // Paper - Add option to make parrots stay
             this.removeEntitiesOnShoulder();
         }
     }
@@ -630,6 +_,7 @@
 
     @Override
     public void die(DamageSource p_36152_) {
+        if (net.neoforged.neoforge.common.CommonHooks.onLivingDeath(this, p_36152_)) return;
         super.die(p_36152_);
         this.reapplyPosition();
         if (!this.isSpectator() && this.level() instanceof ServerLevel serverlevel) {
@@ -656,6 +_,7 @@
 
     @Override
     protected void dropEquipment() {
+        if (KeepInventory.inventory(this)) return;
         super.dropEquipment();
         if (!this.level().getGameRules().getBoolean(GameRules.RULE_KEEPINVENTORY)) {
             this.destroyVanishingCursedItems();
@@ -678,17 +_,24 @@
     }
 
     @Override
-    protected SoundEvent getDeathSound() {
+    public SoundEvent getDeathSound() {
         return SoundEvents.PLAYER_DEATH;
     }
 
     @Nullable
     public ItemEntity drop(ItemStack p_36177_, boolean p_36178_) {
-        return this.drop(p_36177_, false, p_36178_);
+        return net.neoforged.neoforge.common.CommonHooks.onPlayerTossEvent(this, p_36177_, p_36178_);
     }
 
     @Nullable
     public ItemEntity drop(ItemStack p_36179_, boolean p_36180_, boolean p_36181_) {
+        // CraftBukkit start - SPIGOT-2942: Add boolean to call event
+        return drop(p_36179_, p_36180_, p_36181_, true);
+    }
+
+    @Nullable
+    public ItemEntity drop(ItemStack p_36179_, boolean p_36180_, boolean p_36181_, boolean callEvent) {
+        // CraftBukkit end
         if (p_36179_.isEmpty()) {
             return null;
         } else {
@@ -722,11 +_,43 @@
                 );
             }
 
+            // CraftBukkit start - fire PlayerDropItemEvent
+            if (!callEvent) { // SPIGOT-2942: Add boolean to call event
+                return itementity;
+            }
+            org.bukkit.entity.Player player = (org.bukkit.entity.Player) this.getBukkitEntity();
+            org.bukkit.entity.Item drop = (org.bukkit.entity.Item) itementity.getBukkitEntity();
+
+            org.bukkit.event.player.PlayerDropItemEvent event = new org.bukkit.event.player.PlayerDropItemEvent(player, drop);
+            this.level().getCraftServer().getPluginManager().callEvent(event);
+
+            if (event.isCancelled()) {
+                org.bukkit.inventory.ItemStack cur = player.getInventory().getItemInHand();
+                if (p_36181_ && (cur == null || cur.getAmount() == 0)) {
+                    // The complete stack was dropped
+                    player.getInventory().setItemInHand(drop.getItemStack());
+                } else if (p_36181_ && cur.isSimilar(drop.getItemStack()) && cur.getAmount() < cur.getMaxStackSize() && drop.getItemStack().getAmount() == 1) {
+                    // Only one item is dropped
+                    cur.setAmount(cur.getAmount() + 1);
+                    player.getInventory().setItemInHand(cur);
+                } else {
+                    // Fallback
+                    player.getInventory().addItem(drop.getItemStack());
+                }
+                return null;
+            }
+            // CraftBukkit end
+
             return itementity;
         }
     }
 
+    @Deprecated //Use location sensitive version below
     public float getDestroySpeed(BlockState p_36282_) {
+        return getDigSpeed(p_36282_, null);
+    }
+
+    public float getDigSpeed(BlockState p_36282_, @Nullable BlockPos pos) {
         float f = this.inventory.getDestroySpeed(p_36282_);
         if (f > 1.0F) {
             f += (float)this.getAttributeValue(Attributes.MINING_EFFICIENCY);
@@ -754,13 +_,19 @@
             f /= 5.0F;
         }
 
+        f = net.neoforged.neoforge.event.EventHooks.getBreakSpeed(this, p_36282_, f, pos);
         return f;
     }
 
+    @Deprecated // Neo: use position sensitive version below
     public boolean hasCorrectToolForDrops(BlockState p_36299_) {
         return !p_36299_.requiresCorrectToolForDrops() || this.inventory.getSelected().isCorrectToolForDrops(p_36299_);
     }
 
+    public boolean hasCorrectToolForDrops(BlockState state, Level level, BlockPos pos) {
+        return net.neoforged.neoforge.event.EventHooks.doPlayerHarvestCheck(this, state, level, pos);
+    }
+
     @Override
     public void readAdditionalSaveData(CompoundTag p_36215_) {
         super.readAdditionalSaveData(p_36215_);
@@ -872,7 +_,9 @@
                     this.removeEntitiesOnShoulder();
                 }
 
-                if (p_36154_.scalesWithDifficulty()) {
+                p_36155_ = Math.max(0.0F, p_36154_.type().scaling().getScalingFunction().scaleDamage(p_36154_, this, p_36155_, this.level().getDifficulty()));
+
+                if (false && p_36154_.scalesWithDifficulty()) {
                     if (this.level().getDifficulty() == Difficulty.PEACEFUL) {
                         p_36155_ = 0.0F;
                     }
@@ -895,6 +_,7 @@
     protected void blockUsingShield(LivingEntity p_36295_) {
         super.blockUsingShield(p_36295_);
         if (p_36295_.canDisableShield()) {
+            this.disableShield$attacker = p_36295_;  // Paper - Add PlayerShieldDisableEvent
             this.disableShield();
         }
     }
@@ -905,13 +_,29 @@
     }
 
     public boolean canHarmPlayer(Player p_36169_) {
-        Team team = this.getTeam();
-        Team team1 = p_36169_.getTeam();
-        if (team == null) {
+        // CraftBukkit start - Change to check OTHER player's scoreboard team according to API
+        // To summarize this method's logic, it's "Can parameter hurt this"
+        org.bukkit.scoreboard.Team team;
+        if (p_36169_ instanceof ServerPlayer) {
+            ServerPlayer thatPlayer = (ServerPlayer) p_36169_;
+            team = thatPlayer.getBukkitEntity().getScoreboard().getPlayerTeam(thatPlayer.getBukkitEntity());
+            if (team == null || team.allowFriendlyFire()) {
             return true;
+            }
         } else {
-            return !team.isAlliedTo(team1) ? true : team.isAllowFriendlyFire();
-        }
+            // This should never be called, but is implemented anyway
+            org.bukkit.OfflinePlayer thisPlayer = p_36169_.level().getCraftServer().getOfflinePlayer(p_36169_.getScoreboardName());
+            team = p_36169_.level().getCraftServer().getScoreboardManager().getMainScoreboard().getPlayerTeam(thisPlayer);
+            if (team == null || team.allowFriendlyFire()) {
+                return true;
+            }
+        }
+
+        if (this instanceof ServerPlayer) {
+            return !team.hasPlayer(((ServerPlayer) this).getBukkitEntity());
+        }
+        return !team.hasPlayer(this.level().getCraftServer().getOfflinePlayer(this.getScoreboardName()));
+        // CraftBukkit end
     }
 
     @Override
@@ -926,7 +_,7 @@
 
     @Override
     protected void hurtCurrentlyUsedShield(float p_36383_) {
-        if (this.useItem.is(Items.SHIELD)) {
+        if (this.useItem.canPerformAction(net.neoforged.neoforge.common.ItemAbilities.SHIELD_BLOCK)) {
             if (!this.level().isClientSide) {
                 this.awardStat(Stats.ITEM_USED.get(this.useItem.getItem()));
             }
@@ -934,7 +_,13 @@
             if (p_36383_ >= 3.0F) {
                 int i = 1 + Mth.floor(p_36383_);
                 InteractionHand interactionhand = this.getUsedItemHand();
-                this.useItem.hurtAndBreak(i, this, getSlotForHand(interactionhand));
+                if (this.level() instanceof ServerLevel serverlevel && !hasInfiniteMaterials()) {
+                    this.useItem.hurtAndBreak(i, serverlevel, this, item -> {
+                        this.onEquippedItemBroken(item, getSlotForHand(interactionhand));
+                        net.neoforged.neoforge.event.EventHooks.onPlayerDestroyItem(this, this.useItem, interactionhand);
+                        stopUsingItem(); // Neo: Fix MC-168573 ("After breaking a shield, the player's off-hand can't finish using some items")
+                    });
+                }
                 if (this.useItem.isEmpty()) {
                     if (interactionhand == InteractionHand.MAIN_HAND) {
                         this.setItemSlot(EquipmentSlot.MAINHAND, ItemStack.EMPTY);
@@ -952,17 +_,20 @@
     @Override
     protected void actuallyHurt(DamageSource p_36312_, float p_36313_) {
         if (!this.isInvulnerableTo(p_36312_)) {
-            p_36313_ = this.getDamageAfterArmorAbsorb(p_36312_, p_36313_);
-            p_36313_ = this.getDamageAfterMagicAbsorb(p_36312_, p_36313_);
-            float f1 = Math.max(p_36313_ - this.getAbsorptionAmount(), 0.0F);
-            this.setAbsorptionAmount(this.getAbsorptionAmount() - (p_36313_ - f1));
-            float f = p_36313_ - f1;
+            this.damageContainers.peek().setReduction(net.neoforged.neoforge.common.damagesource.DamageContainer.Reduction.ARMOR, this.damageContainers.peek().getNewDamage() - this.getDamageAfterArmorAbsorb(p_36312_, this.damageContainers.peek().getNewDamage()));
+            this.getDamageAfterMagicAbsorb(p_36312_, this.damageContainers.peek().getNewDamage());
+            float damage = net.neoforged.neoforge.common.CommonHooks.onLivingDamagePre(this, this.damageContainers.peek());
+            this.damageContainers.peek().setReduction(net.neoforged.neoforge.common.damagesource.DamageContainer.Reduction.ABSORPTION, Math.min(this.getAbsorptionAmount(), damage));
+            float absorbed = Math.min(damage, this.damageContainers.peek().getReduction(net.neoforged.neoforge.common.damagesource.DamageContainer.Reduction.ABSORPTION));
+            this.setAbsorptionAmount(Math.max(0, this.getAbsorptionAmount() - absorbed));
+            float f1 = this.damageContainers.peek().getNewDamage();
+            float f = absorbed;
             if (f > 0.0F && f < 3.4028235E37F) {
                 this.awardStat(Stats.DAMAGE_ABSORBED, Math.round(f * 10.0F));
             }
 
             if (f1 != 0.0F) {
-                this.causeFoodExhaustion(p_36312_.getFoodExhaustion());
+                this.causeFoodExhaustion(p_36312_.getFoodExhaustion(), org.bukkit.event.entity.EntityExhaustionEvent.ExhaustionReason.DAMAGED); // CraftBukkit - EntityExhaustionEvent
                 this.getCombatTracker().recordDamage(p_36312_, f1);
                 this.setHealth(this.getHealth() - f1);
                 if (f1 < 3.4028235E37F) {
@@ -970,7 +_,9 @@
                 }
 
                 this.gameEvent(GameEvent.ENTITY_DAMAGE);
+                this.onDamageTaken(this.damageContainers.peek());
             }
+            net.neoforged.neoforge.common.CommonHooks.onLivingDamagePost(this, this.damageContainers.peek());
         }
     }
 
@@ -1014,6 +_,8 @@
 
             return InteractionResult.PASS;
         } else {
+            InteractionResult cancelResult = net.neoforged.neoforge.common.CommonHooks.onInteractEntity(this, p_36158_, p_36159_);
+            if (cancelResult != null) return cancelResult;
             ItemStack itemstack = this.getItemInHand(p_36159_);
             ItemStack itemstack1 = itemstack.copy();
             InteractionResult interactionresult = p_36158_.interact(this, p_36159_);
@@ -1022,6 +_,9 @@
                     itemstack.setCount(itemstack1.getCount());
                 }
 
+                if (!this.abilities.instabuild && itemstack.isEmpty()) {
+                    net.neoforged.neoforge.event.EventHooks.onPlayerDestroyItem(this, itemstack1, p_36159_);
+                }
                 return interactionresult;
             } else {
                 if (!itemstack.isEmpty() && p_36158_ instanceof LivingEntity) {
@@ -1033,6 +_,7 @@
                     if (interactionresult1.consumesAction()) {
                         this.level().gameEvent(GameEvent.ENTITY_INTERACT, p_36158_.position(), GameEvent.Context.of(this));
                         if (itemstack.isEmpty() && !this.abilities.instabuild) {
+                            net.neoforged.neoforge.event.EventHooks.onPlayerDestroyItem(this, itemstack1, p_36159_);
                             this.setItemInHand(p_36159_, ItemStack.EMPTY);
                         }
 
@@ -1053,7 +_,7 @@
 
     @Override
     protected boolean isImmobile() {
-        return super.isImmobile() || this.isSleeping();
+        return super.isImmobile() || this.isSleeping()  || this.isRemoved() || !valid; // Paper - player's who are dead or not in a world shouldn't move...
     }
 
     @Override
@@ -1062,6 +_,7 @@
     }
 
     @Override
+    // Forge: Don't update this method to use IForgeEntity#getStepHeight() - https://github.com/MinecraftForge/MinecraftForge/issues/8922
     protected Vec3 maybeBackOffFromEdge(Vec3 p_36201_, MoverType p_36202_) {
         float f = this.maxUpStep();
         if (!this.abilities.flying
@@ -1111,6 +_,7 @@
         }
     }
 
+    // Forge: Don't update this method to use IForgeEntity#getStepHeight() - https://github.com/MinecraftForge/MinecraftForge/issues/9376
     private boolean isAboveGround(float p_341626_) {
         return this.onGround() || this.fallDistance < p_341626_ && !this.canFallAtLeast(0.0, 0.0, p_341626_ - this.fallDistance);
     }
@@ -1132,8 +_,17 @@
     }
 
     public void attack(Entity p_36347_) {
-        if (p_36347_.isAttackable()) {
-            if (!p_36347_.skipAttackInteraction(this)) {
+        if (!net.neoforged.neoforge.common.CommonHooks.onPlayerAttackTarget(this, p_36347_)) return;
+        // Paper start - PlayerAttackEntityEvent
+        boolean willAttack = p_36347_.isAttackable() && !p_36347_.skipAttackInteraction(this); // Vanilla logic
+        io.papermc.paper.event.player.PrePlayerAttackEntityEvent playerAttackEntityEvent = new io.papermc.paper.event.player.PrePlayerAttackEntityEvent(
+                (org.bukkit.entity.Player) this.getBukkitEntity(),
+                p_36347_.getBukkitEntity(),
+                willAttack
+        );
+        if (playerAttackEntityEvent.callEvent() && willAttack) { // Logic moved to willAttack local variable.
+            {
+                // Paper end - PlayerAttackEntityEvent
                 float f = this.isAutoSpinAttack() ? this.autoSpinAttackDmg : (float)this.getAttributeValue(Attributes.ATTACK_DAMAGE);
                 ItemStack itemstack = this.getWeaponItem();
                 DamageSource damagesource = this.damageSources().playerAttack(this);
@@ -1141,7 +_,6 @@
                 float f2 = this.getAttackStrengthScale(0.5F);
                 f *= 0.2F + f2 * f2 * 0.8F;
                 f1 *= f2;
-                this.resetAttackStrengthTicker();
                 if (p_36347_.getType().is(EntityTypeTags.REDIRECTABLE_PROJECTILE)
                     && p_36347_ instanceof Projectile projectile
                     && projectile.deflect(ProjectileDeflection.AIM_DEFLECT, this, this, true)) {
@@ -1170,19 +_,30 @@
                         && !this.isPassenger()
                         && p_36347_ instanceof LivingEntity
                         && !this.isSprinting();
+                    // Neo: Fire the critical hit event and override the critical hit status and damage multiplier based on the event.
+                    // The boolean local above (flag1) is the vanilla critical hit result.
+                    var critEvent = net.neoforged.neoforge.common.CommonHooks.fireCriticalHit(this, p_36347_, flag1, flag1 ? 1.5F : 1.0F);
+                    flag1 = critEvent.isCriticalHit();
+                    flag1 = flag1 && !this.level().paperConfig().entities.behavior.disablePlayerCrits; // Paper - Toggleable player crits
                     if (flag1) {
-                        f *= 1.5F;
+                        damagesource = damagesource.critical(true); // Paper start - critical damage API
+                        f *= critEvent.getDamageMultiplier();
                     }
 
                     float f3 = f + f1;
                     boolean flag2 = false;
                     double d0 = (double)(this.walkDist - this.walkDistO);
-                    if (flag4 && !flag1 && !flag && this.onGround() && d0 < (double)this.getSpeed()) {
+                    // Neo: Replace !flag1 (!isCriticalHit) with the logic from the CriticalHitEvent.
+                    boolean critBlocksSweep = critEvent.isCriticalHit() && critEvent.disableSweep();
+                    if (flag4 && !critBlocksSweep && !flag && this.onGround() && d0 < (double)this.getSpeed()) {
+                        // Neo: Make sweep attacks check SWORD_SWEEP instead of instanceof SwordItem.
                         ItemStack itemstack1 = this.getItemInHand(InteractionHand.MAIN_HAND);
-                        if (itemstack1.getItem() instanceof SwordItem) {
-                            flag2 = true;
-                        }
+                        flag2 = itemstack1.canPerformAction(net.neoforged.neoforge.common.ItemAbilities.SWORD_SWEEP);
                     }
+
+                    // Neo: Fire the SweepAttackEvent and overwrite the value of flag2 (the local controlling if a sweep will occur).
+                    var sweepEvent = net.neoforged.neoforge.common.CommonHooks.fireSweepAttack(this, p_36347_, flag2);
+                    flag2 = sweepEvent.isSweeping();
 
                     float f6 = 0.0F;
                     if (p_36347_ instanceof LivingEntity livingentity) {
@@ -1195,12 +_,15 @@
                         float f4 = this.getKnockback(p_36347_, damagesource) + (flag ? 1.0F : 0.0F);
                         if (f4 > 0.0F) {
                             if (p_36347_ instanceof LivingEntity livingentity1) {
+                                livingentity1.knockback$attacker = this;
+                                livingentity1.knockback$cause = io.papermc.paper.event.entity.EntityKnockbackEvent.Cause.ENTITY_ATTACK; // Paper - knockback events
                                 livingentity1.knockback(
                                     (double)(f4 * 0.5F),
                                     (double)Mth.sin(this.getYRot() * (float) (Math.PI / 180.0)),
                                     (double)(-Mth.cos(this.getYRot() * (float) (Math.PI / 180.0)))
                                 );
                             } else {
+                                p_36347_.pushingEntity = this; // Paper - Add EntityKnockbackByEntityEvent and EntityPushedByEntityAttackEvent
                                 p_36347_.push(
                                     (double)(-Mth.sin(this.getYRot() * (float) (Math.PI / 180.0)) * f4 * 0.5F),
                                     0.1,
@@ -1209,26 +_,38 @@
                             }
 
                             this.setDeltaMovement(this.getDeltaMovement().multiply(0.6, 1.0, 0.6));
-                            this.setSprinting(false);
+                            // Paper start - Configurable sprint interruption on attack
+                            if (!this.level().paperConfig().misc.disableSprintInterruptionOnAttack) {
+                                this.setSprinting(false);
+                            }
+                            // Paper end - Configurable sprint interruption on attack
                         }
 
                         if (flag2) {
                             float f7 = 1.0F + (float)this.getAttributeValue(Attributes.SWEEPING_DAMAGE_RATIO) * f;
 
                             for (LivingEntity livingentity2 : this.level()
-                                .getEntitiesOfClass(LivingEntity.class, p_36347_.getBoundingBox().inflate(1.0, 0.25, 1.0))) {
+                                .getEntitiesOfClass(LivingEntity.class, itemstack.getSweepHitBox(this, p_36347_))) { // Neo: Patch in item extension for custom sweep hit box
+                                double entityReachSq = Mth.square(this.entityInteractionRange()); // Use entity reach instead of constant 9.0. Vanilla uses bottom center-to-center checks here, so don't update this to use canReach, since it uses closest-corner checks.
                                 if (livingentity2 != this
                                     && livingentity2 != p_36347_
                                     && !this.isAlliedTo(livingentity2)
                                     && (!(livingentity2 instanceof ArmorStand) || !((ArmorStand)livingentity2).isMarker())
-                                    && this.distanceToSqr(livingentity2) < 9.0) {
+                                    && this.distanceToSqr(livingentity2) < entityReachSq) {
                                     float f5 = this.getEnchantedDamage(livingentity2, f7, damagesource) * f2;
+                                    // CraftBukkit start - Only apply knockback if the damage hits
+                                    if (!livingentity2.hurt(this.damageSources().playerAttack(this).sweep().critical(flag1), f5)) { // Paper - add critical damage API
+                                        continue;
+                                    }
+                                    // CraftBukkit end
+                                    livingentity2.knockback$attacker = this;
+                                    livingentity2.knockback$cause = io.papermc.paper.event.entity.EntityKnockbackEvent.Cause.SWEEP_ATTACK; // CraftBukkit // Paper - knockback events
                                     livingentity2.knockback(
                                         0.4F,
                                         (double)Mth.sin(this.getYRot() * (float) (Math.PI / 180.0)),
                                         (double)(-Mth.cos(this.getYRot() * (float) (Math.PI / 180.0)))
                                     );
-                                    livingentity2.hurt(damagesource, f5);
+                                    // livingentity2.hurt(damagesource, f5); // CraftBukkit - moved up
                                     if (this.level() instanceof ServerLevel serverlevel) {
                                         EnchantmentHelper.doPostAttackEffects(serverlevel, livingentity2, damagesource);
                                     }
@@ -1241,9 +_,26 @@
                         }
 
                         if (p_36347_ instanceof ServerPlayer && p_36347_.hurtMarked) {
-                            ((ServerPlayer)p_36347_).connection.send(new ClientboundSetEntityMotionPacket(p_36347_));
-                            p_36347_.hurtMarked = false;
-                            p_36347_.setDeltaMovement(vec3);
+                            // CraftBukkit start - Add Velocity Event
+                            boolean cancelled = false;
+                            org.bukkit.entity.Player player = (org.bukkit.entity.Player) p_36347_.getBukkitEntity();
+                            org.bukkit.util.Vector velocity = CraftVector.toBukkit(vec3);
+
+                            org.bukkit.event.player.PlayerVelocityEvent event = new org.bukkit.event.player.PlayerVelocityEvent(player, velocity.clone());
+                            this.level().getCraftServer().getPluginManager().callEvent(event);
+
+                            if (event.isCancelled()) {
+                                cancelled = true;
+                            } else if (!velocity.equals(event.getVelocity())) {
+                                player.setVelocity(event.getVelocity());
+                            }
+
+                            if (!cancelled) {
+                                ((ServerPlayer) p_36347_).connection.send(new ClientboundSetEntityMotionPacket(p_36347_));
+                                p_36347_.hurtMarked = false;
+                                p_36347_.setDeltaMovement(vec3);
+                            }
+                            // CraftBukkit end
                         }
 
                         if (flag1) {
@@ -1268,11 +_,12 @@
 
                         this.setLastHurtMob(p_36347_);
                         Entity entity = p_36347_;
-                        if (p_36347_ instanceof EnderDragonPart) {
-                            entity = ((EnderDragonPart)p_36347_).parentMob;
+                        if (p_36347_ instanceof net.neoforged.neoforge.entity.PartEntity) {
+                            entity = ((net.neoforged.neoforge.entity.PartEntity<?>) p_36347_).getParent();
                         }
 
                         boolean flag5 = false;
+                        ItemStack copy = itemstack.copy();
                         if (this.level() instanceof ServerLevel serverlevel1) {
                             if (entity instanceof LivingEntity livingentity3) {
                                 flag5 = itemstack.hurtEnemy(livingentity3, this);
@@ -1287,6 +_,7 @@
                             }
 
                             if (itemstack.isEmpty()) {
+                                net.neoforged.neoforge.event.EventHooks.onPlayerDestroyItem(this, copy, itemstack == this.getMainHandItem() ? InteractionHand.MAIN_HAND : InteractionHand.OFF_HAND);
                                 if (itemstack == this.getMainHandItem()) {
                                     this.setItemInHand(InteractionHand.MAIN_HAND, ItemStack.EMPTY);
                                 } else {
@@ -1305,12 +_,18 @@
                             }
                         }
 
-                        this.causeFoodExhaustion(0.1F);
+                        this.causeFoodExhaustion(this.level().spigotConfig.combatExhaustion, org.bukkit.event.entity.EntityExhaustionEvent.ExhaustionReason.ATTACK); // CraftBukkit - EntityExhaustionEvent // Spigot
                     } else {
                         this.level()
                             .playSound(null, this.getX(), this.getY(), this.getZ(), SoundEvents.PLAYER_ATTACK_NODAMAGE, this.getSoundSource(), 1.0F, 1.0F);
+                        // CraftBukkit start - resync on cancelled event
+                        if (this instanceof ServerPlayer) {
+                            ((ServerPlayer) this).getBukkitEntity().updateInventory();
+                        }
+                        // CraftBukkit end
                     }
                 }
+                this.resetAttackStrengthTicker(); // FORGE: Moved from beginning of attack() so that getAttackStrengthScale() returns an accurate value during all attack events
             }
         }
     }
@@ -1324,12 +_,27 @@
         this.attack(p_36355_);
     }
 
+    public LivingEntity disableShield$attacker = null;
     public void disableShield() {
-        this.getCooldowns().addCooldown(Items.SHIELD, 100);
+        final org.bukkit.entity.Entity finalAttacker = disableShield$attacker != null ? disableShield$attacker.getBukkitEntity() : null;
+        if (finalAttacker != null) {
+            final io.papermc.paper.event.player.PlayerShieldDisableEvent shieldDisableEvent = new io.papermc.paper.event.player.PlayerShieldDisableEvent((org.bukkit.entity.Player) getBukkitEntity(), finalAttacker, 100);
+            if (!shieldDisableEvent.callEvent()) return;
+            this.getCooldowns().addCooldown(Items.SHIELD, shieldDisableEvent.getCooldown());
+        } else {
+            this.getCooldowns().addCooldown(Items.SHIELD, 100);
+        }
+        // Paper end - Add PlayerShieldDisableEvent
         this.stopUsingItem();
         this.level().broadcastEntityEvent(this, (byte)30);
     }
 
+    public void disableShield(@Nullable LivingEntity attacker) {
+        disableShield$attacker = attacker;
+        disableShield();
+        disableShield$attacker = null;
+    }
+
     public void crit(Entity p_36156_) {
     }
 
@@ -1349,7 +_,13 @@
 
     @Override
     public void remove(Entity.RemovalReason p_150097_) {
-        super.remove(p_150097_);
+        // CraftBukkit start - add Bukkit remove cause
+        this.removeCB(p_150097_, null);
+    }
+
+    public void removeCB(Entity.RemovalReason p_150097_, org.bukkit.event.entity.EntityRemoveEvent.Cause cause) {
+        super.removeCB(p_150097_, cause);
+        // CraftBukkit end
         this.inventoryMenu.removed(this);
         if (this.containerMenu != null && this.hasContainerOpen()) {
             this.doCloseContainer();
@@ -1384,6 +_,12 @@
         return this.containerMenu != this.inventoryMenu;
     }
 
+    protected AtomicBoolean startSleepInBed_force = new AtomicBoolean(false);
+    public Player forceSleepInBed(boolean force) {
+        startSleepInBed_force.set(force);
+        return this;
+    }
+
     public Either<Player.BedSleepingProblem, Unit> startSleepInBed(BlockPos p_36203_) {
         this.startSleeping(p_36203_);
         this.sleepCounter = 0;
@@ -1391,6 +_,7 @@
     }
 
     public void stopSleepInBed(boolean p_36226_, boolean p_36227_) {
+        net.neoforged.neoforge.event.EventHooks.onPlayerWakeup(this, p_36226_, p_36227_);
         super.stopSleeping();
         if (this.level() instanceof ServerLevel && p_36227_) {
             ((ServerLevel)this.level()).updateSleepingPlayerList();
@@ -1452,9 +_,9 @@
         super.jumpFromGround();
         this.awardStat(Stats.JUMP);
         if (this.isSprinting()) {
-            this.causeFoodExhaustion(0.2F);
+            this.causeFoodExhaustion(this.level().spigotConfig.jumpSprintExhaustion, org.bukkit.event.entity.EntityExhaustionEvent.ExhaustionReason.JUMP_SPRINT); // CraftBukkit - EntityExhaustionEvent // Spigot
         } else {
-            this.causeFoodExhaustion(0.05F);
+            this.causeFoodExhaustion(this.level().spigotConfig.jumpWalkExhaustion, org.bukkit.event.entity.EntityExhaustionEvent.ExhaustionReason.JUMP); // CraftBukkit - EntityExhaustionEvent // Spigot
         }
     }
 
@@ -1477,7 +_,11 @@
             Vec3 vec31 = this.getDeltaMovement();
             this.setDeltaMovement(vec31.x, d2 * 0.6, vec31.z);
             this.resetFallDistance();
-            this.setSharedFlag(7, false);
+            // CraftBukkit start
+            if (this.getSharedFlag(7) && !CraftEventFactory.callToggleGlideEvent(this, false).isCancelled()) {
+                this.setSharedFlag(7, false);
+            }
+            // CraftBukkit end
         } else {
             super.travel(p_36359_);
         }
@@ -1503,7 +_,8 @@
 
     @Override
     public boolean causeFallDamage(float p_150093_, float p_150094_, DamageSource p_150095_) {
-        if (this.abilities.mayfly) {
+        if (this.mayFly() && !this.flyingFallDamage.toBooleanOrElse(false)) { // Paper - flying fall damage
+            net.neoforged.neoforge.event.EventHooks.onPlayerFall(this, p_150093_, p_150093_);
             return false;
         } else {
             if (p_150093_ >= 2.0F) {
@@ -1535,7 +_,7 @@
     public boolean tryToStartFallFlying() {
         if (!this.onGround() && !this.isFallFlying() && !this.isInWater() && !this.hasEffect(MobEffects.LEVITATION)) {
             ItemStack itemstack = this.getItemBySlot(EquipmentSlot.CHEST);
-            if (itemstack.is(Items.ELYTRA) && ElytraItem.isFlyEnabled(itemstack)) {
+            if (itemstack.canElytraFly(this)) {
                 this.startFallFlying();
                 return true;
             }
@@ -1545,12 +_,24 @@
     }
 
     public void startFallFlying() {
-        this.setSharedFlag(7, true);
+        // CraftBukkit start
+        if (!CraftEventFactory.callToggleGlideEvent(this, true).isCancelled()) {
+            this.setSharedFlag(7, true);
+        } else {
+            // SPIGOT-5542: must toggle like below
+            this.setSharedFlag(7, true);
+            this.setSharedFlag(7, false);
+        }
+        // CraftBukkit end
     }
 
     public void stopFallFlying() {
-        this.setSharedFlag(7, true);
-        this.setSharedFlag(7, false);
+        // CraftBukkit start
+        if (!CraftEventFactory.callToggleGlideEvent(this, false).isCancelled()) {
+            this.setSharedFlag(7, true);
+            this.setSharedFlag(7, false);
+        }
+        // CraftBukkit end
     }
 
     @Override
@@ -1564,13 +_,13 @@
     protected void playStepSound(BlockPos p_282121_, BlockState p_282194_) {
         if (this.isInWater()) {
             this.waterSwimSound();
-            this.playMuffledStepSound(p_282194_);
+            this.playMuffledStepSound(p_282194_, p_282121_);
         } else {
             BlockPos blockpos = this.getPrimaryStepSoundBlockPos(p_282121_);
             if (!p_282121_.equals(blockpos)) {
                 BlockState blockstate = this.level().getBlockState(blockpos);
                 if (blockstate.is(BlockTags.COMBINATION_STEP_SOUND_BLOCKS)) {
-                    this.playCombinationStepSounds(blockstate, p_282194_);
+                    this.playCombinationStepSounds(blockstate, p_282194_, blockpos, p_282121_);
                 } else {
                     super.playStepSound(blockpos, blockstate);
                 }
@@ -1601,6 +_,10 @@
     }
 
     public void giveExperiencePoints(int p_36291_) {
+        net.neoforged.neoforge.event.entity.player.PlayerXpEvent.XpChange event = new net.neoforged.neoforge.event.entity.player.PlayerXpEvent.XpChange(this, p_36291_);
+        if (net.neoforged.neoforge.common.NeoForge.EVENT_BUS.post(event).isCanceled()) return;
+        p_36291_ = event.getAmount();
+
         this.increaseScore(p_36291_);
         this.experienceProgress = this.experienceProgress + (float)p_36291_ / (float)this.getXpNeededForNextLevel();
         this.totalExperience = Mth.clamp(this.totalExperience + p_36291_, 0, Integer.MAX_VALUE);
@@ -1628,7 +_,7 @@
     }
 
     public void onEnchantmentPerformed(ItemStack p_36172_, int p_36173_) {
-        this.experienceLevel -= p_36173_;
+        giveExperienceLevels(-p_36173_);
         if (this.experienceLevel < 0) {
             this.experienceLevel = 0;
             this.experienceProgress = 0.0F;
@@ -1639,6 +_,10 @@
     }
 
     public void giveExperienceLevels(int p_36276_) {
+        net.neoforged.neoforge.event.entity.player.PlayerXpEvent.LevelChange event = new net.neoforged.neoforge.event.entity.player.PlayerXpEvent.LevelChange(this, p_36276_);
+        if (net.neoforged.neoforge.common.NeoForge.EVENT_BUS.post(event).isCanceled()) return;
+        p_36276_ = event.getLevels();
+
         this.experienceLevel += p_36276_;
         if (this.experienceLevel < 0) {
             this.experienceLevel = 0;
@@ -1664,10 +_,27 @@
     public void causeFoodExhaustion(float p_36400_) {
         if (!this.abilities.invulnerable) {
             if (!this.level().isClientSide) {
-                this.foodData.addExhaustion(p_36400_);
+                // CraftBukkit start
+                EntityExhaustionEvent event = CraftEventFactory.callPlayerExhaustionEvent(this, causeFoodExhaustion$reason, p_36400_);
+                if (!event.isCancelled()) {
+                    this.foodData.addExhaustion(event.getExhaustion());
+                }
+                // CraftBukkit end
             }
         }
     }
+
+    // Youer start
+    // CraftBukkit start
+    public void exhaustionReason(EntityExhaustionEvent.ExhaustionReason exhaustionReason) {
+        causeFoodExhaustion$reason = exhaustionReason;
+    }
+    public void causeFoodExhaustion(float f, EntityExhaustionEvent.ExhaustionReason reason) {
+        this.exhaustionReason(reason);
+        causeFoodExhaustion(f);
+    }
+    // CraftBukkit end
+    // Youer end
 
     public Optional<WardenSpawnTracker> getWardenSpawnTracker() {
         return Optional.empty();
@@ -1690,6 +_,16 @@
     }
 
     public boolean mayUseItemAt(BlockPos p_36205_, Direction p_36206_, ItemStack p_36207_) {
+        if (BanItem.check(this, p_36207_)) {
+            return false;
+        }
+        if (PlayerMayUseItemAtEvent.getHandlerList().getRegisteredListeners().length > 0) {
+            Location location = CraftLocation.toBukkit(p_36205_, level());
+            PlayerMayUseItemAtEvent event = new PlayerMayUseItemAtEvent((org.bukkit.entity.Player) this.getBukkitEntity(), location, p_36207_.getBukkitStack());
+            if (!event.callEvent()) {
+                return false;
+            }
+        }
         if (this.abilities.mayBuild) {
             return true;
         } else {
@@ -1701,6 +_,7 @@
 
     @Override
     protected int getBaseExperienceReward() {
+        if (KeepInventory.exp(this)) return 0;
         if (!this.level().getGameRules().getBoolean(GameRules.RULE_KEEPINVENTORY) && !this.isSpectator()) {
             int i = this.experienceLevel * 7;
             return i > 100 ? 100 : i;
@@ -1764,6 +_,18 @@
         }
     }
 
+    @Override
+    public void setItemSlot(EquipmentSlot p_36161_, ItemStack p_36162_, boolean silent) {
+        this.verifyEquippedItem(p_36162_);
+        if (p_36161_ == EquipmentSlot.MAINHAND) {
+            this.onEquipItem(p_36161_, this.inventory.items.set(this.inventory.selected, p_36162_), p_36162_, silent);
+        } else if (p_36161_ == EquipmentSlot.OFFHAND) {
+            this.onEquipItem(p_36161_, this.inventory.offhand.set(0, p_36162_), p_36162_, silent); // CraftBukkit
+        } else if (p_36161_.getType() == EquipmentSlot.Type.HUMANOID_ARMOR) {
+            this.onEquipItem(p_36161_, this.inventory.armor.set(p_36161_.getIndex(), p_36162_), p_36162_, silent);
+        }
+    }
+
     public boolean addItem(ItemStack p_36357_) {
         return this.inventory.add(p_36357_);
     }
@@ -1799,28 +_,69 @@
         }
     }
 
-    protected void removeEntitiesOnShoulder() {
+    public void removeEntitiesOnShoulder() {
         if (this.timeEntitySatOnShoulder + 20L < this.level().getGameTime()) {
-            this.respawnEntityOnShoulder(this.getShoulderEntityLeft());
+            // CraftBukkit start
+            if (this.spawnEntityFromShoulder(this.getShoulderEntityLeft())) {
+                this.setShoulderEntityLeft(new CompoundTag());
+            }
+            if (this.spawnEntityFromShoulder(this.getShoulderEntityRight())) {
+                this.setShoulderEntityRight(new CompoundTag());
+            }
+            // CraftBukkit end
+        }
+
+    }
+
+    // Paper start
+    public Entity releaseLeftShoulderEntity() {
+        Entity entity = this.respawnEntityOnShoulder0(this.getShoulderEntityLeft());
+        if (entity != null) {
             this.setShoulderEntityLeft(new CompoundTag());
-            this.respawnEntityOnShoulder(this.getShoulderEntityRight());
+        }
+        return entity;
+    }
+
+    public Entity releaseRightShoulderEntity() {
+        Entity entity = this.respawnEntityOnShoulder0(this.getShoulderEntityRight());
+        if (entity != null) {
             this.setShoulderEntityRight(new CompoundTag());
         }
-    }
+        return entity;
+    }
+    // Paper - maintain old signature
+
+    // Paper - return entity
+    private Entity respawnEntityOnShoulder0(CompoundTag nbttagcompound) { // CraftBukkit void->boolean
+        respawnEntityOnShoulder(nbttagcompound);
+        return spawnEntityFromShoulder.getAndSet(null);
+    }
+    // Paper end
+
+    // Youer start
+    public AtomicReference<Entity> spawnEntityFromShoulder = new AtomicReference<>(null);
 
     private void respawnEntityOnShoulder(CompoundTag p_36371_) {
         if (!this.level().isClientSide && !p_36371_.isEmpty()) {
-            EntityType.create(p_36371_, this.level()).ifPresent(p_352835_ -> {
-                if (p_352835_ instanceof TamableAnimal) {
-                    ((TamableAnimal)p_352835_).setOwnerUUID(this.uuid);
+            EntityType.create(p_36371_, this.level()).ifPresent((p_276001_) -> {
+                if (p_276001_ instanceof TamableAnimal) {
+                    ((TamableAnimal)p_276001_).setOwnerUUID(this.uuid);
                 }
 
-                p_352835_.setPos(this.getX(), this.getY() + 0.7F, this.getZ());
-                ((ServerLevel)this.level()).addWithUUID(p_352835_);
+                p_276001_.setPos(this.getX(), this.getY() + (double)0.7F, this.getZ());
+                boolean canAdd = ((ServerLevel)this.level()).addWithUUID(p_276001_);
+                if (canAdd) {
+                    spawnEntityFromShoulder.set(p_276001_);
+                }
             });
         }
     }
 
+    private boolean spawnEntityFromShoulder(CompoundTag pEntityCompound) { // CraftBukkit void->boolean
+        return this.respawnEntityOnShoulder0(pEntityCompound) != null;
+    }
+    // Youer end
+
     @Override
     public abstract boolean isSpectator();
 
@@ -1847,7 +_,11 @@
 
     @Override
     public Component getDisplayName() {
-        MutableComponent mutablecomponent = PlayerTeam.formatNameForTeam(this.getTeam(), this.getName());
+        if (this.displayname == null) this.displayname = net.neoforged.neoforge.event.EventHooks.getPlayerDisplayName(this, this.getName());
+        MutableComponent mutablecomponent = Component.literal("");
+        mutablecomponent = prefixes.stream().reduce(mutablecomponent, MutableComponent::append);
+        mutablecomponent = mutablecomponent.append(PlayerTeam.formatNameForTeam(this.getTeam(), this.displayname));
+        mutablecomponent = suffixes.stream().reduce(mutablecomponent, MutableComponent::append);
         return this.decorateDisplayNameComponent(mutablecomponent);
     }
 
@@ -2004,33 +_,44 @@
         return ImmutableList.of(Pose.STANDING, Pose.CROUCHING, Pose.SWIMMING);
     }
 
+    // Paper start - PlayerReadyArrowEvent
+    protected boolean tryReadyArrow(ItemStack bow, ItemStack itemstack) {
+        return !(this instanceof ServerPlayer) ||
+                new com.destroystokyo.paper.event.player.PlayerReadyArrowEvent(
+                        ((ServerPlayer) this).getBukkitEntity(),
+                        org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(bow),
+                        org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(itemstack)
+                ).callEvent();
+    }
+    // Paper end - PlayerReadyArrowEvent
+
     @Override
     public ItemStack getProjectile(ItemStack p_36349_) {
         if (!(p_36349_.getItem() instanceof ProjectileWeaponItem)) {
             return ItemStack.EMPTY;
         } else {
-            Predicate<ItemStack> predicate = ((ProjectileWeaponItem)p_36349_.getItem()).getSupportedHeldProjectiles();
+            Predicate<ItemStack> predicate = ((ProjectileWeaponItem)p_36349_.getItem()).getSupportedHeldProjectiles(p_36349_).and(item -> tryReadyArrow(p_36349_, item)); // Paper - PlayerReadyArrowEvent
             ItemStack itemstack = ProjectileWeaponItem.getHeldProjectile(this, predicate);
             if (!itemstack.isEmpty()) {
-                return itemstack;
+                return net.neoforged.neoforge.common.CommonHooks.getProjectile(this, p_36349_, itemstack);
             } else {
-                predicate = ((ProjectileWeaponItem)p_36349_.getItem()).getAllSupportedProjectiles();
+                predicate = ((ProjectileWeaponItem)p_36349_.getItem()).getAllSupportedProjectiles(p_36349_).and(item -> tryReadyArrow(p_36349_, item)); // Paper - PlayerReadyArrowEvent
 
                 for (int i = 0; i < this.inventory.getContainerSize(); i++) {
                     ItemStack itemstack1 = this.inventory.getItem(i);
                     if (predicate.test(itemstack1)) {
-                        return itemstack1;
+                        return net.neoforged.neoforge.common.CommonHooks.getProjectile(this, p_36349_, itemstack1);
                     }
                 }
 
-                return this.abilities.instabuild ? new ItemStack(Items.ARROW) : ItemStack.EMPTY;
+                return net.neoforged.neoforge.common.CommonHooks.getProjectile(this, p_36349_, this.abilities.instabuild ? ((ProjectileWeaponItem)p_36349_.getItem()).getDefaultCreativeAmmo(this, p_36349_) : ItemStack.EMPTY);
             }
         }
     }
 
     @Override
     public ItemStack eat(Level p_36185_, ItemStack p_36186_, FoodProperties p_347562_) {
-        this.getFoodData().eat(p_347562_);
+        this.getFoodData().eat(p_36186_, p_347562_); // CraftBukkit - add item to parameter
         this.awardStat(Stats.ITEM_USED.get(p_36186_.getItem()));
         p_36185_.playSound(
             null, this.getX(), this.getY(), this.getZ(), SoundEvents.PLAYER_BURP, SoundSource.PLAYERS, 0.5F, p_36185_.random.nextFloat() * 0.1F + 0.9F
@@ -2047,7 +_,10 @@
             }
 
             if (!this.level().isClientSide()) {
-                this.getInventory().add(optional.get().copy());
+                ItemStack container = optional.get().copy();
+                if (!getInventory().add(container)) {
+                    drop(container, false);
+                }
             }
         }
 
@@ -2089,7 +_,7 @@
     }
 
     public boolean isScoping() {
-        return this.isUsingItem() && this.getUseItem().is(Items.SPYGLASS);
+        return this.isUsingItem() && this.getUseItem().canPerformAction(net.neoforged.neoforge.common.ItemAbilities.SPYGLASS_SCOPE);
     }
 
     @Override
@@ -2188,6 +_,7 @@
 
         @Nullable
         private final Component message;
+        private Component paperMessage = null;
 
         private BedSleepingProblem() {
             this.message = null;
@@ -2199,7 +_,50 @@
 
         @Nullable
         public Component getMessage() {
+            if (paperMessage != null) return paperMessage;
             return this.message;
         }
+
+        // Youer start
+        public void setPaperMessage(Component message) {
+            this.paperMessage = message;
+        }
+        // Youer end
+    }
+
+    // Neo: Getters for the Player's name prefixes and suffixes
+    public Collection<MutableComponent> getPrefixes() {
+         return this.prefixes;
+    }
+
+    public Collection<MutableComponent> getSuffixes() {
+         return this.suffixes;
+    }
+
+    private Component displayname = null;
+
+    /**
+     * Neo: Force the displayed name to refresh, by firing {@link net.neoforged.neoforge.event.entity.player.PlayerEvent.NameFormat}, using the real player name as event parameter.
+     */
+    public void refreshDisplayName() {
+        this.displayname = net.neoforged.neoforge.event.EventHooks.getPlayerDisplayName(this, this.getName());
+    }
+
+    /**
+     * Neo: Force a pose for the player. If set, the vanilla pose determination and clearance check is skipped. Make sure the pose is clear yourself (e.g. in PlayerTick).
+     * This has to be set just once, do not set it every tick.
+     * Make sure to clear (null) the pose if not required anymore and only use if necessary.
+     */
+    public void setForcedPose(@Nullable Pose pose) {
+        this.forcedPose = pose;
+    }
+
+    /**
+     * Neo:
+     * @return The forced pose if set, null otherwise
+     */
+    @Nullable
+    public Pose getForcedPose() {
+        return this.forcedPose;
     }
 }
