--- a/net/minecraft/server/level/ServerLevel.java
+++ b/net/minecraft/server/level/ServerLevel.java
@@ -1,10 +_,19 @@
 package net.minecraft.server.level;
 
+import com.mohistmc.youer.YouerConfig;
+import com.mohistmc.youer.api.event.block.PlayerMayInteractBlockEvent;
+import com.mohistmc.youer.neoforge.NeoForgeInjectBukkit;
+import com.mohistmc.youer.plugins.ban.bans.BanEntity;
+import com.mohistmc.youer.plugins.world.utils.ConfigByWorlds;
+import com.mohistmc.youer.util.Level2LevelStem;
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.collect.Lists;
+import com.mohistmc.youer.neoforge.YouerDerivedWorldInfo;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.datafixers.util.Pair;
 import com.mojang.logging.LogUtils;
+import com.destroystokyo.paper.event.entity.EntityAddToWorldEvent;
+import com.destroystokyo.paper.event.entity.EntityRemoveFromWorldEvent;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
 import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
 import it.unimi.dsi.fastutil.longs.LongSet;
@@ -14,6 +_,7 @@
 import it.unimi.dsi.fastutil.objects.ObjectLinkedOpenHashSet;
 import it.unimi.dsi.fastutil.objects.ObjectOpenHashSet;
 import it.unimi.dsi.fastutil.objects.Object2IntMap.Entry;
+import java.io.File;
 import java.io.IOException;
 import java.io.Writer;
 import java.nio.file.Files;
@@ -27,6 +_,7 @@
 import java.util.Set;
 import java.util.UUID;
 import java.util.concurrent.Executor;
+import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.function.BooleanSupplier;
 import java.util.function.Function;
 import java.util.function.Predicate;
@@ -56,6 +_,11 @@
 import net.minecraft.network.protocol.game.ClientboundGameEventPacket;
 import net.minecraft.network.protocol.game.ClientboundLevelEventPacket;
 import net.minecraft.network.protocol.game.ClientboundLevelParticlesPacket;
+import net.minecraft.network.protocol.game.ClientboundSetBorderCenterPacket;
+import net.minecraft.network.protocol.game.ClientboundSetBorderLerpSizePacket;
+import net.minecraft.network.protocol.game.ClientboundSetBorderSizePacket;
+import net.minecraft.network.protocol.game.ClientboundSetBorderWarningDelayPacket;
+import net.minecraft.network.protocol.game.ClientboundSetBorderWarningDistancePacket;
 import net.minecraft.network.protocol.game.ClientboundSetDefaultSpawnPositionPacket;
 import net.minecraft.network.protocol.game.ClientboundSoundEntityPacket;
 import net.minecraft.network.protocol.game.ClientboundSoundPacket;
@@ -79,6 +_,7 @@
 import net.minecraft.util.profiling.ProfilerFiller;
 import net.minecraft.util.valueproviders.IntProvider;
 import net.minecraft.util.valueproviders.UniformInt;
+import net.minecraft.world.Container;
 import net.minecraft.world.DifficultyInstance;
 import net.minecraft.world.RandomSequences;
 import net.minecraft.world.TickRateManager;
@@ -98,9 +_,9 @@
 import net.minecraft.world.entity.animal.Animal;
 import net.minecraft.world.entity.animal.WaterAnimal;
 import net.minecraft.world.entity.animal.horse.SkeletonHorse;
-import net.minecraft.world.entity.boss.EnderDragonPart;
 import net.minecraft.world.entity.boss.enderdragon.EnderDragon;
 import net.minecraft.world.entity.npc.Npc;
+import net.minecraft.world.entity.npc.Villager;
 import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.entity.raid.Raid;
 import net.minecraft.world.entity.raid.Raids;
@@ -119,11 +_,15 @@
 import net.minecraft.world.level.StructureManager;
 import net.minecraft.world.level.WorldGenLevel;
 import net.minecraft.world.level.biome.Biome;
+import net.minecraft.world.level.biome.BiomeSource;
 import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.block.SnowLayerBlock;
+import net.minecraft.world.level.block.entity.BlockEntity;
 import net.minecraft.world.level.block.entity.TickingBlockEntity;
 import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.border.BorderChangeListener;
+import net.minecraft.world.level.border.WorldBorder;
 import net.minecraft.world.level.chunk.ChunkAccess;
 import net.minecraft.world.level.chunk.ChunkGenerator;
 import net.minecraft.world.level.chunk.LevelChunk;
@@ -132,6 +_,7 @@
 import net.minecraft.world.level.chunk.storage.RegionStorageInfo;
 import net.minecraft.world.level.chunk.storage.SimpleRegionStorage;
 import net.minecraft.world.level.dimension.BuiltinDimensionTypes;
+import net.minecraft.world.level.dimension.DimensionType;
 import net.minecraft.world.level.dimension.LevelStem;
 import net.minecraft.world.level.dimension.end.EndDragonFight;
 import net.minecraft.world.level.entity.EntityPersistentStorage;
@@ -143,7 +_,9 @@
 import net.minecraft.world.level.gameevent.DynamicGameEventListener;
 import net.minecraft.world.level.gameevent.GameEvent;
 import net.minecraft.world.level.gameevent.GameEventDispatcher;
+import net.minecraft.world.level.levelgen.FlatLevelSource;
 import net.minecraft.world.level.levelgen.Heightmap;
+import net.minecraft.world.level.levelgen.NoiseBasedChunkGenerator;
 import net.minecraft.world.level.levelgen.structure.BoundingBox;
 import net.minecraft.world.level.levelgen.structure.Structure;
 import net.minecraft.world.level.levelgen.structure.StructureCheck;
@@ -155,8 +_,10 @@
 import net.minecraft.world.level.saveddata.maps.MapId;
 import net.minecraft.world.level.saveddata.maps.MapIndex;
 import net.minecraft.world.level.saveddata.maps.MapItemSavedData;
+import net.minecraft.world.level.storage.DerivedLevelData;
 import net.minecraft.world.level.storage.DimensionDataStorage;
 import net.minecraft.world.level.storage.LevelStorageSource;
+import net.minecraft.world.level.storage.PrimaryLevelData;
 import net.minecraft.world.level.storage.ServerLevelData;
 import net.minecraft.world.phys.AABB;
 import net.minecraft.world.phys.Vec3;
@@ -164,7 +_,24 @@
 import net.minecraft.world.phys.shapes.Shapes;
 import net.minecraft.world.phys.shapes.VoxelShape;
 import net.minecraft.world.ticks.LevelTicks;
+import org.bukkit.Bukkit;
+import org.bukkit.Location;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.event.CraftEventFactory;
+import org.bukkit.craftbukkit.generator.CraftWorldInfo;
+import org.bukkit.craftbukkit.generator.CustomChunkGenerator;
+import org.bukkit.craftbukkit.generator.CustomWorldChunkManager;
+import org.bukkit.craftbukkit.util.CraftLocation;
+import org.bukkit.craftbukkit.util.WorldUUID;
+import org.bukkit.event.entity.CreatureSpawnEvent;
+import org.bukkit.event.server.MapInitializeEvent;
+import org.bukkit.event.weather.LightningStrikeEvent;
+import org.bukkit.event.world.TimeSkipEvent;
+import org.bukkit.event.world.WorldSaveEvent;
+import org.bukkit.generator.WorldInfo;
 import org.slf4j.Logger;
+import org.spigotmc.AsyncCatcher;
+import org.spigotmc.SpigotWorldConfig;
 
 public class ServerLevel extends Level implements WorldGenLevel {
     public static final BlockPos END_SPAWN_POINT = new BlockPos(100, 50, 0);
@@ -176,7 +_,7 @@
     private static final int EMPTY_TIME_NO_TICK = 300;
     private static final int MAX_SCHEDULED_TICKS_PER_TICK = 65536;
     final List<ServerPlayer> players = Lists.newArrayList();
-    private final ServerChunkCache chunkSource;
+    public final ServerChunkCache chunkSource;
     private final MinecraftServer server;
     public final ServerLevelData serverLevelData;
     private int lastSpawnChunkRadius;
@@ -199,12 +_,84 @@
     private final List<CustomSpawner> customSpawners;
     @Nullable
     private EndDragonFight dragonFight;
-    final Int2ObjectMap<EnderDragonPart> dragonParts = new Int2ObjectOpenHashMap<>();
+    final Int2ObjectMap<net.neoforged.neoforge.entity.PartEntity<?>> dragonParts = new Int2ObjectOpenHashMap<>();
     private final StructureManager structureManager;
     private final StructureCheck structureCheck;
     private final boolean tickTime;
     private final RandomSequences randomSequences;
 
+    public PrimaryLevelData K;
+    public final LevelStorageSource.LevelStorageAccess convertable;
+    public final UUID uuid;
+    public ResourceKey<LevelStem> typeKey;
+    public boolean hasEntityMoveEvent; // Paper - Add EntityMoveEvent
+    public boolean hasPhysicsEvent = true; // Paper - BlockPhysicsEvent
+    public boolean hasRidableMoveEvent = false; // Purpur
+
+    @Override
+    public ResourceKey<LevelStem> getTypeKey() {
+        return typeKey == null ? super.getTypeKey() : typeKey;
+    }
+
+    public CraftWorld getWorld() {
+        return this.world;
+    }
+
+
+    // Paper start
+    public final boolean areChunksLoadedForMove(AABB axisalignedbb) {
+        // copied code from collision methods, so that we can guarantee that they wont load chunks (we don't override
+        // ICollisionAccess methods for VoxelShapes)
+        // be more strict too, add a block (dumb plugins in move events?)
+        int minBlockX = Mth.floor(axisalignedbb.minX - 1.0E-7D) - 3;
+        int maxBlockX = Mth.floor(axisalignedbb.maxX + 1.0E-7D) + 3;
+
+        int minBlockZ = Mth.floor(axisalignedbb.minZ - 1.0E-7D) - 3;
+        int maxBlockZ = Mth.floor(axisalignedbb.maxZ + 1.0E-7D) + 3;
+
+        int minChunkX = minBlockX >> 4;
+        int maxChunkX = maxBlockX >> 4;
+
+        int minChunkZ = minBlockZ >> 4;
+        int maxChunkZ = maxBlockZ >> 4;
+
+        ServerChunkCache chunkProvider = this.getChunkSource();
+
+        for (int cx = minChunkX; cx <= maxChunkX; ++cx) {
+            for (int cz = minChunkZ; cz <= maxChunkZ; ++cz) {
+                if (chunkProvider.getChunkAtIfLoadedImmediately(cx, cz) == null) {
+                    return false;
+                }
+            }
+        }
+
+        return true;
+    }
+
+    public LevelChunk getChunkIfLoaded(int x, int z) {
+        return this.chunkSource.getChunkAtIfLoadedImmediately(x, z); // Paper - Use getChunkIfLoadedImmediately
+    }
+
+    // Paper start - optimise getPlayerByUUID
+    @Nullable
+    @Override
+    public Player getPlayerByUUID(UUID uuid) {
+        final Player player = this.getServer().getPlayerList().getPlayer(uuid);
+        return player != null && player.level() == this ? player : null;
+    }
+    // Paper end - optimise getPlayerByUUID
+    // Paper start - lag compensation
+    private long lagCompensationTick = net.minecraft.server.MinecraftServer.SERVER_INIT;
+
+    public long getLagCompensationTick() {
+        return this.lagCompensationTick;
+    }
+
+    public void updateLagCompensationTick() {
+        this.lagCompensationTick = (System.nanoTime() - net.minecraft.server.MinecraftServer.SERVER_INIT) / (java.util.concurrent.TimeUnit.MILLISECONDS.toNanos(50L));
+    }
+    // Paper end - lag compensation
+
     public ServerLevel(
         MinecraftServer p_214999_,
         Executor p_215000_,
@@ -230,11 +_,68 @@
             p_215007_,
             p_214999_.getMaxChainedNeighborUpdates()
         );
+        // CraftBukkit start
+        this.pvpMode = p_214999_.isPvpAllowed();
+        this.convertable = p_215001_;
+        // Youer start
+        File worldFile = DimensionType.getStorageFolder(p_215003_, p_215001_.levelDirectory.path()).toFile();
+        uuid = Level2LevelStem.bukkit != null ? WorldUUID.getUUID(Level2LevelStem.bukkit) : WorldUUID.getUUID(worldFile);
+        name = Level2LevelStem.bukkit != null ? Level2LevelStem.bukkit_name : worldFile.getName();
+        var typeKey = p_215001_.dimensionType;
+        if (typeKey != null) {
+            this.typeKey = typeKey;
+        } else {
+            var dimensions = p_214999_.registryAccess().registryOrThrow(Registries.LEVEL_STEM);
+            var key = dimensions.getResourceKey(p_215004_);
+            if (key.isPresent()) {
+                this.typeKey = key.get();
+            } else {
+                this.typeKey = ResourceKey.create(Registries.LEVEL_STEM, dimension.location());
+            }
+            if (p_215002_ instanceof DerivedLevelData data) {
+                data.setTypeKey(this.getTypeKey());
+            }
+        }
         this.tickTime = p_215009_;
         this.server = p_214999_;
-        this.customSpawners = p_215008_;
         this.serverLevelData = p_215002_;
+        if (p_215002_ instanceof PrimaryLevelData) {
+            this.K = (PrimaryLevelData) p_215002_;
+        } else {
+            this.K = YouerDerivedWorldInfo.create(p_215002_);
+        }
         ChunkGenerator chunkgenerator = p_215004_.generator();
+        if (environment == null) {
+            environment = NeoForgeInjectBukkit.environment.get(getTypeKey());
+        }
+        if (biomeProvider != null) {
+            WorldInfo worldInfo = new CraftWorldInfo(K, p_215001_, environment, p_215004_.type().value(), chunkgenerator, p_214999_.registryAccess());
+            BiomeSource worldChunkManager = new CustomWorldChunkManager(worldInfo, biomeProvider, server.registryAccess().registryOrThrow(Registries.BIOME), chunkgenerator.getBiomeSource()); // Paper - add vanillaBiomeProvider
+            if (chunkgenerator instanceof NoiseBasedChunkGenerator cga) {
+                chunkgenerator = new NoiseBasedChunkGenerator(worldChunkManager, cga.settings);
+            } else if (chunkgenerator instanceof FlatLevelSource cpf) {
+                chunkgenerator = new FlatLevelSource(cpf.settings(), worldChunkManager);
+            }
+        } else {
+            biomeProvider = getCraftServer().getBiomeProvider(name);
+        }
+
+        if (generator != null) {
+            chunkgenerator = new CustomChunkGenerator(this, chunkgenerator, generator);
+        } else {
+            generator = getCraftServer().getGenerator(name);
+        }
+        this.spigotConfig = new SpigotWorldConfig(name); // Spigot
+        paperWorldConfigCreator = spigotConfig -> p_214999_.paperConfigurations.createWorldConfig(
+                io.papermc.paper.configuration.PaperConfigurations.createWorldContextMap(
+                        p_215001_.levelDirectory.path(),
+                        name, // Youer  - use world name
+                        p_215003_.location(),
+                        spigotConfig,
+                        p_214999_.registryAccess(),
+                        (K != null ? K.getGameRules() : serverLevelData.getGameRules())));
+        this.paperConfig = paperWorldConfigCreator.apply(this.spigotConfig); // Paper - create paper world config
+        this.purpurConfig = new org.purpurmc.purpur.PurpurWorldConfig(name, environment); // Purpur
         boolean flag = p_214999_.forceSynchronousWrites();
         DataFixer datafixer = p_214999_.getFixerUpper();
         EntityPersistentStorage<Entity> entitypersistentstorage = new EntityStorage(
@@ -256,8 +_,8 @@
             p_214999_.getStructureManager(),
             p_215000_,
             chunkgenerator,
-            p_214999_.getPlayerList().getViewDistance(),
-            p_214999_.getPlayerList().getSimulationDistance(),
+            this.spigotConfig.viewDistance, // Spigot
+            this.spigotConfig.simulationDistance, // Spigot
             flag,
             p_215005_,
             this.entityManager::updateChunkStatus,
@@ -286,8 +_,8 @@
             i,
             datafixer
         );
-        this.structureManager = new StructureManager(this, p_214999_.getWorldData().worldGenOptions(), this.structureCheck);
-        if (this.dimension() == Level.END && this.dimensionTypeRegistration().is(BuiltinDimensionTypes.END)) {
+        this.structureManager = new StructureManager(this, this.K.worldGenOptions(), this.structureCheck); // CraftBukkit
+        if (this.dimension() == Level.END && this.dimensionTypeRegistration().is(BuiltinDimensionTypes.END) || environment == org.bukkit.World.Environment.THE_END) { // CraftBukkit - Allow to create EnderDragonBattle in default and custom END
             this.dragonFight = new EndDragonFight(this, i, p_214999_.getWorldData().endDragonFightData());
         } else {
             this.dragonFight = null;
@@ -298,6 +_,52 @@
         this.randomSequences = Objects.requireNonNullElseGet(
             p_288977_, () -> this.getDataStorage().computeIfAbsent(RandomSequences.factory(i), "random_sequences")
         );
+
+        net.neoforged.neoforge.attachment.LevelAttachmentsSavedData.init(this);
+        // Neo: Move the initialization of customSpawners to the end of costructor
+        // Providing a fully initialized ServerLevel instance for the ServerLevelEvent.CustomSpawners
+        this.customSpawners = net.neoforged.neoforge.event.EventHooks.getCustomSpawners(this, p_215008_);
+        this.world = new CraftWorld(this, generator, biomeProvider, environment);
+        this.getCraftServer().addWorld(this.getWorld()); // CraftBukkit
+        this.K.setWorld(this);
+        // CraftBukkit start
+        getWorldBorder().world = this;
+        // From PlayerList.setPlayerFileData
+        getWorldBorder().addListener(new BorderChangeListener() {
+
+            @Override
+            public void onBorderSizeSet(WorldBorder pBorder, double pSize) {
+                getCraftServer().getHandle().broadcastAll(new ClientboundSetBorderSizePacket(pBorder), pBorder.world.dimension());
+            }
+
+            @Override
+            public void onBorderSizeLerping(WorldBorder pBorder, double pOldSize, double pNewSize, long pTime) {
+                getCraftServer().getHandle().broadcastAll(new ClientboundSetBorderLerpSizePacket(pBorder), pBorder.world.dimension());
+            }
+
+            @Override
+            public void onBorderCenterSet(WorldBorder pBorder, double pX, double pZ) {
+                getCraftServer().getHandle().broadcastAll(new ClientboundSetBorderCenterPacket(pBorder), pBorder.world.dimension());
+            }
+
+            @Override
+            public void onBorderSetWarningTime(WorldBorder pBorder, int pWarningTime) {
+                getCraftServer().getHandle().broadcastAll(new ClientboundSetBorderWarningDelayPacket(pBorder), pBorder.world.dimension());
+            }
+
+            @Override
+            public void onBorderSetWarningBlocks(WorldBorder pBorder, int pWarningBlocks) {
+                getCraftServer().getHandle().broadcastAll(new ClientboundSetBorderWarningDistancePacket(pBorder), pBorder.world.dimension());
+            }
+
+            @Override
+            public void onBorderSetDamagePerBlock(WorldBorder pBorder, double pDamagePerBlock) { }
+
+            @Override
+            public void onBorderSetDamageSafeZOne(WorldBorder pBorder, double pDamageSafeZone) { }
+        });
+        // CraftBukkit end
+        ConfigByWorlds.initMods(this);
     }
 
     @Deprecated
@@ -340,12 +_,21 @@
 
         int i = this.getGameRules().getInt(GameRules.RULE_PLAYERS_SLEEPING_PERCENTAGE);
         if (this.sleepStatus.areEnoughSleeping(i) && this.sleepStatus.areEnoughDeepSleeping(i, this.players)) {
+            long j = this.levelData.getDayTime() + 24000L;
+            // CraftBukkit start
+            TimeSkipEvent event = new TimeSkipEvent(this.getWorld(), TimeSkipEvent.SkipReason.NIGHT_SKIP, net.neoforged.neoforge.event.EventHooks.onSleepFinished(this, j - j % 24000L, this.getDayTime()) - this.getDayTime());
             if (this.getGameRules().getBoolean(GameRules.RULE_DAYLIGHT)) {
-                long j = this.levelData.getDayTime() + 24000L;
-                this.setDayTime(j - j % 24000L);
-            }
-
-            this.wakeUpAllPlayers();
+                this.getCraftServer().getPluginManager().callEvent(event);
+                if (!event.isCancelled()) {
+                    this.setDayTime(this.getDayTime() + event.getSkipAmount());
+                }
+            }
+
+            if (!event.isCancelled()) {
+                this.wakeUpAllPlayers();
+            }
+            // CraftBukkit end
+
             if (this.getGameRules().getBoolean(GameRules.RULE_WEATHER_CYCLE) && this.isRaining()) {
                 this.resetWeatherCycle();
             }
@@ -360,9 +_,9 @@
         if (!this.isDebug() && flag) {
             long k = this.getGameTime();
             profilerfiller.push("blockTicks");
-            this.blockTicks.tick(k, 65536, this::tickBlock);
+            this.blockTicks.tick(k, paperConfig().environment.maxBlockTicks, this::tickBlock); // Paper - configurable max block ticks
             profilerfiller.popPush("fluidTicks");
-            this.fluidTicks.tick(k, 65536, this::tickFluid);
+            this.fluidTicks.tick(k, paperConfig().environment.maxFluidTicks, this::tickFluid); // Paper - configurable max block ticks
             profilerfiller.pop();
         }
 
@@ -380,7 +_,7 @@
 
         this.handlingTick = false;
         profilerfiller.pop();
-        boolean flag1 = !this.players.isEmpty() || !this.getForcedChunks().isEmpty();
+        boolean flag1 = !paperConfig().unsupportedSettings.disableWorldTickingWhenEmpty || !this.players.isEmpty() || net.neoforged.neoforge.common.world.chunk.ForcedChunkManager.hasForcedChunks(this); // Neo: Replace vanilla's has forced chunk check with neo's that checks both the vanilla and neo added ones
         if (flag1) {
             this.resetEmptyTime();
         }
@@ -393,6 +_,7 @@
                 profilerfiller.pop();
             }
 
+            org.spigotmc.ActivationRange.activateEntities(this); // Spigot
             this.entityTickList.forEach(p_308566_ -> {
                 if (!p_308566_.isRemoved()) {
                     if (this.shouldDiscardEntity(p_308566_)) {
@@ -412,7 +_,9 @@
                             }
 
                             profilerfiller.push("tick");
-                            this.guardEntityTick(this::tickNonPassenger, p_308566_);
+                            if (!p_308566_.isRemoved() && !(p_308566_ instanceof net.neoforged.neoforge.entity.PartEntity)) {
+                                this.guardEntityTick(this::tickNonPassenger, p_308566_);
+                            }
                             profilerfiller.pop();
                         }
                     }
@@ -420,6 +_,7 @@
             });
             profilerfiller.pop();
             this.tickBlockEntities();
+            spigotConfig.currentPrimedTnt = 0; // Spigot // Mohist move form Level#tickBlockEntities
         }
 
         profilerfiller.push("entityManagement");
@@ -438,7 +_,7 @@
             this.serverLevelData.setGameTime(i);
             this.serverLevelData.getScheduledEvents().tick(this.server, i);
             if (this.levelData.getGameRules().getBoolean(GameRules.RULE_DAYLIGHT)) {
-                this.setDayTime(this.levelData.getDayTime() + 1L);
+                this.setDayTime(this.levelData.getDayTime() + advanceDaytime());
             }
         }
     }
@@ -471,19 +_,20 @@
         int j = chunkpos.getMinBlockZ();
         ProfilerFiller profilerfiller = this.getProfiler();
         profilerfiller.push("thunder");
-        if (flag && this.isThundering() && this.random.nextInt(100000) == 0) {
+        if (!this.paperConfig().environment.disableThunder && flag && this.isThundering() && this.spigotConfig.thunderChance > 0 && this.random.nextInt(this.spigotConfig.thunderChance) == 0) { // Spigot // Paper - Option to disable thunder
             BlockPos blockpos = this.findLightningTargetAround(this.getBlockRandomPos(i, 0, j, 15));
             if (this.isRainingAt(blockpos)) {
                 DifficultyInstance difficultyinstance = this.getCurrentDifficultyAt(blockpos);
                 boolean flag1 = this.getGameRules().getBoolean(GameRules.RULE_DOMOBSPAWNING)
-                    && this.random.nextDouble() < (double)difficultyinstance.getEffectiveDifficulty() * 0.01
-                    && !this.getBlockState(blockpos.below()).is(Blocks.LIGHTNING_ROD);
+                    && this.random.nextDouble() < (double)difficultyinstance.getEffectiveDifficulty() * this.paperConfig().entities.spawning.skeletonHorseThunderSpawnChance.or(0.01D)
+                    && !(this.getBlockState(blockpos.below()).getBlock() instanceof net.minecraft.world.level.block.LightningRodBlock); // Neo: support custom LightningRodBlocks
                 if (flag1) {
                     SkeletonHorse skeletonhorse = EntityType.SKELETON_HORSE.create(this);
                     if (skeletonhorse != null) {
                         skeletonhorse.setTrap(true);
                         skeletonhorse.setAge(0);
                         skeletonhorse.setPos((double)blockpos.getX(), (double)blockpos.getY(), (double)blockpos.getZ());
+                        skeletonhorse.spawnReason(org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.LIGHTNING);
                         this.addFreshEntity(skeletonhorse);
                     }
                 }
@@ -492,18 +_,27 @@
                 if (lightningbolt != null) {
                     lightningbolt.moveTo(Vec3.atBottomCenterOf(blockpos));
                     lightningbolt.setVisualOnly(flag1);
+                    // Youer start - fix mixin
+                    LightningStrikeEvent lightning = CraftEventFactory.callLightningStrikeEvent((org.bukkit.entity.LightningStrike) lightningbolt.getBukkitEntity(), org.bukkit.event.weather.LightningStrikeEvent.Cause.WEATHER);
+
+                    if (lightning.isCancelled()) {
+                        return;
+                    }
                     this.addFreshEntity(lightningbolt);
+                    // Youer end
                 }
             }
         }
 
         profilerfiller.popPush("iceandsnow");
 
-        for (int i1 = 0; i1 < p_8716_; i1++) {
+        if (!this.paperConfig().environment.disableIceAndSnow) { // Paper - Option to disable ice and snow
+            for (int i1 = 0; i1 < p_8716_; i1++) {
             if (this.random.nextInt(48) == 0) {
                 this.tickPrecipitation(this.getBlockRandomPos(i, 0, j, 15));
             }
         }
+        } // Paper - Option to disable ice and snow
 
         profilerfiller.popPush("tickBlocks");
         if (p_8716_ > 0) {
@@ -542,8 +_,11 @@
         BlockPos blockpos = this.getHeightmapPos(Heightmap.Types.MOTION_BLOCKING, p_295060_);
         BlockPos blockpos1 = blockpos.below();
         Biome biome = this.getBiome(blockpos).value();
+        if (this.isAreaLoaded(blockpos1, 1)) // Forge: check area to avoid loading neighbors in unloaded chunks
         if (biome.shouldFreeze(this, blockpos1)) {
+            this.callEvent(true);
             this.setBlockAndUpdate(blockpos1, Blocks.ICE.defaultBlockState());
+            CraftEventFactory.handleBlockFormEvent(this, blockpos1, this.mohist$defaultBlockState, null); // CraftBukkit
         }
 
         if (this.isRaining()) {
@@ -555,10 +_,14 @@
                     if (j < Math.min(i, 8)) {
                         BlockState blockstate1 = blockstate.setValue(SnowLayerBlock.LAYERS, Integer.valueOf(j + 1));
                         Block.pushEntitiesUp(blockstate, blockstate1, this, blockpos);
-                        this.setBlockAndUpdate(blockpos, blockstate1);
+                        this.callEvent(true);
+                        this.setBlockAndUpdate(blockpos1, blockstate1);
+                        CraftEventFactory.handleBlockFormEvent(this, blockpos, this.mohist$defaultBlockState, null); // CraftBukkit
                     }
                 } else {
-                    this.setBlockAndUpdate(blockpos, Blocks.SNOW.defaultBlockState());
+                    this.callEvent(true);
+                    this.setBlockAndUpdate(blockpos1, Blocks.SNOW.defaultBlockState());
+                    CraftEventFactory.handleBlockFormEvent(this, blockpos, this.mohist$defaultBlockState, null); // CraftBukkit
                 }
             }
 
@@ -570,7 +_,7 @@
         }
     }
 
-    private Optional<BlockPos> findLightningRod(BlockPos p_143249_) {
+    public Optional<BlockPos> findLightningRod(BlockPos p_143249_) {
         Optional<BlockPos> optional = this.getPoiManager()
             .findClosest(
                 p_215059_ -> p_215059_.is(PoiTypes.LIGHTNING_ROD),
@@ -582,7 +_,10 @@
         return optional.map(p_184053_ -> p_184053_.above(1));
     }
 
-    protected BlockPos findLightningTargetAround(BlockPos p_143289_) {
+    public AtomicBoolean findLightningTargetAround$returnNullWhenNoTarget = new AtomicBoolean(false);
+
+    public BlockPos findLightningTargetAround(BlockPos p_143289_) {
+        // Paper end - Add methods to find targets for lightning strikes
         BlockPos blockpos = this.getHeightmapPos(Heightmap.Types.MOTION_BLOCKING, p_143289_);
         Optional<BlockPos> optional = this.findLightningRod(blockpos);
         if (optional.isPresent()) {
@@ -590,11 +_,12 @@
         } else {
             AABB aabb = AABB.encapsulatingFullBlocks(blockpos, new BlockPos(blockpos.atY(this.getMaxBuildHeight()))).inflate(3.0);
             List<LivingEntity> list = this.getEntitiesOfClass(
-                LivingEntity.class, aabb, p_352698_ -> p_352698_ != null && p_352698_.isAlive() && this.canSeeSky(p_352698_.blockPosition())
+                    LivingEntity.class, aabb, p_352698_ -> p_352698_ != null && p_352698_.isAlive() && this.canSeeSky(p_352698_.blockPosition()) && !p_352698_.isSpectator() // Paper - Fix lightning being able to hit spectators (MC-262422)
             );
             if (!list.isEmpty()) {
                 return list.get(this.random.nextInt(list.size())).blockPosition();
             } else {
+                if (findLightningTargetAround$returnNullWhenNoTarget.getAndSet(false)) return null; // Paper - Add methods to find targets for lightning strikes
                 if (blockpos.getY() == this.getMinBuildHeight() - 1) {
                     blockpos = blockpos.above(2);
                 }
@@ -603,6 +_,10 @@
             }
         }
     }
+    public BlockPos findLightningTargetAround(BlockPos p_143289_, boolean returnNullWhenNoTarget) {
+        findLightningTargetAround$returnNullWhenNoTarget.set(returnNullWhenNoTarget);
+        return findLightningTargetAround(p_143289_);
+    }
 
     public boolean isHandlingTick() {
         return this.handlingTick;
@@ -714,15 +_,19 @@
                 .broadcastAll(new ClientboundGameEventPacket(ClientboundGameEventPacket.THUNDER_LEVEL_CHANGE, this.thunderLevel), this.dimension());
         }
 
+        /* The function in use here has been replaced in order to only send the weather info to players in the correct dimension,
+         * rather than to all players on the server. This is what causes the client-side rain, as the
+         * client believes that it has started raining locally, rather than in another dimension.
+         */
         if (flag != this.isRaining()) {
             if (flag) {
-                this.server.getPlayerList().broadcastAll(new ClientboundGameEventPacket(ClientboundGameEventPacket.STOP_RAINING, 0.0F));
+                this.server.getPlayerList().broadcastAll(new ClientboundGameEventPacket(ClientboundGameEventPacket.STOP_RAINING, 0.0F), this.dimension());
             } else {
-                this.server.getPlayerList().broadcastAll(new ClientboundGameEventPacket(ClientboundGameEventPacket.START_RAINING, 0.0F));
+                this.server.getPlayerList().broadcastAll(new ClientboundGameEventPacket(ClientboundGameEventPacket.START_RAINING, 0.0F), this.dimension());
             }
 
-            this.server.getPlayerList().broadcastAll(new ClientboundGameEventPacket(ClientboundGameEventPacket.RAIN_LEVEL_CHANGE, this.rainLevel));
-            this.server.getPlayerList().broadcastAll(new ClientboundGameEventPacket(ClientboundGameEventPacket.THUNDER_LEVEL_CHANGE, this.thunderLevel));
+            this.server.getPlayerList().broadcastAll(new ClientboundGameEventPacket(ClientboundGameEventPacket.RAIN_LEVEL_CHANGE, this.rainLevel), this.dimension());
+            this.server.getPlayerList().broadcastAll(new ClientboundGameEventPacket(ClientboundGameEventPacket.THUNDER_LEVEL_CHANGE, this.thunderLevel), this.dimension());
         }
     }
 
@@ -753,12 +_,22 @@
     }
 
     public void tickNonPassenger(Entity p_8648_) {
+        final boolean isActive = org.spigotmc.ActivationRange.checkIfActive(p_8648_);
         p_8648_.setOldPosAndRot();
         ProfilerFiller profilerfiller = this.getProfiler();
         p_8648_.tickCount++;
         this.getProfiler().push(() -> BuiltInRegistries.ENTITY_TYPE.getKey(p_8648_.getType()).toString());
         profilerfiller.incrementCounter("tickNonPassenger");
-        p_8648_.tick();
+        // Neo: Permit cancellation of Entity#tick via EntityTickEvent.Pre
+        if (!net.neoforged.neoforge.event.EventHooks.fireEntityTickPre(p_8648_).isCanceled()) {
+            if (isActive) { // Paper - EAR 2
+                p_8648_.tick();
+                p_8648_.postTick(); // CraftBukkit
+            } else {
+                p_8648_.inactiveTick();
+            } // Paper - EAR 2
+            net.neoforged.neoforge.event.EventHooks.fireEntityTickPost(p_8648_);
+        }
         this.getProfiler().pop();
 
         for (Entity entity : p_8648_.getPassengers()) {
@@ -770,14 +_,24 @@
         if (p_8664_.isRemoved() || p_8664_.getVehicle() != p_8663_) {
             p_8664_.stopRiding();
         } else if (p_8664_ instanceof Player || this.entityTickList.contains(p_8664_)) {
+            final boolean isActive = org.spigotmc.ActivationRange.checkIfActive(p_8664_);
+
             p_8664_.setOldPosAndRot();
             p_8664_.tickCount++;
             ProfilerFiller profilerfiller = this.getProfiler();
             profilerfiller.push(() -> BuiltInRegistries.ENTITY_TYPE.getKey(p_8664_.getType()).toString());
             profilerfiller.incrementCounter("tickPassenger");
-            p_8664_.rideTick();
+            // Paper start - EAR 2
+            if (isActive) {
+                p_8664_.rideTick();
+                p_8664_.postTick(); // CraftBukkit
+            } else {
+                p_8664_.setDeltaMovement(Vec3.ZERO);
+                p_8664_.inactiveTick();
+                // copied from inside of if (isPassenger()) of passengerTick, but that ifPassenger is unnecessary
+                p_8663_.positionRider(p_8664_);
+            }
             profilerfiller.pop();
-
             for (Entity entity : p_8664_.getPassengers()) {
                 this.tickPassenger(p_8664_, entity);
             }
@@ -786,12 +_,20 @@
 
     @Override
     public boolean mayInteract(Player p_8696_, BlockPos p_8697_) {
+        if (PlayerMayInteractBlockEvent.getHandlerList().getRegisteredListeners().length > 0) {
+            Location location = CraftLocation.toBukkit(p_8697_, world);
+            PlayerMayInteractBlockEvent event = new PlayerMayInteractBlockEvent((org.bukkit.entity.Player) p_8696_.getBukkitEntity(), location);
+            if (!event.callEvent()) {
+                return false;
+            }
+        }
         return !this.server.isUnderSpawnProtection(this, p_8697_, p_8696_) && this.getWorldBorder().isWithinBounds(p_8697_);
     }
 
     public void save(@Nullable ProgressListener p_8644_, boolean p_8645_, boolean p_8646_) {
         ServerChunkCache serverchunkcache = this.getChunkSource();
         if (!p_8646_) {
+            Bukkit.getPluginManager().callEvent(new WorldSaveEvent(getWorld())); // CraftBukkit
             if (p_8644_ != null) {
                 p_8644_.progressStartNoAbort(Component.translatable("menu.savingLevel"));
             }
@@ -807,12 +_,30 @@
             } else {
                 this.entityManager.autoSave();
             }
+
+            // CraftBukkit start
+            ServerLevel worldserver1 = this;
+            if (worldserver1 != this.server.overworld()) {
+                this.K.setWorldBorder(worldserver1.getWorldBorder().createSettings());
+                this.K.setCustomBossEvents(this.server.getCustomBossEvents().save(this.registryAccess()));
+                this.convertable.saveDataTag(this.server.registryAccess(), this.K, this.server.getPlayerList().getSingleplayerData());
+            }
+            // CraftBukkit end
+
+            net.neoforged.neoforge.common.NeoForge.EVENT_BUS.post(new net.neoforged.neoforge.event.level.LevelEvent.Save(this));
+            if (p_8645_) {
+                net.neoforged.neoforge.common.IOUtilities.waitUntilIOWorkerComplete();
+            }
         }
     }
 
     private void saveLevelData() {
         if (this.dragonFight != null) {
-            this.server.getWorldData().setEndDragonFightData(this.dragonFight.saveData());
+            if (K != null) {
+                this.K.setEndDragonFightData(this.dragonFight.saveData()); // CraftBukkit
+            } else {
+                this.server.getWorldData().setEndDragonFightData(this.dragonFight.saveData());
+            }
         }
 
         this.getChunkSource().getDataStorage().save();
@@ -870,22 +_,45 @@
         return list.isEmpty() ? null : list.get(this.random.nextInt(list.size()));
     }
 
+    // Mohist start
+    public AtomicBoolean canaddFreshEntity = new AtomicBoolean(false);
+
+    public boolean canAddFreshEntity() {
+        return canaddFreshEntity.getAndSet(false);
+    }
+    // Mohist end
+
     @Override
     public boolean addFreshEntity(Entity p_8837_) {
-        return this.addEntity(p_8837_);
+        boolean add = this.addEntity(p_8837_);
+        canaddFreshEntity.set(add);
+        return add;
+    }
+
+    public boolean addFreshEntity(Entity entity, CreatureSpawnEvent.SpawnReason reason) {
+        return this.addEntityByReason(entity, reason);
     }
 
     public boolean addWithUUID(Entity p_8848_) {
         return this.addEntity(p_8848_);
     }
 
+    public boolean addWithUUID(Entity entity, CreatureSpawnEvent.SpawnReason reason) {
+        return this.addEntityByReason(entity, reason);
+    }
+
     public void addDuringTeleport(Entity p_143335_) {
-        if (p_143335_ instanceof ServerPlayer serverplayer) {
-            this.addPlayer(serverplayer);
-        } else {
-            this.addEntity(p_143335_);
-        }
-    }
+        // SPIGOT-6415: Don't call spawn event for entities which travel trough worlds,
+        // since it is only an implementation detail, that a new entity is created when
+        // they are traveling between worlds.
+        p_143335_.spawnReason(null); // Mohist
+        this.addEntity(p_143335_);
+    }
+
+    public void addDuringTeleport(Entity entity, CreatureSpawnEvent.SpawnReason reason) {
+        this.addEntityByReason(entity, reason);
+    }
+    // CraftBukkit end
 
     public void addNewPlayer(ServerPlayer p_8835_) {
         this.addPlayer(p_8835_);
@@ -896,6 +_,7 @@
     }
 
     private void addPlayer(ServerPlayer p_8854_) {
+        if (net.neoforged.neoforge.common.NeoForge.EVENT_BUS.post(new net.neoforged.neoforge.event.entity.EntityJoinLevelEvent(p_8854_, this)).isCanceled()) return;
         Entity entity = this.getEntities().get(p_8854_.getUUID());
         if (entity != null) {
             LOGGER.warn("Force-added player with duplicate UUID {}", p_8854_.getUUID());
@@ -903,15 +_,58 @@
             this.removePlayerImmediately((ServerPlayer)entity, Entity.RemovalReason.DISCARDED);
         }
 
-        this.entityManager.addNewEntity(p_8854_);
+        this.entityManager.addNewEntityWithoutEvent(p_8854_);
+        p_8854_.onAddedToLevel();
     }
 
     private boolean addEntity(Entity p_8873_) {
+        p_8873_.generation = false; // Paper - Don't fire sync event during generation; Reset flag if it was added during a ServerLevel generation process
+        // Paper start - extra debug info
+        if (p_8873_.valid) {
+            return true;
+        }
+        // Paper end - extra debug info
         if (p_8873_.isRemoved()) {
-            LOGGER.warn("Tried to add entity {} but it was marked as removed already", EntityType.getKey(p_8873_.getType()));
-            return false;
-        } else {
-            return this.entityManager.addNewEntity(p_8873_);
+            if (Boolean.parseBoolean("false")) LOGGER.warn("Tried to add entity {} but it was marked as removed already", EntityType.getKey(p_8873_.getType()));
+            return false;
+        } else {
+            if (p_8873_ instanceof Villager && YouerConfig.custom_no_villager) return false;
+            if (BanEntity.check(p_8873_)) {
+                p_8873_.discard();
+                return false;
+            }
+            if (p_8873_ instanceof net.minecraft.world.entity.item.ItemEntity itemEntity && itemEntity.getItem().isEmpty()) return false; // Paper - Prevent empty items from being added
+            // Paper start - capture all item additions to the world
+            if (captureDrops != null && p_8873_ instanceof net.minecraft.world.entity.item.ItemEntity) {
+                captureDrops.add((net.minecraft.world.entity.item.ItemEntity) p_8873_);
+                return true;
+            }
+            // Paper end - capture all item additions to the world
+            if (!AsyncCatcher.catchAsync() && p_8873_.spawnReason != null && !CraftEventFactory.doEntityAddEventCalling(this, p_8873_, p_8873_.spawnReason)) {
+                return false;
+            }
+            if (this.entityManager.addNewEntity(p_8873_)) {
+                p_8873_.onAddedToLevel();
+                return true;
+            } else {
+                return false;
+            }
+        }
+    }
+
+    // Mohist start
+    public boolean addEntityByReason(Entity entity, CreatureSpawnEvent.SpawnReason spawnReason) {
+        entity.spawnReason(spawnReason);
+        return addEntity(entity);
+    }
+    // Mohist end
+
+    public boolean tryAddFreshEntityWithPassengers(Entity pEntity, CreatureSpawnEvent.SpawnReason reason) {
+        if (pEntity.getSelfAndPassengers().map(Entity::getUUID).anyMatch(this.entityManager::isLoaded)) {
+            return false;
+        } else {
+            this.addFreshEntityWithPassengers(pEntity, reason);
+            return true;
         }
     }
 
@@ -925,6 +_,21 @@
     }
 
     public void unload(LevelChunk p_8713_) {
+        // Spigot Start
+        for (BlockEntity tileentity : p_8713_.getBlockEntities().values()) {
+            if (tileentity instanceof Container container) {
+                // Paper start - this area looks like it can load chunks, change the behavior
+                // chests for example can apply physics to the world
+                // so instead we just change the active container and call the event
+                for (org.bukkit.entity.HumanEntity h : Lists.newArrayList(container.getViewers())) {
+                    if (h != null) {
+                        ((org.bukkit.craftbukkit.entity.CraftHumanEntity) h).getHandle().closeUnloadedInventory(org.bukkit.event.inventory.InventoryCloseEvent.Reason.UNLOADED); // Paper - Inventory close reason
+                    }
+                }
+                // Paper end - this area looks like it can load chunks, change the behavior
+            }
+        }
+        // Spigot End
         p_8713_.clearAllBlockEntities();
         p_8713_.unregisterTickContainerFromLevel(this);
     }
@@ -933,13 +_,53 @@
         p_143262_.remove(p_143263_);
     }
 
+    // CraftBukkit start
+    public boolean strikeLightning(Entity entitylightning) {
+        return this.strikeLightning(entitylightning, LightningStrikeEvent.Cause.UNKNOWN);
+    }
+
+    public boolean strikeLightning(Entity entitylightning, LightningStrikeEvent.Cause cause) {
+        LightningStrikeEvent lightning = CraftEventFactory.callLightningStrikeEvent((org.bukkit.entity.LightningStrike) entitylightning.getBukkitEntity(), cause);
+
+        if (lightning.isCancelled()) {
+            return false;
+        }
+        return this.addFreshEntity(entitylightning);
+    }
+    // CraftBukkit end
+
     @Override
     public void destroyBlockProgress(int p_8612_, BlockPos p_8613_, int p_8614_) {
+
+        // CraftBukkit start
+        Player entityhuman = null;
+        Entity entity = this.getEntity(p_8612_);
+        if (entity instanceof Player) entityhuman = (Player) entity;
+        // CraftBukkit end
+
+        // Paper start - Add BlockBreakProgressUpdateEvent
+        // If a plugin is using this method to send destroy packets for a client-side only entity id, no block progress occurred on the server.
+        // Hence, do not call the event.
+        if (entity != null) {
+            float progressFloat = Mth.clamp(p_8614_, 0, 10) / 10.0f;
+            org.bukkit.craftbukkit.block.CraftBlock bukkitBlock = org.bukkit.craftbukkit.block.CraftBlock.at(this, p_8613_);
+            new io.papermc.paper.event.block.BlockBreakProgressUpdateEvent(bukkitBlock, progressFloat, entity.getBukkitEntity())
+                    .callEvent();
+        }
+        // Paper end - Add BlockBreakProgressUpdateEvent
+
         for (ServerPlayer serverplayer : this.server.getPlayerList().getPlayers()) {
             if (serverplayer != null && serverplayer.level() == this && serverplayer.getId() != p_8612_) {
                 double d0 = (double)p_8613_.getX() - serverplayer.getX();
                 double d1 = (double)p_8613_.getY() - serverplayer.getY();
                 double d2 = (double)p_8613_.getZ() - serverplayer.getZ();
+
+                // CraftBukkit start
+                if (entityhuman != null && !serverplayer.getBukkitEntity().canSee(entityhuman.getBukkitEntity())) {
+                    continue;
+                }
+                // CraftBukkit end
+
                 if (d0 * d0 + d1 * d1 + d2 * d2 < 1024.0) {
                     serverplayer.connection.send(new ClientboundBlockDestructionPacket(p_8612_, p_8613_, p_8614_));
                 }
@@ -959,6 +_,14 @@
         float p_263390_,
         long p_263403_
     ) {
+        if (!AsyncCatcher.catchAsync()) {
+            net.neoforged.neoforge.event.PlayLevelSoundEvent.AtPosition event = net.neoforged.neoforge.event.EventHooks.onPlaySoundAtPosition(this, p_263393_, p_263369_, p_263354_, p_263412_, p_263338_, p_263352_, p_263390_);
+            if (event.isCanceled() || event.getSound() == null) return;
+            p_263412_ = event.getSound();
+            p_263338_ = event.getSource();
+            p_263352_ = event.getNewVolume();
+            p_263390_ = event.getNewPitch();
+        }
         this.server
             .getPlayerList()
             .broadcast(
@@ -976,6 +_,12 @@
     public void playSeededSound(
         @Nullable Player p_263545_, Entity p_263544_, Holder<SoundEvent> p_263491_, SoundSource p_263542_, float p_263530_, float p_263520_, long p_263490_
     ) {
+        net.neoforged.neoforge.event.PlayLevelSoundEvent.AtEntity event = net.neoforged.neoforge.event.EventHooks.onPlaySoundAtEntity(p_263544_, p_263491_, p_263542_, p_263530_, p_263520_);
+        if (event.isCanceled() || event.getSound() == null) return;
+        p_263491_ = event.getSound();
+        p_263542_ = event.getSource();
+        p_263530_ = event.getNewVolume();
+        p_263520_ = event.getNewPitch();
         this.server
             .getPlayerList()
             .broadcast(
@@ -1019,6 +_,7 @@
 
     @Override
     public void gameEvent(Holder<GameEvent> p_316597_, Vec3 p_215042_, GameEvent.Context p_215043_) {
+        if (!net.neoforged.neoforge.common.CommonHooks.onVanillaGameEvent(this, p_316597_, p_215042_, p_215043_)) return;
         this.gameEventDispatcher.post(p_316597_, p_215042_, p_215043_);
     }
 
@@ -1031,6 +_,7 @@
 
         this.getChunkSource().blockChanged(p_8755_);
         this.pathTypesByPosCache.invalidate(p_8755_);
+        if (this.paperConfig().misc.updatePathfindingOnBlockUpdate) { // Paper - option to disable pathfinding updates
         VoxelShape voxelshape1 = p_8756_.getCollisionShape(this, p_8755_);
         VoxelShape voxelshape = p_8757_.getCollisionShape(this, p_8755_);
         if (Shapes.joinIsNotEmpty(voxelshape1, voxelshape, BooleanOp.NOT_SAME)) {
@@ -1053,15 +_,22 @@
                 this.isUpdatingNavigations = false;
             }
         }
+        } // Paper - option to disable pathfinding updates
     }
 
     @Override
     public void updateNeighborsAt(BlockPos p_215045_, Block p_215046_) {
+        if (captureBlockStates) { return; } // Paper - Cancel all physics during placement
+        net.neoforged.neoforge.event.EventHooks.onNeighborNotify(this, p_215045_, this.getBlockState(p_215045_), java.util.EnumSet.allOf(Direction.class), false).isCanceled();
         this.neighborUpdater.updateNeighborsAtExceptFromFacing(p_215045_, p_215046_, null);
     }
 
     @Override
     public void updateNeighborsAtExceptFromFacing(BlockPos p_215052_, Block p_215053_, Direction p_215054_) {
+        java.util.EnumSet<Direction> directions = java.util.EnumSet.allOf(Direction.class);
+        directions.remove(p_215054_);
+        if (net.neoforged.neoforge.event.EventHooks.onNeighborNotify(this, p_215052_, this.getBlockState(p_215052_), directions, false).isCanceled())
+            return;
         this.neighborUpdater.updateNeighborsAtExceptFromFacing(p_215052_, p_215053_, p_215054_);
     }
 
@@ -1107,6 +_,11 @@
         Explosion explosion = this.explode(
             p_256039_, p_255778_, p_256002_, p_256067_, p_256370_, p_256153_, p_256045_, p_255686_, p_255827_, false, p_312436_, p_312391_, p_320497_
         );
+        // CraftBukkit start
+        if (explosion.wasCanceled) {
+            return explosion;
+        }
+        // CraftBukkit end
         if (!explosion.interactsWithBlocks()) {
             explosion.clearToBlow();
         }
@@ -1196,14 +_,24 @@
     public <T extends ParticleOptions> int sendParticles(
         T p_8768_, double p_8769_, double p_8770_, double p_8771_, int p_8772_, double p_8773_, double p_8774_, double p_8775_, double p_8776_
     ) {
-        ClientboundLevelParticlesPacket clientboundlevelparticlespacket = new ClientboundLevelParticlesPacket(
-            p_8768_, false, p_8769_, p_8770_, p_8771_, (float)p_8773_, (float)p_8774_, (float)p_8775_, (float)p_8776_, p_8772_
-        );
+        // CraftBukkit - visibility api support
+        return sendParticles(null, p_8768_, p_8769_, p_8770_, p_8771_, p_8772_, p_8773_, p_8774_, p_8775_, p_8776_, false);
+    }
+
+    public <T extends ParticleOptions> int sendParticles(ServerPlayer sender, T p_8768_, double p_8769_, double p_8770_, double p_8771_, int p_8772_, double p_8773_, double p_8774_, double p_8775_, double p_8776_, boolean force) {
+        // Paper start - Particle API
+        return sendParticles(players, sender, p_8768_, p_8769_, p_8770_, p_8771_, p_8772_, p_8773_, p_8774_, p_8775_, p_8776_, force);
+    }
+    public <T extends ParticleOptions> int sendParticles(List<ServerPlayer> receivers, @Nullable ServerPlayer sender, T p_8768_, double p_8769_, double p_8770_, double p_8771_, int p_8772_, double p_8773_, double p_8774_, double p_8775_, double p_8776_, boolean force) {
+        // Paper end - Particle API
+        ClientboundLevelParticlesPacket clientboundlevelparticlespacket = new ClientboundLevelParticlesPacket( p_8768_, force, p_8769_, p_8770_, p_8771_, (float)p_8773_, (float)p_8774_, (float)p_8775_, (float)p_8776_, p_8772_);
+        // CraftBukkit end
         int i = 0;
 
-        for (int j = 0; j < this.players.size(); j++) {
-            ServerPlayer serverplayer = this.players.get(j);
-            if (this.sendParticles(serverplayer, false, p_8769_, p_8770_, p_8771_, clientboundlevelparticlespacket)) {
+        for (Player entityhuman : receivers) { // Paper - Particle API
+            ServerPlayer serverplayer = (ServerPlayer) entityhuman; // Paper - Particle API
+            if (sender != null && !serverplayer.getBukkitEntity().canSee(sender.getBukkitEntity())) continue; // CraftBukkit
+            if (this.sendParticles(serverplayer, force, p_8769_, p_8770_, p_8771_, clientboundlevelparticlespacket)) { // CraftBukkit
                 i++;
             }
         }
@@ -1264,7 +_,7 @@
 
     @Nullable
     public BlockPos findNearestMapStructure(TagKey<Structure> p_215012_, BlockPos p_215013_, int p_215014_, boolean p_215015_) {
-        if (!this.server.getWorldData().worldGenOptions().generateStructures()) {
+        if (!this.K.worldGenOptions().generateStructures()) {
             return null;
         } else {
             Optional<HolderSet.Named<Structure>> optional = this.registryAccess().registryOrThrow(Registries.STRUCTURE).getTag(p_215012_);
@@ -1309,11 +_,32 @@
     @Nullable
     @Override
     public MapItemSavedData getMapData(MapId p_323746_) {
-        return this.getServer().overworld().getDataStorage().get(MapItemSavedData.factory(), p_323746_.key());
+        // Paper start - Call missing map initialize event and set id
+        final DimensionDataStorage storage = this.getServer().overworld().getDataStorage();
+
+        final net.minecraft.world.level.saveddata.SavedData existing = storage.cache.get(p_323746_.key());
+        if (existing == null && !storage.cache.containsKey(p_323746_.key())) {
+            final MapItemSavedData worldmap = (MapItemSavedData) this.getServer().overworld().getDataStorage().get(MapItemSavedData.factory(), p_323746_.key());
+            storage.cache.put(p_323746_.key(), worldmap);
+            if (worldmap != null) {
+                worldmap.id = p_323746_;
+                new MapInitializeEvent(worldmap.mapView).callEvent();
+                return worldmap;
+            }
+        } else if (existing instanceof MapItemSavedData mapItemSavedData) {
+            mapItemSavedData.id = p_323746_;
+        }
+
+        return existing instanceof MapItemSavedData data ? data : null;
     }
 
     @Override
     public void setMapData(MapId p_323697_, MapItemSavedData p_143306_) {
+        // CraftBukkit start
+        p_143306_.id = p_323697_;
+        org.bukkit.event.server.MapInitializeEvent event = new org.bukkit.event.server.MapInitializeEvent(p_143306_.mapView);
+        org.bukkit.Bukkit.getServer().getPluginManager().callEvent(event);
+        // CraftBukkit end
         this.getServer().overworld().getDataStorage().set(p_323697_.key(), p_143306_);
     }
 
@@ -1326,7 +_,9 @@
         BlockPos blockpos = this.levelData.getSpawnPos();
         float f = this.levelData.getSpawnAngle();
         if (!blockpos.equals(p_8734_) || f != p_8735_) {
+            org.bukkit.Location prevSpawnLoc = this.getWorld().getSpawnLocation(); // Paper - Call SpawnChangeEvent
             this.levelData.setSpawn(p_8734_, p_8735_);
+            new org.bukkit.event.world.SpawnChangeEvent(this.getWorld(), prevSpawnLoc).callEvent(); // Paper - Call SpawnChangeEvent
             this.getServer().getPlayerList().broadcastAll(new ClientboundSetDefaultSpawnPositionPacket(p_8734_, p_8735_));
         }
 
@@ -1525,6 +_,11 @@
     @Override
     public void blockUpdated(BlockPos p_8743_, Block p_8744_) {
         if (!this.isDebug()) {
+            // CraftBukkit start
+            if (populating) {
+                return;
+            }
+            // CraftBukkit end
             this.updateNeighborsAt(p_8743_, p_8744_);
         }
     }
@@ -1544,12 +_,12 @@
     }
 
     public boolean isFlat() {
-        return this.server.getWorldData().isFlatWorld();
+        return this.K == null ?  this.server.getWorldData().isFlatWorld() : this.K.isFlatWorld(); // CraftBukkit // Mohist
     }
 
     @Override
     public long getSeed() {
-        return this.server.getWorldData().worldGenOptions().seed();
+        return this.K == null ?  this.server.getWorldData().worldGenOptions().seed() : this.K.worldGenOptions().seed(); // CraftBukkit // Mohist
     }
 
     @Nullable
@@ -1688,22 +_,29 @@
         }
 
         public void onTickingStart(Entity p_143363_) {
+            if (p_143363_ instanceof net.minecraft.world.entity.Marker && !paperConfig().entities.markers.tick) return; // Paper - Configurable marker ticking
             ServerLevel.this.entityTickList.add(p_143363_);
         }
 
         public void onTickingEnd(Entity p_143367_) {
             ServerLevel.this.entityTickList.remove(p_143367_);
+            // Paper start - Reset pearls when they stop being ticked
+            if (paperConfig().fixes.disableUnloadedChunkEnderpearlExploit && p_143367_ instanceof net.minecraft.world.entity.projectile.ThrownEnderpearl pearl) {
+                pearl.cachedOwner = null;
+                pearl.ownerUUID = null;
+            }
+            // Paper end - Reset pearls when they stop being ticked
         }
 
         public void onTrackingStart(Entity p_143371_) {
-            ServerLevel.this.getChunkSource().addEntity(p_143371_);
+            // ServerLevel.this.getChunkSource().addEntity(p_143371_); // Paper - ignore and warn about illegal addEntity calls instead of crashing server; moved down below valid=true
             if (p_143371_ instanceof ServerPlayer serverplayer) {
                 ServerLevel.this.players.add(serverplayer);
                 ServerLevel.this.updateSleepingPlayerList();
             }
 
             if (p_143371_ instanceof Mob mob) {
-                if (ServerLevel.this.isUpdatingNavigations) {
+                if (false && ServerLevel.this.isUpdatingNavigations) {
                     String s = "onTrackingStart called during navigation iteration";
                     Util.logAndPauseIfInIde(
                         "onTrackingStart called during navigation iteration", new IllegalStateException("onTrackingStart called during navigation iteration")
@@ -1713,16 +_,64 @@
                 ServerLevel.this.navigatingMobs.add(mob);
             }
 
-            if (p_143371_ instanceof EnderDragon enderdragon) {
-                for (EnderDragonPart enderdragonpart : enderdragon.getSubEntities()) {
+            if (p_143371_.isMultipartEntity()) {
+                for(net.neoforged.neoforge.entity.PartEntity<?> enderdragonpart : p_143371_.getParts()) {
                     ServerLevel.this.dragonParts.put(enderdragonpart.getId(), enderdragonpart);
                 }
             }
 
             p_143371_.updateDynamicGameEventListener(DynamicGameEventListener::add);
+            p_143371_.inWorld = true; // CraftBukkit - Mark entity as in world
+            p_143371_.valid = true; // CraftBukkit
+            ServerLevel.this.getChunkSource().addEntity(p_143371_); // Paper - ignore and warn about illegal addEntity calls instead of crashing server
+            // Paper start - Entity origin API
+            if (p_143371_.getOriginVector() == null) {
+                p_143371_.setOrigin(p_143371_.getBukkitEntity().getLocation());
+            }
+            // Default to current world if unknown, gross assumption but entities rarely change world
+            if (p_143371_.getOriginWorld() == null) {
+                p_143371_.setOrigin(p_143371_.getOriginVector().toLocation(getWorld()));
+            }
+            // Paper end - Entity origin API
+            new EntityAddToWorldEvent(p_143371_.getBukkitEntity(), ServerLevel.this.getWorld()).callEvent(); // Paper - fire while valid
         }
 
         public void onTrackingEnd(Entity p_143375_) {
+            // Spigot start
+            if ( p_143375_ instanceof Player )
+            {
+                com.google.common.collect.Streams.stream( getServer().getAllLevels() ).map( ServerLevel::getDataStorage ).forEach( (worldData) ->
+                {
+                    for (Object o : worldData.cache.values() )
+                    {
+                        if ( o instanceof MapItemSavedData )
+                        {
+                            MapItemSavedData map = (MapItemSavedData) o;
+                            map.carriedByPlayers.remove( (Player) p_143375_ );
+                            for ( java.util.Iterator<net.minecraft.world.level.saveddata.maps.MapItemSavedData.HoldingPlayer> iter = (java.util.Iterator<net.minecraft.world.level.saveddata.maps.MapItemSavedData.HoldingPlayer>) map.carriedBy.iterator(); iter.hasNext(); )
+                            {
+                                if ( iter.next().player == p_143375_ )
+                                {
+                                    iter.remove();
+                                }
+                            }
+                        }
+                    }
+                } );
+            }
+            // Spigot end
+            // Spigot Start
+            if (p_143375_.getBukkitEntity() instanceof org.bukkit.inventory.InventoryHolder && (!(p_143375_ instanceof ServerPlayer) || p_143375_.getRemovalReason() != Entity.RemovalReason.KILLED)) { // SPIGOT-6876: closeInventory clears death message
+                // Paper start - Fix merchant inventory not closing on entity removal
+                if (p_143375_.getBukkitEntity() instanceof org.bukkit.inventory.Merchant merchant && merchant.getTrader() != null) {
+                    merchant.getTrader().closeInventory(org.bukkit.event.inventory.InventoryCloseEvent.Reason.UNLOADED);
+                }
+                // Paper end - Fix merchant inventory not closing on entity removal
+                for (org.bukkit.entity.HumanEntity h : Lists.newArrayList(((org.bukkit.inventory.InventoryHolder) p_143375_.getBukkitEntity()).getInventory().getViewers())) {
+                    h.closeInventory(org.bukkit.event.inventory.InventoryCloseEvent.Reason.UNLOADED); // Paper - Inventory close reason
+                }
+            }
+            // Spigot End
             ServerLevel.this.getChunkSource().removeEntity(p_143375_);
             if (p_143375_ instanceof ServerPlayer serverplayer) {
                 ServerLevel.this.players.remove(serverplayer);
@@ -1730,27 +_,123 @@
             }
 
             if (p_143375_ instanceof Mob mob) {
-                if (ServerLevel.this.isUpdatingNavigations) {
+                if (false && ServerLevel.this.isUpdatingNavigations) {
                     String s = "onTrackingStart called during navigation iteration";
                     Util.logAndPauseIfInIde(
-                        "onTrackingStart called during navigation iteration", new IllegalStateException("onTrackingStart called during navigation iteration")
+                              "onTrackingStart called during navigation iteration", new IllegalStateException("onTrackingStart called during navigation iteration")
                     );
                 }
 
                 ServerLevel.this.navigatingMobs.remove(mob);
             }
 
-            if (p_143375_ instanceof EnderDragon enderdragon) {
-                for (EnderDragonPart enderdragonpart : enderdragon.getSubEntities()) {
+            if (p_143375_.isMultipartEntity()) {
+                for(net.neoforged.neoforge.entity.PartEntity<?> enderdragonpart : p_143375_.getParts()) {
                     ServerLevel.this.dragonParts.remove(enderdragonpart.getId());
                 }
             }
 
             p_143375_.updateDynamicGameEventListener(DynamicGameEventListener::remove);
+            // CraftBukkit start
+            p_143375_.valid = false;
+            if (!(p_143375_ instanceof ServerPlayer)) {
+                for (ServerPlayer player : players) {
+                    player.getBukkitEntity().onEntityRemove(p_143375_);
+                }
+            }
+            // CraftBukkit end
+
+            p_143375_.onRemovedFromLevel();
+            net.neoforged.neoforge.common.NeoForge.EVENT_BUS.post(new net.neoforged.neoforge.event.entity.EntityLeaveLevelEvent(p_143375_, ServerLevel.this));
+            new EntityRemoveFromWorldEvent(p_143375_.getBukkitEntity(), ServerLevel.this.getWorld()).callEvent(); // Paper - fire while valid
         }
 
         public void onSectionChange(Entity p_215086_) {
             p_215086_.updateDynamicGameEventListener(DynamicGameEventListener::move);
         }
     }
+
+    @Override
+    public java.util.Collection<net.neoforged.neoforge.entity.PartEntity<?>> getPartEntities() {
+        return this.dragonParts.values();
+    }
+
+    @Override
+    public final void syncData(net.neoforged.neoforge.attachment.AttachmentType<?> type) {
+        net.neoforged.neoforge.attachment.AttachmentSync.syncLevelUpdate(this, type);
+    }
+
+    private final net.neoforged.neoforge.capabilities.CapabilityListenerHolder capListenerHolder = new net.neoforged.neoforge.capabilities.CapabilityListenerHolder();
+
+    @Override
+    public void invalidateCapabilities(BlockPos pos) {
+        capListenerHolder.invalidatePos(pos);
+    }
+
+    @Override
+    public void invalidateCapabilities(ChunkPos pos) {
+        capListenerHolder.invalidateChunk(pos);
+    }
+
+    /**
+     * Register a listener for capability invalidation.
+     * @see net.neoforged.neoforge.capabilities.ICapabilityInvalidationListener
+     */
+    public void registerCapabilityListener(BlockPos pos, net.neoforged.neoforge.capabilities.ICapabilityInvalidationListener listener) {
+        capListenerHolder.addListener(pos, listener);
+    }
+
+    /**
+     * Internal method, used to clean capability listeners that are not referenced.
+     * Do not call.
+     */
+    @org.jetbrains.annotations.ApiStatus.Internal
+    public void cleanCapabilityListenerReferences() {
+        capListenerHolder.clean();
+    }
+
+    // Neo: Variable day time code
+
+    @org.jetbrains.annotations.ApiStatus.Internal
+    public void setDayTimeFraction(float dayTimeFraction) {
+        serverLevelData.setDayTimeFraction(dayTimeFraction);
+    }
+
+    @org.jetbrains.annotations.ApiStatus.Internal
+    public float getDayTimeFraction() {
+        return serverLevelData.getDayTimeFraction();
+    }
+
+    /**
+     * Returns the current ratio between game ticks and clock ticks. If this value is negative, no
+     * speed has been set and those two are coupled 1:1 (i.e. vanilla mode).
+     */
+    public float getDayTimePerTick() {
+        return serverLevelData.getDayTimePerTick();
+    }
+
+    /**
+     * This allows mods to set the rate time flows in a level. By default, each game tick the clock time
+     * also advances by one tick, with {@link Level#TICKS_PER_DAY} clock ticks (or 20 real-life minutes)
+     * forming a Minecraft day.
+     * <p>
+     * This can be sped up for shorter days by giving a higher number, or slowed down for longer days
+     * with a smaller number. A negative value will reset it back to vanilla logic.
+     * <p>
+     * This value can also be changed with the command <code>/neoforge day</code>, where you can set
+     * either the speed or a day length in minutes.
+     * <p>
+     * This has no effect when time progression is stopped.
+     * <p>
+     * While this still technically works when vanilla clients are connected, those will desync and
+     * experience a time jump once per second.
+     */
+    @Override
+    public void setDayTimePerTick(float dayTimePerTick) {
+        if (dayTimePerTick != getDayTimePerTick() && dayTimePerTick != 0f) {
+            serverLevelData.setDayTimePerTick(dayTimePerTick);
+            server.forceTimeSynchronization();
+        }
+    }
+
 }
