--- a/net/minecraft/world/item/crafting/RecipeManager.java
+++ b/net/minecraft/world/item/crafting/RecipeManager.java
@@ -3,6 +_,8 @@
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableMultimap;
+import com.google.common.collect.LinkedHashMultimap;
+import com.google.common.collect.Maps;
 import com.google.common.collect.Multimap;
 import com.google.common.collect.ImmutableMultimap.Builder;
 import com.google.gson.Gson;
@@ -10,10 +_,13 @@
 import com.google.gson.JsonElement;
 import com.google.gson.JsonObject;
 import com.google.gson.JsonParseException;
+import com.mohistmc.youer.plugins.ban.bans.BanRecipe;
+import com.mohistmc.youer.util.I18n;
 import com.mojang.logging.LogUtils;
 import com.mojang.serialization.JsonOps;
 import java.util.Collection;
 import java.util.Comparator;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Optional;
@@ -38,7 +_,7 @@
     private static final Logger LOGGER = LogUtils.getLogger();
     private final HolderLookup.Provider registries;
     public Multimap<RecipeType<?>, RecipeHolder<?>> byType = ImmutableMultimap.of();
-    private Map<ResourceLocation, RecipeHolder<?>> byName = ImmutableMap.of();
+    public Map<ResourceLocation, RecipeHolder<?>> byName = ImmutableMap.of();
     private boolean hasErrors;
 
     public RecipeManager(HolderLookup.Provider p_324137_) {
@@ -50,24 +_,30 @@
         this.hasErrors = false;
         Builder<RecipeType<?>, RecipeHolder<?>> builder = ImmutableMultimap.builder();
         com.google.common.collect.ImmutableMap.Builder<ResourceLocation, RecipeHolder<?>> builder1 = ImmutableMap.builder();
-        RegistryOps<JsonElement> registryops = this.registries.createSerializationContext(JsonOps.INSTANCE);
+        RegistryOps<JsonElement> registryops = this.makeConditionalOps(); // Neo: add condition context
 
         for (Entry<ResourceLocation, JsonElement> entry : p_44037_.entrySet()) {
             ResourceLocation resourcelocation = entry.getKey();
-
+            if (resourcelocation.getPath().startsWith("_")) continue; //Forge: filter anything beginning with "_" as it's used for metadata.
+            if (BanRecipe.checkBan(resourcelocation)) continue;
             try {
-                Recipe<?> recipe = Recipe.CODEC.parse(registryops, entry.getValue()).getOrThrow(JsonParseException::new);
+                var decoded = Recipe.CONDITIONAL_CODEC.parse(registryops, entry.getValue()).getOrThrow(JsonParseException::new);
+                decoded.ifPresentOrElse(r -> {
+                Recipe<?> recipe = r.carrier();
                 RecipeHolder<?> recipeholder = new RecipeHolder<>(resourcelocation, recipe);
                 builder.put(recipe.getType(), recipeholder);
                 builder1.put(resourcelocation, recipeholder);
+                }, () -> {
+                    LOGGER.debug("Skipping loading recipe {} as its conditions were not met", resourcelocation);
+                });
             } catch (IllegalArgumentException | JsonParseException jsonparseexception) {
-                LOGGER.error("Parsing error loading recipe {}", resourcelocation, jsonparseexception);
+                if (Boolean.parseBoolean("false")) LOGGER.error("Parsing error loading recipe {}", resourcelocation, jsonparseexception);
             }
         }
 
         this.byType = builder.build();
         this.byName = builder1.build();
-        LOGGER.info("Loaded {} recipes", this.byType.size());
+        LOGGER.info(I18n.as("recipemanager.loaded", this.byType.size()));
     }
 
     public boolean hadErrorsLoading() {
@@ -193,5 +_,47 @@
 
     public interface CachedCheck<I extends RecipeInput, T extends Recipe<I>> {
         Optional<RecipeHolder<T>> getRecipeFor(I p_344938_, Level p_220281_);
+    }
+
+    public synchronized void addRecipe(RecipeHolder<?> recipe) {
+        Multimap<RecipeType<?>, RecipeHolder<?>> mutableByType = LinkedHashMultimap.create(this.byType);
+        Map<ResourceLocation, RecipeHolder<?>> mutableByName = Maps.newHashMap(this.byName);
+
+        if (mutableByName.containsKey(recipe.id())) {
+            throw new IllegalStateException("Duplicate recipe ignored with ID " + recipe.id());
+        }
+
+        mutableByType.put(recipe.value().getType(), recipe);
+        mutableByName.put(recipe.id(), recipe);
+
+        this.byType = ImmutableMultimap.copyOf(mutableByType);
+        this.byName = ImmutableMap.copyOf(mutableByName);
+    }
+
+    public synchronized boolean removeRecipe(ResourceLocation mcKey) {
+        Multimap<RecipeType<?>, RecipeHolder<?>> mutableByType = LinkedHashMultimap.create(this.byType);
+        Map<ResourceLocation, RecipeHolder<?>> mutableByName = Maps.newHashMap(this.byName);
+
+        Iterator<RecipeHolder<?>> iter = mutableByType.values().iterator();
+        boolean removed = false;
+        while (iter.hasNext()) {
+            RecipeHolder<?> recipe = iter.next();
+            if (recipe.id().equals(mcKey)) {
+                iter.remove();
+                removed = true;
+            }
+        }
+        removed |= mutableByName.remove(mcKey) != null;
+
+        if (removed) {
+            this.byType = ImmutableMultimap.copyOf(mutableByType);
+            this.byName = ImmutableMap.copyOf(mutableByName);
+        }
+        return removed;
+    }
+
+    public void clearRecipes() {
+        this.byType = ImmutableMultimap.of();
+        this.byName = ImmutableMap.of();
     }
 }
