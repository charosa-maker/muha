--- a/net/minecraft/network/CompressionEncoder.java
+++ b/net/minecraft/network/CompressionEncoder.java
@@ -6,16 +_,31 @@
 import java.util.zip.Deflater;
 
 public class CompressionEncoder extends MessageToByteEncoder<ByteBuf> {
-    private final byte[] encodeBuf = new byte[8192];
+    @javax.annotation.Nullable private final byte[] encodeBuf; // Paper - Use Velocity cipher
+    @javax.annotation.Nullable // Paper - Use Velocity cipher
     private final Deflater deflater;
+    @javax.annotation.Nullable // Paper - Use Velocity cipher
+    private final com.velocitypowered.natives.compression.VelocityCompressor compressor; // Paper - Use Velocity cipher
     private int threshold;
 
-    public CompressionEncoder(int p_129448_) {
-        this.threshold = p_129448_;
-        this.deflater = new Deflater();
+    // Paper start - Use Velocity cipher
+    public CompressionEncoder(int compressionThreshold) {
+        this(null, compressionThreshold);
+    }
+    public CompressionEncoder(@javax.annotation.Nullable com.velocitypowered.natives.compression.VelocityCompressor compressor, int compressionThreshold) {
+        this.threshold = compressionThreshold;
+        if (compressor == null) {
+            this.encodeBuf = new byte[8192];
+            this.deflater = new Deflater();
+        } else {
+            this.encodeBuf = null;
+            this.deflater = null;
+        }
+        this.compressor = compressor;
+        // Paper end - Use Velocity cipher
     }
 
-    protected void encode(ChannelHandlerContext p_129452_, ByteBuf p_129453_, ByteBuf p_129454_) {
+    protected void encode(ChannelHandlerContext p_129452_, ByteBuf p_129453_, ByteBuf p_129454_) throws Exception { // Paper - Use Velocity cipher
         int i = p_129453_.readableBytes();
         if (i > 8388608) {
             throw new IllegalArgumentException("Packet too big (is " + i + ", should be less than 8388608)");
@@ -24,19 +_,57 @@
                 VarInt.write(p_129454_, 0);
                 p_129454_.writeBytes(p_129453_);
             } else {
-                byte[] abyte = new byte[i];
-                p_129453_.readBytes(abyte);
-                VarInt.write(p_129454_, abyte.length);
-                this.deflater.setInput(abyte, 0, i);
-                this.deflater.finish();
-
-                while (!this.deflater.finished()) {
-                    int j = this.deflater.deflate(this.encodeBuf);
-                    p_129454_.writeBytes(this.encodeBuf, 0, j);
-                }
-
-                this.deflater.reset();
+                if (this.deflater != null) { // Paper - Use Velocity cipher
+                    byte[] bs = new byte[i];
+                    p_129453_.readBytes(bs);
+                    VarInt.write(p_129454_, bs.length);
+                    this.deflater.setInput(bs, 0, i);
+                    this.deflater.finish();
+
+                    while (!this.deflater.finished()) {
+                        int j = this.deflater.deflate(this.encodeBuf);
+                        p_129454_.writeBytes(this.encodeBuf, 0, j);
+                    }
+
+                    this.deflater.reset();
+                    // Paper start - Use Velocity cipher
+                    return;
+                }
+
+                VarInt.write(p_129454_, i);
+                final ByteBuf compatibleIn = com.velocitypowered.natives.util.MoreByteBufUtils.ensureCompatible(p_129452_.alloc(), this.compressor, p_129453_);
+                try {
+                    this.compressor.deflate(compatibleIn, p_129454_);
+                } finally {
+                    compatibleIn.release();
+                }
             }
+        }
+    }
+
+    @Override
+    protected ByteBuf allocateBuffer(ChannelHandlerContext ctx, ByteBuf msg, boolean preferDirect) throws Exception{
+        if (this.compressor != null) {
+            // We allocate bytes to be compressed plus 1 byte. This covers two cases:
+            //
+            // - Compression
+            //    According to https://github.com/ebiggers/libdeflate/blob/master/libdeflate.h#L103,
+            //    if the data compresses well (and we do not have some pathological case) then the maximum
+            //    size the compressed size will ever be is the input size minus one.
+            // - Uncompressed
+            //    This is fairly obvious - we will then have one more than the uncompressed size.
+            final int initialBufferSize = msg.readableBytes() + 1;
+            return com.velocitypowered.natives.util.MoreByteBufUtils.preferredBuffer(ctx.alloc(), this.compressor, initialBufferSize);
+        }
+
+        return super.allocateBuffer(ctx, msg, preferDirect);
+    }
+
+    @Override
+    public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {
+        if (this.compressor != null) {
+            this.compressor.close();
+            // Paper end - Use Velocity cipher
         }
     }
 
