--- a/net/minecraft/commands/Commands.java
+++ b/net/minecraft/commands/Commands.java
@@ -1,6 +_,9 @@
 package net.minecraft.commands;
 
+import com.google.common.base.Joiner;
 import com.google.common.collect.Maps;
+import com.mohistmc.youer.commands.UnBanIpCommand;
+import com.mohistmc.youer.commands.UnbanCommand;
 import com.mojang.brigadier.CommandDispatcher;
 import com.mojang.brigadier.ParseResults;
 import com.mojang.brigadier.StringReader;
@@ -8,17 +_,20 @@
 import com.mojang.brigadier.builder.ArgumentBuilder;
 import com.mojang.brigadier.builder.LiteralArgumentBuilder;
 import com.mojang.brigadier.builder.RequiredArgumentBuilder;
-import com.mojang.brigadier.context.CommandContext;
 import com.mojang.brigadier.context.CommandContextBuilder;
 import com.mojang.brigadier.context.ContextChain;
 import com.mojang.brigadier.exceptions.CommandSyntaxException;
 import com.mojang.brigadier.tree.CommandNode;
+import com.mojang.brigadier.suggestion.SuggestionProvider;
 import com.mojang.brigadier.tree.RootCommandNode;
 import com.mojang.logging.LogUtils;
 import java.util.Collection;
+import java.util.LinkedHashSet;
 import java.util.Map;
 import java.util.Optional;
 import java.util.Set;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.Consumer;
 import java.util.function.Predicate;
 import java.util.function.UnaryOperator;
@@ -40,10 +_,8 @@
 import net.minecraft.network.chat.ClickEvent;
 import net.minecraft.network.chat.CommonComponents;
 import net.minecraft.network.chat.Component;
-import net.minecraft.network.chat.ComponentUtils;
 import net.minecraft.network.chat.HoverEvent;
 import net.minecraft.network.chat.MutableComponent;
-import net.minecraft.network.chat.Style;
 import net.minecraft.network.protocol.game.ClientboundCommandsPacket;
 import net.minecraft.resources.ResourceKey;
 import net.minecraft.server.MinecraftServer;
@@ -58,7 +_,6 @@
 import net.minecraft.server.commands.DamageCommand;
 import net.minecraft.server.commands.DataPackCommand;
 import net.minecraft.server.commands.DeOpCommands;
-import net.minecraft.server.commands.DebugCommand;
 import net.minecraft.server.commands.DebugConfigCommand;
 import net.minecraft.server.commands.DebugMobSpawningCommand;
 import net.minecraft.server.commands.DebugPathCommand;
@@ -136,6 +_,8 @@
 import net.minecraft.tags.TagKey;
 import net.minecraft.util.profiling.jfr.JvmProfiler;
 import net.minecraft.world.level.GameRules;
+import org.bukkit.event.player.PlayerCommandSendEvent;
+import org.bukkit.event.server.ServerCommandEvent;
 import org.slf4j.Logger;
 
 public class Commands {
@@ -158,7 +_,7 @@
         DamageCommand.register(this.dispatcher, p_230944_);
         DataCommands.register(this.dispatcher);
         DataPackCommand.register(this.dispatcher);
-        DebugCommand.register(this.dispatcher);
+        //DebugCommand.register(this.dispatcher); // Purpur
         DefaultGameModeCommands.register(this.dispatcher);
         DifficultyCommand.register(this.dispatcher);
         EffectCommands.register(this.dispatcher, p_230944_);
@@ -214,7 +_,7 @@
             JfrCommand.register(this.dispatcher);
         }
 
-        if (SharedConstants.IS_RUNNING_IN_IDE) {
+        if (net.neoforged.neoforge.gametest.GameTestHooks.isGametestEnabled()) {
             TestCommand.register(this.dispatcher);
             RaidCommand.register(this.dispatcher, p_230944_);
             DebugPathCommand.register(this.dispatcher);
@@ -235,6 +_,8 @@
             OpCommand.register(this.dispatcher);
             PardonCommand.register(this.dispatcher);
             PardonIpCommand.register(this.dispatcher);
+            UnbanCommand.register(this.dispatcher);
+            UnBanIpCommand.register(this.dispatcher);
             PerfCommand.register(this.dispatcher);
             SaveAllCommand.register(this.dispatcher);
             SaveOffCommand.register(this.dispatcher);
@@ -243,12 +_,45 @@
             StopCommand.register(this.dispatcher);
             TransferCommand.register(this.dispatcher);
             WhitelistCommand.register(this.dispatcher);
+            org.purpurmc.purpur.command.CreditsCommand.register(this.dispatcher); // Purpur
+            org.purpurmc.purpur.command.DemoCommand.register(this.dispatcher); // Purpur
+            org.purpurmc.purpur.command.PingCommand.register(this.dispatcher); // Purpur
+            org.purpurmc.purpur.command.UptimeCommand.register(this.dispatcher); // Purpur
+            org.purpurmc.purpur.command.TPSBarCommand.register(this.dispatcher); // Purpur
+            org.purpurmc.purpur.command.CompassCommand.register(this.dispatcher); // Purpur
+            org.purpurmc.purpur.command.RamBarCommand.register(this.dispatcher); // Purpur
+            org.purpurmc.purpur.command.RamCommand.register(this.dispatcher); // Purpur
         }
 
         if (p_230943_.includeIntegrated) {
             PublishCommand.register(this.dispatcher);
         }
+        net.neoforged.neoforge.event.EventHooks.onCommandRegister(this.dispatcher, p_230943_, p_230944_);
+        // Paper start - Vanilla command permission fixes
+        for (final CommandNode<CommandSourceStack> node : this.dispatcher.getRoot().getChildren()) {
+            if (node.getRequirement() == com.mojang.brigadier.builder.ArgumentBuilder.<CommandSourceStack>defaultRequirement()) {
+                node.requirement = stack -> stack.source == CommandSource.NULL || stack.getBukkitSender().hasPermission(org.bukkit.craftbukkit.command.VanillaCommandWrapper.getPermission(node));
+            }
+        }
+        // Paper end - Vanilla command permission fixes
+        // Paper start - Brigadier Command API
+        // Create legacy minecraft namespace commands
+        for (final CommandNode<CommandSourceStack> node : new java.util.ArrayList<>(this.dispatcher.getRoot().getChildren())) {
+            // The brigadier dispatcher is not able to resolve nested redirects.
+            // E.g. registering the alias minecraft:tp cannot redirect to tp, as tp itself redirects to teleport.
+            // Instead, target the first none redirecting node.
+            CommandNode<CommandSourceStack> flattenedAliasTarget = node;
+            while (flattenedAliasTarget.getRedirect() != null) flattenedAliasTarget = flattenedAliasTarget.getRedirect();
 
+            this.dispatcher.register(
+                    LiteralArgumentBuilder.<CommandSourceStack>literal("minecraft:" + node.getName())
+                            .executes(flattenedAliasTarget.getCommand())
+                            .requires(flattenedAliasTarget.getRequirement())
+                            .redirect(flattenedAliasTarget)
+            );
+        }
+        // Paper end - Brigadier Command API
+        // Paper - remove public constructor, no longer needed
         this.dispatcher.setConsumer(ExecutionCommandSource.resultConsumer());
     }
 
@@ -258,14 +_,77 @@
         return new ParseResults<>(commandcontextbuilder1, p_242928_.getReader(), p_242928_.getExceptions());
     }
 
-    public void performPrefixedCommand(CommandSourceStack p_230958_, String p_230959_) {
-        p_230959_ = p_230959_.startsWith("/") ? p_230959_.substring(1) : p_230959_;
-        this.performCommand(this.dispatcher.parse(p_230959_, p_230958_), p_230959_);
+    // CraftBukkit start
+    public void dispatchServerCommand(CommandSourceStack sender, String command) {
+        Joiner joiner = Joiner.on(" ");
+        if (command.startsWith("/")) {
+            command = command.substring(1);
+        }
+
+        ServerCommandEvent event = new ServerCommandEvent(sender.getBukkitSender(), command);
+        org.bukkit.Bukkit.getPluginManager().callEvent(event);
+        if (event.isCancelled()) {
+            return;
+        }
+        command = event.getCommand();
+
+        String[] args = command.split(" ");
+        if (args.length == 0) return; // Paper - empty commands shall not be dispatched
+
+        // Paper - Fix permission levels for command blocks
+
+        // Handle vanilla commands; // Paper - handled in CommandNode/CommandDispatcher
+
+        String newCommand = joiner.join(args);
+        this.performPrefixedCommand(sender, newCommand, newCommand);
+    }
+    // CraftBukkit end
+
+    public void performPrefixedCommand(CommandSourceStack source, String command) {
+        // CraftBukkit start
+        this.performPrefixedCommand(source, command, command);
+    }
+
+    public void performPrefixedCommand(CommandSourceStack commandlistenerwrapper, String s, String label) {
+        s = s.startsWith("/") ? s.substring(1) : s;
+        this.performCommandCB(this.dispatcher.parse(s, commandlistenerwrapper), s, label);
+        // CraftBukkit end
+    }
+
+    // Mohist start - add field to compat with mods
+    private final AtomicReference<String> mohist$label = new AtomicReference<>();
+    private static final AtomicReference<String> finishParsing$label = new AtomicReference<>();
+    private final AtomicBoolean performCommand$throwCommandError = new AtomicBoolean(false);
+
+    public void performCommandCB(ParseResults<CommandSourceStack> pParseResults, String pCommand, String label) { // CraftBukkit
+        mohist$label.set(label);
+        performCommand$throwCommandError.set(false);
+        this.performCommand(pParseResults, pCommand);
+    }
+
+    public void performCommandCB(ParseResults<CommandSourceStack> parseresults, String s, String label, boolean throwCommandError) {
+        mohist$label.set(label);
+        performCommand$throwCommandError.set(throwCommandError);
+        this.performCommand(parseresults, s);
     }
 
     public void performCommand(ParseResults<CommandSourceStack> p_242844_, String p_242841_) {
+        var label = mohist$label.get();
+        label = label == null ? p_242841_ : label;
+        // Mohist end
         CommandSourceStack commandsourcestack = p_242844_.getContext().getSource();
+        net.neoforged.neoforge.event.CommandEvent event = new net.neoforged.neoforge.event.CommandEvent(p_242844_);
+        if (net.neoforged.neoforge.common.NeoForge.EVENT_BUS.post(event).isCanceled()) {
+            if (event.getException() != null) {
+                commandsourcestack.sendFailure(Component.literal(Util.describeError(event.getException())));
+                LOGGER.error("'/{}' threw an exception", p_242841_, event.getException());
+            }
+            return;
+        }
+        p_242844_ = event.getParseResults();
+
         commandsourcestack.getServer().getProfiler().push(() -> "/" + p_242841_);
+        finishParsing$label.set(label);
         ContextChain<CommandSourceStack> contextchain = finishParsing(p_242844_, p_242841_, commandsourcestack);
 
         try {
@@ -278,9 +_,10 @@
                 );
             }
         } catch (Exception exception) {
+            if (performCommand$throwCommandError.getAndSet(false)) throw exception;
             MutableComponent mutablecomponent = Component.literal(exception.getMessage() == null ? exception.getClass().getName() : exception.getMessage());
+            Commands.LOGGER.error("Command exception: /{}", p_242841_, exception); // Paper - always show execution exception in console log
             if (LOGGER.isDebugEnabled()) {
-                LOGGER.error("Command exception: /{}", p_242841_, exception);
                 StackTraceElement[] astacktraceelement = exception.getStackTrace();
 
                 for (int i = 0; i < Math.min(astacktraceelement.length, 3); i++) {
@@ -313,12 +_,16 @@
             return ContextChain.tryFlatten(p_307220_.getContext().build(p_307311_))
                 .orElseThrow(() -> CommandSyntaxException.BUILT_IN_EXCEPTIONS.dispatcherUnknownCommand().createWithContext(p_307220_.getReader()));
         } catch (CommandSyntaxException commandsyntaxexception) {
-            p_307676_.sendFailure(ComponentUtils.fromMessage(commandsyntaxexception.getRawMessage()));
+            // Paper start - Add UnknownCommandEvent
+            final net.kyori.adventure.text.TextComponent.Builder builder = net.kyori.adventure.text.Component.text();
+            // commandlistenerwrapper.sendFailure(ComponentUtils.fromMessage(commandsyntaxexception.getRawMessage()));
+            builder.color(net.kyori.adventure.text.format.NamedTextColor.RED).append(io.papermc.paper.brigadier.PaperBrigadier.componentFromMessage(commandsyntaxexception.getRawMessage()));
+            // Paper end - Add UnknownCommandEvent
             if (commandsyntaxexception.getInput() != null && commandsyntaxexception.getCursor() >= 0) {
                 int i = Math.min(commandsyntaxexception.getInput().length(), commandsyntaxexception.getCursor());
                 MutableComponent mutablecomponent = Component.empty()
                     .withStyle(ChatFormatting.GRAY)
-                    .withStyle(p_82134_ -> p_82134_.withClickEvent(new ClickEvent(ClickEvent.Action.SUGGEST_COMMAND, "/" + p_307311_)));
+                    .withStyle(p_82134_ -> p_82134_.withClickEvent(new ClickEvent(ClickEvent.Action.SUGGEST_COMMAND, "/" + finishParsing$label.get()))); // CraftBukkit
                 if (i > 10) {
                     mutablecomponent.append(CommonComponents.ELLIPSIS);
                 }
@@ -331,7 +_,17 @@
                 }
 
                 mutablecomponent.append(Component.translatable("command.context.here").withStyle(ChatFormatting.RED, ChatFormatting.ITALIC));
-                p_307676_.sendFailure(mutablecomponent);
+                // Paper start - Add UnknownCommandEvent
+                // commandlistenerwrapper.sendFailure(mutablecomponent);
+                builder
+                        .append(net.kyori.adventure.text.Component.newline())
+                        .append(io.papermc.paper.adventure.PaperAdventure.asAdventure(mutablecomponent));
+            }
+            org.bukkit.event.command.UnknownCommandEvent event = new org.bukkit.event.command.UnknownCommandEvent(p_307676_.getBukkitSender(), p_307311_, org.spigotmc.SpigotConfig.unknownCommandMessage.isEmpty() ? null : builder.build());
+            org.bukkit.Bukkit.getServer().getPluginManager().callEvent(event);
+            if (event.message() != null) {
+                p_307676_.sendFailure(io.papermc.paper.adventure.PaperAdventure.asVanilla(event.message()), false);
+                // Paper end - Add UnknownCommandEvent
             }
 
             return null;
@@ -359,11 +_,67 @@
     }
 
     public void sendCommands(ServerPlayer p_82096_) {
-        Map<CommandNode<CommandSourceStack>, CommandNode<SharedSuggestionProvider>> map = Maps.newHashMap();
-        RootCommandNode<SharedSuggestionProvider> rootcommandnode = new RootCommandNode<>();
+        // Paper start - Send empty commands if tab completion is disabled
+        if (org.spigotmc.SpigotConfig.tabComplete < 0) {
+            p_82096_.connection.send(new ClientboundCommandsPacket(new RootCommandNode<>()));
+            return;
+        }
+        // Paper end - Send empty commands if tab completion is disabled
+        // CraftBukkit start
+        // Register Vanilla commands into builtRoot as before
+        // Paper start - Perf: Async command map building
+        COMMAND_SENDING_POOL.execute(() -> {
+            this.sendAsync(p_82096_);
+        });
+    }
+
+    public static final java.util.concurrent.ThreadPoolExecutor COMMAND_SENDING_POOL = new java.util.concurrent.ThreadPoolExecutor(
+            0, 2, 60L, java.util.concurrent.TimeUnit.SECONDS,
+            new java.util.concurrent.LinkedBlockingQueue<>(),
+            new com.google.common.util.concurrent.ThreadFactoryBuilder()
+                    .setNameFormat("Paper Async Command Builder Thread Pool - %1$d")
+                    .setUncaughtExceptionHandler(new net.minecraft.DefaultUncaughtExceptionHandlerWithName(net.minecraft.server.MinecraftServer.LOGGER))
+                    .build(),
+            new java.util.concurrent.ThreadPoolExecutor.DiscardPolicy()
+    );
+
+    private void sendAsync(ServerPlayer player) {
+        // Paper end - Perf: Async command map building
+        Map<CommandNode<CommandSourceStack>, CommandNode<SharedSuggestionProvider>> map = Maps.newIdentityHashMap(); // Use identity to prevent aliasing issues
+        // Paper - brigadier API removes the need to fill the map twice
+        RootCommandNode<SharedSuggestionProvider> rootcommandnode = new RootCommandNode();
+
         map.put(this.dispatcher.getRoot(), rootcommandnode);
-        this.fillUsableCommands(this.dispatcher.getRoot(), rootcommandnode, p_82096_.createCommandSourceStack(), map);
-        p_82096_.connection.send(new ClientboundCommandsPacket(rootcommandnode));
+        // this.fillUsableCommands(this.dispatcher.getRoot(), rootcommandnode, player.createCommandSourceStack(), map);
+        // FORGE: Use our own command node merging method to handle redirect nodes properly, see issue #7551
+        net.neoforged.neoforge.server.command.CommandHelper.mergeCommandNode(this.dispatcher.getRoot(), rootcommandnode, map, player.createCommandSourceStack(), ctx -> 0, suggest -> SuggestionProviders.safelySwap((SuggestionProvider<SharedSuggestionProvider>) (SuggestionProvider<?>) suggest));
+        Collection<String> bukkit = new LinkedHashSet<>();
+        for (CommandNode node : rootcommandnode.getChildren()) {
+            bukkit.add(node.getName());
+        }
+        // Paper start - Perf: Async command map building
+        new com.destroystokyo.paper.event.brigadier.AsyncPlayerSendCommandsEvent<CommandSourceStack>(player.getBukkitEntity(), (RootCommandNode) rootcommandnode, false).callEvent(); // Paper - Brigadier API
+        net.minecraft.server.MinecraftServer.getServer().execute(() -> {
+            runSync(player, bukkit, rootcommandnode);
+        });
+    }
+
+    private void runSync(ServerPlayer player, Collection<String> bukkit, RootCommandNode<SharedSuggestionProvider> rootcommandnode) {
+        // Paper end - Perf: Async command map building
+        new com.destroystokyo.paper.event.brigadier.AsyncPlayerSendCommandsEvent<CommandSourceStack>(player.getBukkitEntity(), (RootCommandNode) rootcommandnode, true).callEvent(); // Paper - Brigadier API
+        if (PlayerCommandSendEvent.getHandlerList().getRegisteredListeners().length > 0) { // Purpur - skip all this crap if there's nothing listening
+        PlayerCommandSendEvent event = new PlayerCommandSendEvent(player.getBukkitEntity(), new LinkedHashSet<>(bukkit));
+        event.getPlayer().getServer().getPluginManager().callEvent(event);
+
+        // Remove labels that were removed during the event
+        for (String orig : bukkit) {
+            if (!event.getCommands().contains(orig)) {
+                rootcommandnode.removeCommand(orig); // TODO Youer
+            }
+        }
+        // CraftBukkit end
+        } // Purpur - skip event
+        player.connection.send(new ClientboundCommandsPacket(rootcommandnode));
     }
 
     private void fillUsableCommands(
@@ -373,6 +_,12 @@
         Map<CommandNode<CommandSourceStack>, CommandNode<SharedSuggestionProvider>> p_82116_
     ) {
         for (CommandNode<CommandSourceStack> commandnode : p_82113_.getChildren()) {
+            // Paper start - Brigadier API
+            if (commandnode.clientNode != null) {
+                commandnode = commandnode.clientNode;
+            }
+            // Paper end - Brigadier API
+            if ( !org.spigotmc.SpigotConfig.sendNamespaced && commandnode.getName().contains( ":" ) ) continue; // Spigot
             if (commandnode.canUse(p_82115_)) {
                 ArgumentBuilder<SharedSuggestionProvider, ?> argumentbuilder = (ArgumentBuilder<SharedSuggestionProvider, ?>)(ArgumentBuilder<?, ?>)commandnode.createBuilder();
                 argumentbuilder.requires(p_82126_ -> true);
