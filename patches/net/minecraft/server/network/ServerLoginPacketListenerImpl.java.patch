--- a/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
+++ b/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
@@ -1,31 +_,44 @@
 package net.minecraft.server.network;
 
+import com.mohistmc.youer.api.ColorAPI;
+import com.mohistmc.youer.bukkit.LoginHandler;
+import com.destroystokyo.paper.proxy.VelocityProxy;
 import com.google.common.primitives.Ints;
+import com.mohistmc.youer.util.I18n;
 import com.mojang.authlib.GameProfile;
 import com.mojang.authlib.exceptions.AuthenticationUnavailableException;
 import com.mojang.authlib.yggdrasil.ProfileResult;
 import com.mojang.logging.LogUtils;
+import io.papermc.paper.configuration.GlobalConfiguration;
+import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
 import java.math.BigInteger;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.net.SocketAddress;
 import java.security.PrivateKey;
+import java.util.Map;
 import java.util.Objects;
 import java.util.concurrent.atomic.AtomicInteger;
 import javax.annotation.Nullable;
-import javax.crypto.Cipher;
 import javax.crypto.SecretKey;
 import net.minecraft.CrashReport;
 import net.minecraft.CrashReportCategory;
 import net.minecraft.DefaultUncaughtExceptionHandler;
 import net.minecraft.core.UUIDUtil;
 import net.minecraft.network.Connection;
+import net.minecraft.network.ConnectionProtocol;
 import net.minecraft.network.DisconnectionDetails;
+import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.PacketSendListener;
 import net.minecraft.network.TickablePacketListener;
 import net.minecraft.network.chat.Component;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.PacketUtils;
 import net.minecraft.network.protocol.configuration.ConfigurationProtocols;
 import net.minecraft.network.protocol.cookie.ServerboundCookieResponsePacket;
+import net.minecraft.network.protocol.login.ClientboundCustomQueryPacket;
 import net.minecraft.network.protocol.login.ClientboundGameProfilePacket;
 import net.minecraft.network.protocol.login.ClientboundHelloPacket;
 import net.minecraft.network.protocol.login.ClientboundLoginCompressionPacket;
@@ -35,30 +_,57 @@
 import net.minecraft.network.protocol.login.ServerboundHelloPacket;
 import net.minecraft.network.protocol.login.ServerboundKeyPacket;
 import net.minecraft.network.protocol.login.ServerboundLoginAcknowledgedPacket;
+import net.minecraft.resources.ResourceLocation;
 import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.server.players.PlayerList;
 import net.minecraft.util.Crypt;
 import net.minecraft.util.CryptException;
 import net.minecraft.util.RandomSource;
-import net.minecraft.util.StringUtil;
+import net.neoforged.fml.ModList;
 import org.apache.commons.lang3.Validate;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
 import org.slf4j.Logger;
 
-public class ServerLoginPacketListenerImpl implements ServerLoginPacketListener, TickablePacketListener {
+public class ServerLoginPacketListenerImpl implements ServerLoginPacketListener, TickablePacketListener, CraftPlayer.TransferCookieConnection {
+
+    @Override
+    public boolean isTransferred() {
+        return this.transferred;
+    }
+
+    @Override
+    public ConnectionProtocol getProtocol() {
+        return ConnectionProtocol.LOGIN;
+    }
+
+    @Override
+    public void sendPacket(Packet<?> packet) {
+        this.connection.send(packet);
+    }
+
+    @Override
+    public void kickPlayer(Component reason, org.bukkit.event.player.PlayerKickEvent.Cause cause) { // Paper - kick event causes - during login, no event can be called.
+        this.disconnect(reason);
+    }
+
     private static final AtomicInteger UNIQUE_THREAD_ID = new AtomicInteger(0);
-    static final Logger LOGGER = LogUtils.getLogger();
+    public static final Logger LOGGER = LogUtils.getLogger();
+    private static final java.util.concurrent.ExecutorService authenticatorPool = java.util.concurrent.Executors.newCachedThreadPool(new com.google.common.util.concurrent.ThreadFactoryBuilder().setNameFormat("User Authenticator #%d").setUncaughtExceptionHandler(new DefaultUncaughtExceptionHandler(LOGGER)).build()); // Paper - Cache authenticator threads
     private static final int MAX_TICKS_BEFORE_LOGIN = 600;
     private final byte[] challenge;
-    final MinecraftServer server;
+    public final MinecraftServer server;
     public final Connection connection;
-    private volatile ServerLoginPacketListenerImpl.State state = ServerLoginPacketListenerImpl.State.HELLO;
+    public volatile ServerLoginPacketListenerImpl.State state = ServerLoginPacketListenerImpl.State.HELLO;
     private int tick;
     @Nullable
     String requestedUsername;
     @Nullable
-    private GameProfile authenticatedProfile;
+    public GameProfile authenticatedProfile;
     private final String serverId = "";
     private final boolean transferred;
+    private ServerPlayer player; // CraftBukkit
+    public int velocityLoginMessageId = -1; // Paper - Velocity support
 
     public ServerLoginPacketListenerImpl(MinecraftServer p_10027_, Connection p_10028_, boolean p_320815_) {
         this.server = p_10027_;
@@ -69,9 +_,23 @@
 
     @Override
     public void tick() {
+        // Paper start - Do not allow logins while the server is shutting down
+        if (!MinecraftServer.getServer().isRunning()) {
+            this.disconnect(org.bukkit.craftbukkit.util.CraftChatMessage.fromString(org.spigotmc.SpigotConfig.restartMessage)[0]);
+            return;
+        }
+        // Paper end - Do not allow logins while the server is shutting down
         if (this.state == ServerLoginPacketListenerImpl.State.VERIFYING) {
-            this.verifyLoginAndFinishConnectionSetup(Objects.requireNonNull(this.authenticatedProfile));
-        }
+            if (this.connection.isConnected()) { // Paper - prevent logins to be processed even though disconnect was called
+                this.verifyLoginAndFinishConnectionSetup(Objects.requireNonNull(this.authenticatedProfile));
+            } // Paper - prevent logins to be processed even though disconnect was called
+        }
+
+        // CraftBukkit start
+        if (this.state == ServerLoginPacketListenerImpl.State.WAITING_FOR_COOKIES && !this.player.getBukkitEntity().isAwaitingCookies()) {
+            this.postCookies(this.authenticatedProfile);
+        }
+        // CraftBukkit end
 
         if (this.state == ServerLoginPacketListenerImpl.State.WAITING_FOR_DUPE_DISCONNECT
             && !this.isPlayerAlreadyInWorld(Objects.requireNonNull(this.authenticatedProfile))) {
@@ -88,6 +_,12 @@
         return this.connection.isConnected();
     }
 
+    // CraftBukkit start
+    @Deprecated
+    public void disconnect(String s) {
+        this.disconnect(io.papermc.paper.adventure.PaperAdventure.asVanilla(ColorAPI.colorize(s))); // Paper - Fix hex colors not working in some kick messages
+    }
+
     public void disconnect(Component p_10054_) {
         try {
             LOGGER.info("Disconnecting {}: {}", this.getUserName(), p_10054_.getString());
@@ -115,7 +_,7 @@
     @Override
     public void handleHello(ServerboundHelloPacket p_10047_) {
         Validate.validState(this.state == ServerLoginPacketListenerImpl.State.HELLO, "Unexpected hello packet");
-        Validate.validState(StringUtil.isValidPlayerName(p_10047_.name()), "Invalid characters in username");
+        // Validate.validState(StringUtil.isValidPlayerName(p_10047_.name()), "Invalid characters in username");
         this.requestedUsername = p_10047_.name();
         GameProfile gameprofile = this.server.getSingleplayerProfile();
         if (gameprofile != null && this.requestedUsername.equalsIgnoreCase(gameprofile.getName())) {
@@ -125,7 +_,34 @@
                 this.state = ServerLoginPacketListenerImpl.State.KEY;
                 this.connection.send(new ClientboundHelloPacket("", this.server.getKeyPair().getPublic().getEncoded(), this.challenge, true));
             } else {
-                this.startClientVerification(UUIDUtil.createOfflineProfile(this.requestedUsername));
+                // Paper start - Add Velocity IP Forwarding Support
+                if (GlobalConfiguration.get().proxies.velocity.enabled) {
+                    this.velocityLoginMessageId = java.util.concurrent.ThreadLocalRandom.current().nextInt();
+                    net.minecraft.network.FriendlyByteBuf buf = new net.minecraft.network.FriendlyByteBuf(io.netty.buffer.Unpooled.buffer());
+                    buf.writeByte(VelocityProxy.MAX_SUPPORTED_FORWARDING_VERSION);
+                    ClientboundCustomQueryPacket packet1 = new ClientboundCustomQueryPacket(this.velocityLoginMessageId, ClientboundCustomQueryPacket.readPayload(VelocityProxy.PLAYER_INFO_CHANNEL, buf));
+                    this.connection.send(packet1);
+                    return;
+                }
+                // Paper end - Add Velocity IP Forwarding Support
+                // CraftBukkit start
+                // Paper start - Cache authenticator threads
+                authenticatorPool.execute(new Runnable() {
+
+                    @Override
+                    public void run() {
+                        try {
+                            GameProfile gameprofile = createOfflineProfile(ServerLoginPacketListenerImpl.this.requestedUsername); // Spigot
+                            new LoginHandler().fireEvents(ServerLoginPacketListenerImpl.this, gameprofile);
+                            ServerLoginPacketListenerImpl.this.startClientVerification(gameprofile);
+                        } catch (Exception ex) {
+                            disconnect("Failed to verify username!");
+                            ServerLoginPacketListenerImpl.this.server.server.getLogger().log(java.util.logging.Level.WARNING, "Exception verifying " + ServerLoginPacketListenerImpl.this.requestedUsername, ex);
+                        }
+                    }
+                });
+                // Paper end - Cache authenticator threads
+                // CraftBukkit end
             }
         }
     }
@@ -137,10 +_,41 @@
 
     private void verifyLoginAndFinishConnectionSetup(GameProfile p_294502_) {
         PlayerList playerlist = this.server.getPlayerList();
+        // CraftBukkit start - fire PlayerLoginEvent
+        this.server.getPlayerList().youer$putHandler(this);
         Component component = playerlist.canPlayerLogin(this.connection.getRemoteAddress(), p_294502_);
         if (component != null) {
             this.disconnect(component);
         } else {
+            if (player == null) {
+                player = playerlist.youer$canPlayerLogin$entity.get();
+            }
+            if (this.player.getBukkitEntity().isAwaitingCookies()) {
+                this.state = ServerLoginPacketListenerImpl.State.WAITING_FOR_COOKIES;
+            } else {
+                if (this.server.getCompressionThreshold() >= 0 && !this.connection.isMemoryConnection()) {
+                    this.connection
+                            .send(
+                                    new ClientboundLoginCompressionPacket(this.server.getCompressionThreshold()),
+                                    PacketSendListener.thenRun(() -> this.connection.setupCompression(this.server.getCompressionThreshold(), true))
+                            );
+                }
+
+                boolean flag = playerlist.disconnectAllPlayersWithProfile(p_294502_, this.player); // CraftBukkit - add player reference
+                if (flag) {
+                    this.state = ServerLoginPacketListenerImpl.State.WAITING_FOR_DUPE_DISCONNECT;
+                } else {
+                    this.finishLoginAndWaitForClient(p_294502_);
+                }
+            }
+        }
+    }
+
+    private void postCookies(GameProfile p_294502_) {
+        PlayerList playerlist = this.server.getPlayerList();
+        if (this.player == null) {
+            // CraftBukkit end
+        } else {
             if (this.server.getCompressionThreshold() >= 0 && !this.connection.isMemoryConnection()) {
                 this.connection
                     .send(
@@ -149,7 +_,7 @@
                     );
             }
 
-            boolean flag = playerlist.disconnectAllPlayersWithProfile(p_294502_);
+            boolean flag = playerlist.disconnectAllPlayersWithProfile(p_294502_, this.player); // CraftBukkit - add player reference
             if (flag) {
                 this.state = ServerLoginPacketListenerImpl.State.WAITING_FOR_DUPE_DISCONNECT;
             } else {
@@ -175,17 +_,19 @@
             }
 
             SecretKey secretkey = p_10049_.getSecretKey(privatekey);
-            Cipher cipher = Crypt.getCipher(2, secretkey);
-            Cipher cipher1 = Crypt.getCipher(1, secretkey);
+            // Paper start - Use Velocity cipher
+            // Cipher cipher = Crypt.getCipher(2, secretkey);
+            // Cipher cipher1 = Crypt.getCipher(1, secretkey);
+            // Paper end - Use Velocity cipher
             s = new BigInteger(Crypt.digestData("", this.server.getKeyPair().getPublic(), secretkey)).toString(16);
             this.state = ServerLoginPacketListenerImpl.State.AUTHENTICATING;
-            this.connection.setEncryptionKey(cipher, cipher1);
+            this.connection.setupEncryption(secretkey); // Paper - Use Velocity cipher
         } catch (CryptException cryptexception) {
             throw new IllegalStateException("Protocol error", cryptexception);
         }
 
-        Thread thread = new Thread("User Authenticator #" + UNIQUE_THREAD_ID.incrementAndGet()) {
-            @Override
+        // Paper start - Cache authenticator threads
+        authenticatorPool.execute(new Runnable() {
             public void run() {
                 String s1 = Objects.requireNonNull(ServerLoginPacketListenerImpl.this.requestedUsername, "Player name not initialized");
 
@@ -193,11 +_,16 @@
                     ProfileResult profileresult = ServerLoginPacketListenerImpl.this.server.getSessionService().hasJoinedServer(s1, s, this.getAddress());
                     if (profileresult != null) {
                         GameProfile gameprofile = profileresult.profile();
-                        ServerLoginPacketListenerImpl.LOGGER.info("UUID of player {} is {}", gameprofile.getName(), gameprofile.getId());
+                        // CraftBukkit start - fire PlayerPreLoginEvent
+                        if (!connection.isConnected()) {
+                            return;
+                        }
+                        new LoginHandler().fireEvents(ServerLoginPacketListenerImpl.this, gameprofile);
+                        // CraftBukkit end
                         ServerLoginPacketListenerImpl.this.startClientVerification(gameprofile);
                     } else if (ServerLoginPacketListenerImpl.this.server.isSingleplayer()) {
                         ServerLoginPacketListenerImpl.LOGGER.warn("Failed to verify username but will let them in anyway!");
-                        ServerLoginPacketListenerImpl.this.startClientVerification(UUIDUtil.createOfflineProfile(s1));
+                        ServerLoginPacketListenerImpl.this.startClientVerification(createOfflineProfile(s1)); // Spigot
                     } else {
                         ServerLoginPacketListenerImpl.this.disconnect(Component.translatable("multiplayer.disconnect.unverified_username"));
                         ServerLoginPacketListenerImpl.LOGGER.error("Username '{}' tried to join with an invalid session", s1);
@@ -205,11 +_,16 @@
                 } catch (AuthenticationUnavailableException authenticationunavailableexception) {
                     if (ServerLoginPacketListenerImpl.this.server.isSingleplayer()) {
                         ServerLoginPacketListenerImpl.LOGGER.warn("Authentication servers are down but will let them in anyway!");
-                        ServerLoginPacketListenerImpl.this.startClientVerification(UUIDUtil.createOfflineProfile(s1));
+                        ServerLoginPacketListenerImpl.this.startClientVerification(createOfflineProfile(s1)); // Spigot
                     } else {
-                        ServerLoginPacketListenerImpl.this.disconnect(Component.translatable("multiplayer.disconnect.authservers_down"));
+                        ServerLoginPacketListenerImpl.this.disconnect(io.papermc.paper.adventure.PaperAdventure.asVanilla(io.papermc.paper.configuration.GlobalConfiguration.get().messages.kick.authenticationServersDown)); // Paper - Configurable kick message
                         ServerLoginPacketListenerImpl.LOGGER.error("Couldn't verify username because servers are unavailable");
                     }
+                    // CraftBukkit start - catch all exceptions
+                } catch (Exception exception) {
+                    disconnect("Failed to verify username!");
+                    server.server.getLogger().log(java.util.logging.Level.WARNING, "Exception verifying " + s1, exception);
+                    // CraftBukkit end
                 }
             }
 
@@ -220,9 +_,8 @@
                     ? ((InetSocketAddress)socketaddress).getAddress()
                     : null;
             }
-        };
-        thread.setUncaughtExceptionHandler(new DefaultUncaughtExceptionHandler(LOGGER));
-        thread.start();
+        });
+        // Paper end - Cache authenticator threads
     }
 
     @Override
@@ -230,14 +_,83 @@
         this.disconnect(ServerCommonPacketListenerImpl.DISCONNECT_UNEXPECTED_QUERY);
     }
 
+    public void youer$handleCustomQueryPacket(FriendlyByteBuf payload, String type) {
+        var buffer = payload.readNullable(r -> {
+            int i = r.readableBytes();
+            if (i >= 0 && i <= 1048576) {
+                return new FriendlyByteBuf(r.readBytes(i));
+            } else {
+                throw new IllegalArgumentException("Payload may not be larger than 1048576 bytes");
+            }
+        });
+        if (buffer == null) {
+            this.disconnect(I18n.as("velocity.requires"));
+            return;
+        }
+        if (!VelocityProxy.checkIntegrity(buffer)) {
+            this.disconnect("Unable to verify player details");
+            return;
+        }
+
+        int version = buffer.readVarInt();
+        if (version > VelocityProxy.MAX_SUPPORTED_FORWARDING_VERSION) {
+            this.disconnect(Component.literal(String.format("Unsupported forwarding version %d, supported up to %d", version, VelocityProxy.MAX_SUPPORTED_FORWARDING_VERSION)));
+            return;
+        }
+
+        java.net.SocketAddress listening = this.connection.getRemoteAddress();
+        int port = 0;
+        if (listening instanceof java.net.InetSocketAddress) {
+            port = ((java.net.InetSocketAddress) listening).getPort();
+        }
+        this.connection.address = new java.net.InetSocketAddress(VelocityProxy.readAddress(buffer), port);
+
+        if (ModList.get().isLoaded("fabric_networking_api_v1")) fixFabricNetworkingIssue();
+
+        this.authenticatedProfile = VelocityProxy.createProfile(buffer);
+        //TODO Update handling for lazy sessions, might not even have to do anything?
+
+        // Proceed with login
+        authenticatorPool.execute(() -> {
+            try {
+                new LoginHandler().fireEvents(ServerLoginPacketListenerImpl.this, this.authenticatedProfile);
+                ServerLoginPacketListenerImpl.this.startClientVerification(this.authenticatedProfile);
+            } catch (Exception ex) {
+                disconnect("Failed to verify username!");
+                server.server.getLogger().log(java.util.logging.Level.WARNING, "Exception verifying " + authenticatedProfile.getName(), ex);
+            }
+        });
+        ServerLoginPacketListenerImpl.LOGGER.info("Authenticated {} ({}) via Velocity proxy form {}", this.authenticatedProfile.getName(), this.authenticatedProfile.getId(), type);
+    }
+
+    private void fixFabricNetworkingIssue() {
+        try {
+            Class<?> extClass = Class.forName("net.fabricmc.fabric.impl.networking.NetworkHandlerExtensions");
+            Method getAddon = extClass.getMethod("getAddon");
+            Object addon = getAddon.invoke(this);
+
+            Class<?> addonClass = Class.forName("net.fabricmc.fabric.impl.networking.server.ServerLoginNetworkAddon");
+            Field channelsField = addonClass.getDeclaredField("channels");
+            channelsField.setAccessible(true);
+
+            @SuppressWarnings("unchecked") Map<Integer, ResourceLocation> channels = (Map<Integer, ResourceLocation>) channelsField.get(addon);
+            channels.remove(velocityLoginMessageId);
+        } catch (ClassNotFoundException | NoSuchMethodException | NoSuchFieldException | IllegalAccessException |
+                 InvocationTargetException e) {
+            this.disconnect(Component.literal("Server encountered an error applying the Fabric Networking API workaround.\nThis is a server-side issue. Please contact an administrator."));
+        }
+    }
+
     @Override
     public void handleLoginAcknowledgement(ServerboundLoginAcknowledgedPacket p_295661_) {
+        PacketUtils.ensureRunningOnSameThread(p_295661_, this, this.server); // CraftBukkit
         Validate.validState(this.state == ServerLoginPacketListenerImpl.State.PROTOCOL_SWITCHING, "Unexpected login acknowledgement packet");
         this.connection.setupOutboundProtocol(ConfigurationProtocols.CLIENTBOUND);
         CommonListenerCookie commonlistenercookie = CommonListenerCookie.createInitial(Objects.requireNonNull(this.authenticatedProfile), this.transferred);
         ServerConfigurationPacketListenerImpl serverconfigurationpacketlistenerimpl = new ServerConfigurationPacketListenerImpl(
             this.server, this.connection, commonlistenercookie
         );
+        serverconfigurationpacketlistenerimpl.setPlayer(this.player);
         this.connection.setupInboundProtocol(ConfigurationProtocols.SERVERBOUND, serverconfigurationpacketlistenerimpl);
         serverconfigurationpacketlistenerimpl.startConfiguration();
         this.state = ServerLoginPacketListenerImpl.State.ACCEPTED;
@@ -250,8 +_,40 @@
 
     @Override
     public void handleCookieResponse(ServerboundCookieResponsePacket p_320866_) {
+        // CraftBukkit start
+        PacketUtils.ensureRunningOnSameThread(p_320866_, this, this.server);
+        if (this.player != null && this.player.getBukkitEntity().handleCookieResponse(p_320866_)) {
+            return;
+        }
+        // CraftBukkit end
         this.disconnect(ServerCommonPacketListenerImpl.DISCONNECT_UNEXPECTED_QUERY);
     }
+
+    // Spigot start
+    protected GameProfile createOfflineProfile(String s) {
+        java.util.UUID uuid;
+        if ( this.connection.spoofedUUID != null )
+        {
+            uuid = this.connection.spoofedUUID;
+        } else
+        {
+            uuid = UUIDUtil.createOfflinePlayerUUID( s );
+        }
+
+        GameProfile gameProfile = new GameProfile( uuid, s );
+
+        if (this.connection.spoofedProfile != null)
+        {
+            for ( com.mojang.authlib.properties.Property property : this.connection.spoofedProfile )
+            {
+                if ( !ServerHandshakePacketListenerImpl.PROP_PATTERN.matcher( property.name()).matches() ) continue;
+                gameProfile.getProperties().put( property.name(), property );
+            }
+        }
+
+        return gameProfile;
+    }
+    // Spigot end
 
     public static enum State {
         HELLO,
@@ -259,6 +_,7 @@
         AUTHENTICATING,
         NEGOTIATING,
         VERIFYING,
+        WAITING_FOR_COOKIES,
         WAITING_FOR_DUPE_DISCONNECT,
         PROTOCOL_SWITCHING,
         ACCEPTED;
