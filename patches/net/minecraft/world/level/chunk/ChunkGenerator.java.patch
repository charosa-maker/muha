--- a/net/minecraft/world/level/chunk/ChunkGenerator.java
+++ b/net/minecraft/world/level/chunk/ChunkGenerator.java
@@ -1,6 +_,5 @@
 package net.minecraft.world.level.chunk;
 
-import com.google.common.base.Suppliers;
 import com.mojang.datafixers.util.Pair;
 import com.mojang.serialization.Codec;
 import com.mojang.serialization.MapCodec;
@@ -76,12 +_,16 @@
 import net.minecraft.world.level.levelgen.structure.placement.StructurePlacement;
 import net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplateManager;
 import org.apache.commons.lang3.mutable.MutableBoolean;
+import org.bukkit.craftbukkit.generator.CraftLimitedRegion;
+import org.bukkit.craftbukkit.util.RandomSourceWrapper;
+import org.bukkit.craftbukkit.generator.structure.CraftStructure;
+import org.bukkit.generator.BlockPopulator;import org.spigotmc.AsyncCatcher;
 
 public abstract class ChunkGenerator {
     public static final Codec<ChunkGenerator> CODEC = BuiltInRegistries.CHUNK_GENERATOR
         .byNameCodec()
         .dispatchStable(ChunkGenerator::codec, Function.identity());
-    protected final BiomeSource biomeSource;
+    protected BiomeSource biomeSource;
     private final Supplier<List<FeatureSorter.StepFeatureData>> featuresPerStep;
     public final Function<Holder<Biome>, BiomeGenerationSettings> generationSettingsGetter;
 
@@ -92,19 +_,24 @@
     public ChunkGenerator(BiomeSource p_255838_, Function<Holder<Biome>, BiomeGenerationSettings> p_256216_) {
         this.biomeSource = p_255838_;
         this.generationSettingsGetter = p_256216_;
-        this.featuresPerStep = Suppliers.memoize(
+        this.featuresPerStep = net.neoforged.neoforge.common.util.Lazy.of(
             () -> FeatureSorter.buildFeaturesPerStep(List.copyOf(p_255838_.possibleBiomes()), p_223216_ -> p_256216_.apply(p_223216_).features(), true)
         );
     }
 
+    @org.jetbrains.annotations.ApiStatus.Internal
+    public void refreshFeaturesPerStep() {
+        ((net.neoforged.neoforge.common.util.Lazy<?>) this.featuresPerStep).invalidate();
+    }
+
     public void validate() {
         this.featuresPerStep.get();
     }
 
     protected abstract MapCodec<? extends ChunkGenerator> codec();
 
-    public ChunkGeneratorStructureState createState(HolderLookup<StructureSet> p_256405_, RandomState p_256101_, long p_256018_) {
-        return ChunkGeneratorStructureState.createForNormal(p_256101_, p_256018_, this.biomeSource, p_256405_);
+    public ChunkGeneratorStructureState createState(HolderLookup<StructureSet> p_256405_, RandomState p_256101_, long p_256018_, org.spigotmc.SpigotWorldConfig conf) { // Spigot
+        return ChunkGeneratorStructureState.createForNormal(p_256101_, p_256018_, this.biomeSource, p_256405_, conf); // Spigot
     }
 
     public Optional<ResourceKey<MapCodec<? extends ChunkGenerator>>> getTypeNameForDataFixer() {
@@ -132,6 +_,24 @@
     public Pair<BlockPos, Holder<Structure>> findNearestMapStructure(
         ServerLevel p_223038_, HolderSet<Structure> p_223039_, BlockPos p_223040_, int p_223041_, boolean p_223042_
     ) {
+        // Paper start - StructuresLocateEvent
+        final org.bukkit.World bukkitWorld = p_223038_.getWorld();
+        final org.bukkit.Location origin = io.papermc.paper.util.MCUtil.toLocation(p_223038_, p_223040_);
+        final List<org.bukkit.generator.structure.Structure> apiStructures = p_223039_.stream().map(Holder::value).map(nms -> org.bukkit.craftbukkit.generator.structure.CraftStructure.minecraftToBukkit(nms)).toList();
+        if (!apiStructures.isEmpty()) {
+            final io.papermc.paper.event.world.StructuresLocateEvent event = new io.papermc.paper.event.world.StructuresLocateEvent(bukkitWorld, origin, apiStructures, p_223041_, p_223042_);
+            if (!event.callEvent()) {
+                return null;
+            }
+            if (event.getResult() != null) {
+                return Pair.of(io.papermc.paper.util.MCUtil.toBlockPos(event.getResult().pos()), p_223038_.registryAccess().registryOrThrow(Registries.STRUCTURE).wrapAsHolder(org.bukkit.craftbukkit.generator.structure.CraftStructure.bukkitToMinecraft(event.getResult().structure())));
+            }
+            p_223040_ = io.papermc.paper.util.MCUtil.toBlockPosition(event.getOrigin());
+            p_223041_ = event.getRadius();
+            p_223042_ = event.shouldFindUnexplored();
+            p_223039_ = HolderSet.direct(api -> p_223038_.registryAccess().registryOrThrow(Registries.STRUCTURE).wrapAsHolder(org.bukkit.craftbukkit.generator.structure.CraftStructure.bukkitToMinecraft(api)), event.getStructures());
+        }
+        // Paper end
         ChunkGeneratorStructureState chunkgeneratorstructurestate = p_223038_.getChunkSource().getGeneratorState();
         Map<StructurePlacement, Set<Holder<Structure>>> map = new Object2ObjectArrayMap<>();
 
@@ -227,6 +_,8 @@
             BlockPos.MutableBlockPos blockpos$mutableblockpos = new BlockPos.MutableBlockPos();
 
             for (ChunkPos chunkpos : list) {
+                if (!p_223183_.paperConfig().environment.locateStructuresOutsideWorldBorder && !p_223183_.getWorldBorder().isChunkInBounds(chunkpos.x, chunkpos.z)) { continue; } // Paper - Bound treasure maps to world border
+
                 blockpos$mutableblockpos.set(SectionPos.sectionToBlockCoord(chunkpos.x, 8), 32, SectionPos.sectionToBlockCoord(chunkpos.z, 8));
                 double d1 = blockpos$mutableblockpos.distSqr(p_223185_);
                 boolean flag = pair == null || d1 < d0;
@@ -313,6 +_,31 @@
         }
     }
 
+    public void applyBiomeDecorationCB(WorldGenLevel pLevel, ChunkAccess pChunk, StructureManager pStructureManager) { // CraftBukkit
+        this.applyBiomeDecorationCB(pLevel, pChunk, pStructureManager, true);
+    }
+
+    public void applyBiomeDecorationCB(WorldGenLevel pLevel, ChunkAccess pChunk, StructureManager pStructureManager, boolean vanilla) {
+        if (vanilla) {
+            this.applyBiomeDecoration(pLevel, pChunk, pStructureManager);
+        }
+        org.bukkit.World world = pLevel.getMinecraftWorld().getWorld();
+        // only call when a populator is present (prevents unnecessary entity conversion)
+        if (!world.getPopulators().isEmpty()) {
+            CraftLimitedRegion limitedRegion = new CraftLimitedRegion(pLevel, pChunk.getPos());
+            int x = pChunk.getPos().x;
+            int z = pChunk.getPos().z;
+            for (BlockPopulator populator : world.getPopulators()) {
+                WorldgenRandom seededrandom = new WorldgenRandom(new LegacyRandomSource(pLevel.getSeed()));
+                seededrandom.setDecorationSeed(pLevel.getSeed(), x, z);
+                populator.populate(world, new RandomSourceWrapper.RandomWrapper(seededrandom), x, z, limitedRegion);
+            }
+            limitedRegion.saveEntities();
+            limitedRegion.breakLink();
+        }
+        // CraftBukkit end
+    }
+
     public void applyBiomeDecoration(WorldGenLevel p_223087_, ChunkAccess p_223088_, StructureManager p_223089_) {
         ChunkPos chunkpos = p_223088_.getPos();
         if (!SharedConstants.debugVoidTerrain(chunkpos)) {
@@ -384,7 +_,14 @@
                             int l1 = aint[k1];
                             PlacedFeature placedfeature = featuresorter$stepfeaturedata.features().get(l1);
                             Supplier<String> supplier1 = () -> registry1.getResourceKey(placedfeature).map(Object::toString).orElseGet(placedfeature::toString);
-                            worldgenrandom.setFeatureSeed(i, l1, k);
+                            // Paper start - Configurable feature seeds; change populationSeed used in random
+                            long featurePopulationSeed = i;
+                            final long configFeatureSeed = p_223087_.getMinecraftWorld().paperConfig().featureSeeds.features.getLong(placedfeature.feature());
+                            if (configFeatureSeed != -1) {
+                                featurePopulationSeed = worldgenrandom.setDecorationSeed(configFeatureSeed, blockpos.getX(), blockpos.getZ()); // See seededrandom.setDecorationSeed from above
+                            }
+                            worldgenrandom.setFeatureSeed(featurePopulationSeed, l1, k);
+                            // Paper end - Configurable feature seeds
 
                             try {
                                 p_223087_.setCurrentlyGenerating(supplier1);
@@ -429,6 +_,10 @@
         return this.biomeSource;
     }
 
+    public void setBiomeSource(BiomeSource biomeSource) {
+        this.biomeSource = biomeSource;
+    }
+
     public abstract int getGenDepth();
 
     public WeightedRandomList<MobSpawnSettings.SpawnerData> getMobsAt(
@@ -551,6 +_,22 @@
             p_223107_, this, this.biomeSource, p_223108_, p_223109_, p_223110_, p_223112_, i, p_223111_, predicate
         );
         if (structurestart.isValid()) {
+            if (AsyncCatcher.catchAsync()) {
+                // CraftBukkit start
+                BoundingBox box = structurestart.getBoundingBox();
+                org.bukkit.event.world.AsyncStructureSpawnEvent event = new org.bukkit.event.world.AsyncStructureSpawnEvent(
+                        p_223106_.level.getMinecraftWorld().getWorld(),
+                        CraftStructure.minecraftToBukkit(structure),
+                        new org.bukkit.util.BoundingBox(box.minX(), box.minY(), box.minZ(), box.maxX(), box.maxY(), box.maxZ()),
+                        p_223112_.x,
+                        p_223112_.z
+                );
+                org.bukkit.Bukkit.getPluginManager().callEvent(event);
+                if (event.isCancelled()) {
+                    return true;
+                }
+                // CraftBukkit end
+            }
             p_223106_.setStartForStructure(p_223113_, structure, structurestart, p_223111_);
             return true;
         } else {
