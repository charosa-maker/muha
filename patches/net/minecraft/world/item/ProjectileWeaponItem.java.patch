--- a/net/minecraft/world/item/ProjectileWeaponItem.java
+++ b/net/minecraft/world/item/ProjectileWeaponItem.java
@@ -2,6 +_,7 @@
 
 import java.util.ArrayList;
 import java.util.List;
+import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.function.Predicate;
 import javax.annotation.Nullable;
 import net.minecraft.core.component.DataComponents;
@@ -15,6 +_,7 @@
 import net.minecraft.world.entity.projectile.Projectile;
 import net.minecraft.world.item.enchantment.EnchantmentHelper;
 import net.minecraft.world.level.Level;
+import org.bukkit.craftbukkit.event.CraftEventFactory;
 
 public abstract class ProjectileWeaponItem extends Item {
     public static final Predicate<ItemStack> ARROW_ONLY = p_43017_ -> p_43017_.is(ItemTags.ARROWS);
@@ -24,12 +_,42 @@
         super(p_43009_);
     }
 
+    /**
+     * @deprecated Use ItemStack sensitive version {@link ProjectileWeaponItem#getSupportedHeldProjectiles(ItemStack)}
+     */
+    @Deprecated
     public Predicate<ItemStack> getSupportedHeldProjectiles() {
         return this.getAllSupportedProjectiles();
     }
 
+    /**
+     * @deprecated Use ItemStack sensitive version {@link ProjectileWeaponItem#getAllSupportedProjectiles(ItemStack)}
+     */
+    @Deprecated
     public abstract Predicate<ItemStack> getAllSupportedProjectiles();
 
+    /**
+     * Override this method if the weapon stack allows special projectile that would only be used if it's in hand.
+     * The default return value is a union-predicate of {@link ProjectileWeaponItem#getAllSupportedProjectiles(ItemStack)}
+     * and {@link ProjectileWeaponItem#getSupportedHeldProjectiles()}
+     *
+     * @param stack The ProjectileWeapon stack
+     * @return A predicate that returns true for supported projectile stack in hand
+     */
+    public Predicate<ItemStack> getSupportedHeldProjectiles(ItemStack stack) {
+        return getAllSupportedProjectiles(stack).or(getSupportedHeldProjectiles());
+    }
+
+    /**
+     * Override this method if the allowed projectile is weapon stack dependent.
+     *
+     * @param stack The ProjectileWeapon stack
+     * @return A predicate that returns true for all supported projectile stack
+     */
+    public Predicate<ItemStack> getAllSupportedProjectiles(ItemStack stack) {
+        return getAllSupportedProjectiles();
+    }
+
     public static ItemStack getHeldProjectile(LivingEntity p_43011_, Predicate<ItemStack> p_43012_) {
         if (p_43012_.test(p_43011_.getItemInHand(InteractionHand.OFF_HAND))) {
             return p_43011_.getItemInHand(InteractionHand.OFF_HAND);
@@ -68,7 +_,26 @@
                 f3 = -f3;
                 Projectile projectile = this.createProjectile(p_346125_, p_330728_, p_330646_, itemstack, p_331107_);
                 this.shootProjectile(p_330728_, projectile, i, p_331007_, p_331445_, f4, p_331167_);
-                p_346125_.addFreshEntity(projectile);
+                if (p_331167_ != null) {
+                    // CraftBukkit start
+                    org.bukkit.event.entity.EntityShootBowEvent event = CraftEventFactory.callEntityShootBowEvent(p_331167_, p_330646_, itemstack, projectile, p_331152_, p_331007_, true);
+                    if (event.isCancelled()) {
+                        event.getProjectile().remove();
+                        return;
+                    }
+                    if (event.getProjectile() == projectile.getBukkitEntity()) {
+                        p_346125_.addFreshEntity(projectile);
+                        if (!p_346125_.canAddFreshEntity()) {
+                            if (p_331167_ instanceof net.minecraft.server.level.ServerPlayer) {
+                                ((net.minecraft.server.level.ServerPlayer) p_331167_).getBukkitEntity().updateInventory();
+                            }
+                            return;
+                        }
+                    }
+                    // CraftBukkit end
+                } else {
+                    p_346125_.addFreshEntity(projectile);
+                }
                 p_330646_.hurtAndBreak(this.getDurabilityUse(itemstack), p_330728_, LivingEntity.getSlotForHand(p_331152_));
                 if (p_330646_.isEmpty()) {
                     break;
@@ -92,8 +_,10 @@
             abstractarrow.setCritArrow(true);
         }
 
-        return abstractarrow;
+        return customArrow(abstractarrow, p_331497_, p_330846_);
     }
+
+    protected static AtomicBoolean draw$consume = new AtomicBoolean(true);
 
     protected static List<ItemStack> draw(ItemStack p_331565_, ItemStack p_330406_, LivingEntity p_330823_) {
         if (p_330406_.isEmpty()) {
@@ -104,7 +_,7 @@
             ItemStack itemstack1 = p_330406_.copy();
 
             for (int j = 0; j < i; j++) {
-                ItemStack itemstack = useAmmo(p_331565_, j == 0 ? p_330406_ : itemstack1, p_330823_, j > 0);
+                ItemStack itemstack = useAmmo(p_331565_, j == 0 ? p_330406_ : itemstack1, p_330823_, j > 0 || !draw$consume.getAndSet(true)); // Paper
                 if (!itemstack.isEmpty()) {
                     list.add(itemstack);
                 }
@@ -113,9 +_,14 @@
             return list;
         }
     }
+    protected static List<ItemStack> draw(ItemStack p_331565_, ItemStack p_330406_, LivingEntity p_330823_, boolean consume) {
+        draw$consume.set(consume);
+        return draw(p_331565_, p_330406_, p_330823_);
+    }
 
     protected static ItemStack useAmmo(ItemStack p_331207_, ItemStack p_331434_, LivingEntity p_330302_, boolean p_330934_) {
-        int i = !p_330934_ && !p_330302_.hasInfiniteMaterials() && p_330302_.level() instanceof ServerLevel serverlevel
+        // Neo: Adjust this check to respect ArrowItem#isInfinite, bypassing processAmmoUse if true.
+        int i = !p_330934_ && p_330302_.level() instanceof ServerLevel serverlevel && !(p_330302_.hasInfiniteMaterials() || (p_331434_.getItem() instanceof ArrowItem ai && ai.isInfinite(p_331434_, p_331207_, p_330302_)))
             ? EnchantmentHelper.processAmmoUse(serverlevel, p_331207_, p_331434_, 1)
             : 0;
         if (i > p_331434_.getCount()) {
@@ -132,5 +_,20 @@
 
             return itemstack;
         }
+    }
+
+    public AbstractArrow customArrow(AbstractArrow arrow, ItemStack projectileStack, ItemStack weaponStack) {
+        return arrow;
+    }
+
+    /**
+     * Neo: Controls what ammo ItemStack that Creative Mode should return if the player has no valid ammo in inventory.
+     * Modded weapons should override this to return their own ammo if they do not use vanilla arrows.
+     * @param player The player (if in context) firing the weapon
+     * @param projectileWeaponItem The weapon ItemStack the ammo is for
+     * @return The default ammo ItemStack for this weapon
+     */
+    public ItemStack getDefaultCreativeAmmo(@Nullable Player player, ItemStack projectileWeaponItem) {
+        return Items.ARROW.getDefaultInstance();
     }
 }
