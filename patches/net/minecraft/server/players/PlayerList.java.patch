--- a/net/minecraft/server/players/PlayerList.java
+++ b/net/minecraft/server/players/PlayerList.java
@@ -3,25 +_,33 @@
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
+import com.mohistmc.youer.api.ColorAPI;
+import com.mohistmc.youer.bukkit.inventory.InventoryOwner;
 import com.mojang.authlib.GameProfile;
 import com.mojang.logging.LogUtils;
 import com.mojang.serialization.Dynamic;
+import com.destroystokyo.paper.console.TerminalConsoleCommandSender;
+import com.destroystokyo.paper.event.player.PlayerSetSpawnEvent;
+import com.destroystokyo.paper.event.server.WhitelistToggleEvent;
 import java.io.File;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
 import java.net.SocketAddress;
 import java.nio.file.Path;
 import java.text.SimpleDateFormat;
 import java.time.Instant;
 import java.util.EnumSet;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Optional;
 import java.util.Set;
 import java.util.UUID;
+import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.Function;
 import java.util.function.Predicate;
 import javax.annotation.Nullable;
 import net.minecraft.ChatFormatting;
-import net.minecraft.FileUtil;
 import net.minecraft.commands.CommandSourceStack;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.LayeredRegistryAccess;
@@ -67,11 +_,13 @@
 import net.minecraft.server.PlayerAdvancements;
 import net.minecraft.server.RegistryLayer;
 import net.minecraft.server.ServerScoreboard;
+import net.minecraft.server.dedicated.DedicatedServer;
 import net.minecraft.server.level.ClientInformation;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.server.network.CommonListenerCookie;
 import net.minecraft.server.network.ServerGamePacketListenerImpl;
+import net.minecraft.server.network.ServerLoginPacketListenerImpl;
 import net.minecraft.sounds.SoundEvents;
 import net.minecraft.sounds.SoundSource;
 import net.minecraft.stats.ServerStatsCounter;
@@ -98,6 +_,16 @@
 import net.minecraft.world.scores.Objective;
 import net.minecraft.world.scores.PlayerTeam;
 import net.minecraft.world.scores.Team;
+import org.bukkit.Location;
+import org.bukkit.craftbukkit.CraftServer;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.bukkit.craftbukkit.util.CraftLocation;
+import org.bukkit.event.player.PlayerChangedWorldEvent;
+import org.bukkit.event.player.PlayerJoinEvent;
+import org.bukkit.event.player.PlayerLoginEvent;
+import org.bukkit.event.player.PlayerQuitEvent;
+import org.bukkit.event.player.PlayerRespawnEvent;
 import org.slf4j.Logger;
 
 public abstract class PlayerList {
@@ -128,15 +_,29 @@
     private boolean allowCommandsForAllPlayers;
     private static final boolean ALLOW_LOGOUTIVATOR = false;
     private int sendAllPlayerInfoIn;
+    private final List<ServerPlayer> playersView = java.util.Collections.unmodifiableList(players);
+
+    // CraftBukkit start
+    private CraftServer cserver;
+    private final Map<String,ServerPlayer> playersByName = new java.util.HashMap<>();
+    public @Nullable String collideRuleTeamName; // Paper - Configurable player collision
 
     public PlayerList(MinecraftServer p_203842_, LayeredRegistryAccess<RegistryLayer> p_251844_, PlayerDataStorage p_203844_, int p_203845_) {
+        this.cserver = p_203842_.server = new CraftServer((DedicatedServer) p_203842_, this);
+        p_203842_.console = new TerminalConsoleCommandSender(); // Paper
+        // CraftBukkit end
         this.server = p_203842_;
         this.registries = p_251844_;
         this.maxPlayers = p_203845_;
         this.playerIo = p_203844_;
     }
+    public void loadAndSaveFiles() {
+
+    }; // Paper - fix converting txt to json file; moved from DedicatedPlayerList constructor
 
     public void placeNewPlayer(Connection p_11262_, ServerPlayer p_11263_, CommonListenerCookie p_301988_) {
+        p_11263_.isRealPlayer = true; // Paper
+        p_11263_.loginTime = System.currentTimeMillis(); // Paper - Replace OfflinePlayer#getLastPlayed
         GameProfile gameprofile = p_11263_.getGameProfile();
         GameProfileCache gameprofilecache = this.server.getProfileCache();
         String s;
@@ -149,10 +_,19 @@
         }
 
         Optional<CompoundTag> optional1 = this.load(p_11263_);
+        // CraftBukkit start - Better rename detection
+        if (optional1.isPresent()) {
+            CompoundTag nbttagcompound = optional1.get();
+            if (nbttagcompound.contains("bukkit")) {
+                CompoundTag bukkit = nbttagcompound.getCompound("bukkit");
+                s = bukkit.contains("lastKnownName", 8) ? bukkit.getString("lastKnownName") : s;
+            }
+        }
+        // CraftBukkit end
         ResourceKey<Level> resourcekey = optional1.<ResourceKey<Level>>flatMap(
                 p_337568_ -> DimensionType.parseLegacy(new Dynamic<>(NbtOps.INSTANCE, p_337568_.get("Dimension"))).resultOrPartial(LOGGER::error)
             )
-            .orElse(Level.OVERWORLD);
+            .orElse(p_11263_.serverLevel().dimension());
         ServerLevel serverlevel = this.server.getLevel(resourcekey);
         ServerLevel serverlevel1;
         if (serverlevel == null) {
@@ -161,36 +_,47 @@
         } else {
             serverlevel1 = serverlevel;
         }
-
+        if (optional1.isEmpty() ) {
+            p_11263_.spawnReason = org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.DEFAULT; // set Player SpawnReason to DEFAULT on first login
+            // Paper end - reset to main world spawn if first spawn or invalid world
+            p_11263_.moveTo(p_11263_.adjustSpawnLocation(serverlevel1, serverlevel1.getSharedSpawnPos()).getBottomCenter(), serverlevel1.getSharedSpawnAngle(), 0.0F); // Paper - MC-200092 - fix first spawn pos yaw being ignored
+        }
         p_11263_.setServerLevel(serverlevel1);
         String s1 = p_11262_.getLoggableAddress(this.server.logIPs());
-        LOGGER.info(
-            "{}[{}] logged in with entity id {} at ({}, {}, {})",
-            p_11263_.getName().getString(),
-            s1,
-            p_11263_.getId(),
-            p_11263_.getX(),
-            p_11263_.getY(),
-            p_11263_.getZ()
-        );
+
+        // Spigot start - spawn location event
+        org.bukkit.entity.Player spawnPlayer = p_11263_.getBukkitEntity();
+        org.spigotmc.event.player.PlayerSpawnLocationEvent ev = new org.spigotmc.event.player.PlayerSpawnLocationEvent(spawnPlayer, spawnPlayer.getLocation());
+        cserver.getPluginManager().callEvent(ev);
+        org.bukkit.Location loc = ev.getSpawnLocation();
+        serverlevel1 = ((CraftWorld) loc.getWorld()).getHandle();
+        p_11263_.spawnIn(serverlevel1);
+        p_11263_.gameMode.setLevel((net.minecraft.server.level.ServerLevel) p_11263_.level());
+        // Paper start - set raw so we aren't fully joined to the world (not added to chunk or world)
+        p_11263_.setPosRaw(loc.getX(), loc.getY(), loc.getZ());
+        p_11263_.setRot(loc.getYaw(), loc.getPitch());
+        // Paper end - set raw so we aren't fully joined to the world
+        // Spigot end
+
         LevelData leveldata = serverlevel1.getLevelData();
         p_11263_.loadGameTypes(optional1.orElse(null));
         ServerGamePacketListenerImpl servergamepacketlistenerimpl = new ServerGamePacketListenerImpl(this.server, p_11262_, p_11263_, p_301988_);
         p_11262_.setupInboundProtocol(
-            GameProtocols.SERVERBOUND_TEMPLATE.bind(RegistryFriendlyByteBuf.decorator(this.server.registryAccess())), servergamepacketlistenerimpl
+            GameProtocols.SERVERBOUND_TEMPLATE.bind(RegistryFriendlyByteBuf.decorator(this.server.registryAccess(), servergamepacketlistenerimpl.getConnectionType())), servergamepacketlistenerimpl
         );
         GameRules gamerules = serverlevel1.getGameRules();
         boolean flag = gamerules.getBoolean(GameRules.RULE_DO_IMMEDIATE_RESPAWN);
         boolean flag1 = gamerules.getBoolean(GameRules.RULE_REDUCEDDEBUGINFO);
         boolean flag2 = gamerules.getBoolean(GameRules.RULE_LIMITED_CRAFTING);
+        // Spigot - view distance
         servergamepacketlistenerimpl.send(
             new ClientboundLoginPacket(
                 p_11263_.getId(),
                 leveldata.isHardcore(),
                 this.server.levelKeys(),
                 this.getMaxPlayers(),
-                this.viewDistance,
-                this.simulationDistance,
+                serverlevel1.spigotConfig.viewDistance, // Spigot
+                serverlevel1.spigotConfig.simulationDistance, // Spigot
                 flag1,
                 !flag,
                 flag2,
@@ -201,6 +_,7 @@
         servergamepacketlistenerimpl.send(new ClientboundChangeDifficultyPacket(leveldata.getDifficulty(), leveldata.isDifficultyLocked()));
         servergamepacketlistenerimpl.send(new ClientboundPlayerAbilitiesPacket(p_11263_.getAbilities()));
         servergamepacketlistenerimpl.send(new ClientboundSetCarriedItemPacket(p_11263_.getInventory().selected));
+        net.neoforged.neoforge.common.NeoForge.EVENT_BUS.post(new net.neoforged.neoforge.event.OnDatapackSyncEvent(this, p_11263_));
         servergamepacketlistenerimpl.send(new ClientboundUpdateRecipesPacket(this.server.getRecipeManager().getOrderedRecipes()));
         this.sendPlayerPermissionLevel(p_11263_);
         p_11263_.getStats().markAllDirty();
@@ -214,25 +_,97 @@
             mutablecomponent = Component.translatable("multiplayer.player.joined.renamed", p_11263_.getDisplayName(), s);
         }
 
-        this.broadcastSystemMessage(mutablecomponent.withStyle(ChatFormatting.YELLOW), false);
+        // CraftBukkit start
+        mutablecomponent.withStyle(ChatFormatting.YELLOW);
+        Component joinMessage = mutablecomponent; // Paper - Adventure
+
         servergamepacketlistenerimpl.teleport(p_11263_.getX(), p_11263_.getY(), p_11263_.getZ(), p_11263_.getYRot(), p_11263_.getXRot());
         ServerStatus serverstatus = this.server.getStatus();
         if (serverstatus != null && !p_301988_.transferred()) {
             p_11263_.sendServerStatus(serverstatus);
         }
 
-        p_11263_.connection.send(ClientboundPlayerInfoUpdatePacket.createPlayerInitializing(this.players));
+        // p_11263_.connection.send(ClientboundPlayerInfoUpdatePacket.createPlayerInitializing(this.players));
         this.players.add(p_11263_);
+        this.playersByName.put(p_11263_.getScoreboardName().toLowerCase(java.util.Locale.ROOT), p_11263_); // Spigot
         this.playersByUUID.put(p_11263_.getUUID(), p_11263_);
-        this.broadcastAll(ClientboundPlayerInfoUpdatePacket.createPlayerInitializing(List.of(p_11263_)));
-        this.sendLevelInfo(p_11263_, serverlevel1);
+        // this.broadcastAll(ClientboundPlayerInfoUpdatePacket.createPlayerInitializing(List.of(p_11263_)));
+
+        // Paper start - Fire PlayerJoinEvent when Player is actually ready; correctly register player BEFORE PlayerJoinEvent, so the entity is valid and doesn't require tick delay hacks
+        p_11263_.supressTrackerForLogin = true;
         serverlevel1.addNewPlayer(p_11263_);
-        this.server.getCustomBossEvents().onPlayerConnect(p_11263_);
+        this.server.getCustomBossEvents().onPlayerConnect(p_11263_); // see commented out section below worldserver.addPlayerJoin(entityplayer);
+        this.mountSavedVehicle(p_11263_, serverlevel1, optional1);
+        // Paper end - Fire PlayerJoinEvent when Player is actually ready
+
+        // CraftBukkit start
+        CraftPlayer bukkitPlayer = p_11263_.getBukkitEntity();
+        // Ensure that player inventory is populated with its viewer
+        p_11263_.containerMenu.transferTo(p_11263_.containerMenu, bukkitPlayer);
+        PlayerJoinEvent playerJoinEvent = new PlayerJoinEvent(bukkitPlayer, io.papermc.paper.adventure.PaperAdventure.asAdventure(joinMessage)); // Paper - Adventure
+        cserver.getPluginManager().callEvent(playerJoinEvent);
+        if (!p_11263_.connection.isAcceptingMessages()) {
+            return;
+        }
+        final net.kyori.adventure.text.Component jm = playerJoinEvent.joinMessage();
+        if (jm != null && !jm.equals(net.kyori.adventure.text.Component.empty())) { // Paper - Adventure
+            joinMessage = io.papermc.paper.adventure.PaperAdventure.asVanilla(jm); // Paper - Adventure
+            this.server.getPlayerList().broadcastSystemMessage(joinMessage, false); // Paper - Adventure
+        }
+        // CraftBukkit end
+        // CraftBukkit start - sendAll above replaced with this loop
+        ClientboundPlayerInfoUpdatePacket packet = ClientboundPlayerInfoUpdatePacket.createPlayerInitializing(List.of(p_11263_));
+
+        final List<ServerPlayer> onlinePlayers = Lists.newArrayListWithExpectedSize(this.players.size() - 1); // Paper - Use single player info update packet on join
+        for (int i = 0; i < this.players.size(); ++i) {
+            ServerPlayer entityplayer1 = (ServerPlayer) this.players.get(i);
+            if (entityplayer1.getBukkitEntity().canSee(bukkitPlayer)) {
+                // Paper start - Add Listing API for Player
+                if (entityplayer1.getBukkitEntity().isListed(bukkitPlayer)) {
+                    // Paper end - Add Listing API for Player
+                    entityplayer1.connection.send(packet);
+                    // Paper start - Add Listing API for Player
+                } else {
+                    entityplayer1.connection.send(ClientboundPlayerInfoUpdatePacket.createSinglePlayerInitializing(p_11263_, false));
+                }
+                // Paper end - Add Listing API for Player
+            }
+            if (entityplayer1 == p_11263_ || !bukkitPlayer.canSee(entityplayer1.getBukkitEntity())) { // Paper - Use single player info update packet on join; Don't include joining player
+                continue;
+            }
+            onlinePlayers.add(entityplayer1); // Paper - Use single player info update packet on join
+        }
+        // Paper start - Use single player info update packet on join
+        if (!onlinePlayers.isEmpty()) {
+            p_11263_.connection.send(ClientboundPlayerInfoUpdatePacket.createPlayerInitializing(onlinePlayers, p_11263_)); // Paper - Add Listing API for Player
+        }
+        // Paper end - Use single player info update packet on join
+        p_11263_.sentListPacket = true;
+        p_11263_.supressTrackerForLogin = false; // Paper - Fire PlayerJoinEvent when Player is actually ready
+        ((ServerLevel)p_11263_.level()).getChunkSource().chunkMap.addEntity(p_11263_); // Paper - Fire PlayerJoinEvent when Player is actually ready; track entity now
+        // CraftBukkit end
+
+        // p_11263_.refreshEntityData(p_11263_); // CraftBukkit - BungeeCord#2321, send complete data to self on spawn
+
+        this.sendLevelInfo(p_11263_, serverlevel1);
+
+        // CraftBukkit start - Only add if the player wasn't moved in the event
+        if (p_11263_.level() == serverlevel1 && !serverlevel1.players().contains(p_11263_)) {
+            serverlevel1.addNewPlayer(p_11263_);
+            this.server.getCustomBossEvents().onPlayerConnect(p_11263_);
+        }
+        serverlevel1 = p_11263_.serverLevel(); // CraftBukkit - Update in case join event changed it
+        // CraftBukkit end
+
         this.sendActivePlayerEffects(p_11263_);
         if (optional1.isPresent() && optional1.get().contains("RootVehicle", 10)) {
             CompoundTag compoundtag = optional1.get().getCompound("RootVehicle");
+            net.minecraft.server.level.ServerLevel finalServerlevel = serverlevel1;
             Entity entity = EntityType.loadEntityRecursive(
-                compoundtag.getCompound("Entity"), serverlevel1, p_215603_ -> !serverlevel1.addWithUUID(p_215603_) ? null : p_215603_
+                compoundtag.getCompound("Entity"), serverlevel1, p_215603_ -> {
+                        p_215603_.spawnReason = org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.MOUNT; // Paper - Entity#getEntitySpawnReason
+                        return !finalServerlevel.addWithUUID(p_215603_) ? null : p_215603_;
+                    }
             );
             if (entity != null) {
                 UUID uuid;
@@ -255,16 +_,87 @@
 
                 if (!p_11263_.isPassenger()) {
                     LOGGER.warn("Couldn't reattach entity to player");
-                    entity.discard();
+                    entity.discard(null); // CraftBukkit - add Bukkit remove cause
 
                     for (Entity entity2 : entity.getIndirectPassengers()) {
-                        entity2.discard();
+                        entity2.discard(null); // CraftBukkit - add Bukkit remove cause
                     }
                 }
             }
         }
 
         p_11263_.initInventoryMenu();
+        // Paper start - Configurable player collision; Add to collideRule team if needed
+        final net.minecraft.world.scores.Scoreboard scoreboard = this.getServer().getLevel(Level.OVERWORLD).getScoreboard();
+        final PlayerTeam collideRuleTeam = scoreboard.getPlayerTeam(this.collideRuleTeamName);
+        if (this.collideRuleTeamName != null && collideRuleTeam != null && p_11263_.getTeam() == null) {
+            scoreboard.addPlayerToTeam(p_11263_.getScoreboardName(), collideRuleTeam);
+        }
+        // Paper end - Configurable player collision
+        net.neoforged.neoforge.attachment.AttachmentSync.syncInitialPlayerAttachments(p_11263_);
+        net.neoforged.neoforge.event.EventHooks.firePlayerLoggedIn( p_11263_ );
+        // CraftBukkit - Moved from above, added world
+        org.purpurmc.purpur.task.BossBarTask.addToAll(p_11263_); // Purpur
+        LOGGER.info(
+                "{}[{}] logged in with entity id {} at ({}, {}, {})",
+                p_11263_.getName().getString(),
+                s1,
+                p_11263_.getId(),
+                p_11263_.getX(),
+                p_11263_.getY(),
+                p_11263_.getZ()
+        );
+    }
+
+    private void mountSavedVehicle(ServerPlayer player, ServerLevel worldserver1, Optional<CompoundTag> optional) {
+        // Paper end - Fire PlayerJoinEvent when Player is actually ready
+        if (optional.isPresent() && ((CompoundTag) optional.get()).contains("RootVehicle", 10)) {
+            CompoundTag nbttagcompound = ((CompoundTag) optional.get()).getCompound("RootVehicle");
+            ServerLevel finalWorldServer = worldserver1; // CraftBukkit - decompile error
+            Entity entity = EntityType.loadEntityRecursive(nbttagcompound.getCompound("Entity"), worldserver1, (entity1) -> {
+                return !finalWorldServer.addWithUUID(entity1, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.MOUNT) ? null : entity1; // CraftBukkit - decompile error // Paper - Entity#getEntitySpawnReason
+            });
+
+            if (entity != null) {
+                UUID uuid;
+
+                if (nbttagcompound.hasUUID("Attach")) {
+                    uuid = nbttagcompound.getUUID("Attach");
+                } else {
+                    uuid = null;
+                }
+
+                Iterator iterator;
+                Entity entity1;
+
+                if (entity.getUUID().equals(uuid)) {
+                    player.startRiding(entity, true);
+                } else {
+                    iterator = entity.getIndirectPassengers().iterator();
+
+                    while (iterator.hasNext()) {
+                        entity1 = (Entity) iterator.next();
+                        if (entity1.getUUID().equals(uuid)) {
+                            player.startRiding(entity1, true);
+                            break;
+                        }
+                    }
+                }
+
+                if (!player.isPassenger()) {
+                    PlayerList.LOGGER.warn("Couldn't reattach entity to player");
+                    entity.discard(null); // CraftBukkit - add Bukkit remove cause
+                    iterator = entity.getIndirectPassengers().iterator();
+
+                    while (iterator.hasNext()) {
+                        entity1 = (Entity) iterator.next();
+                        entity1.discard(null); // CraftBukkit - add Bukkit remove cause
+                    }
+                }
+            }
+        }
+
+        // Paper start - Fire PlayerJoinEvent when Player is actually ready
     }
 
     public void updateEntireScoreboard(ServerScoreboard p_11274_, ServerPlayer p_11275_) {
@@ -287,6 +_,7 @@
     }
 
     public void addWorldborderListener(ServerLevel p_184210_) {
+        if (playerIo != null) return; // CraftBukkit
         p_184210_.getWorldBorder().addListener(new BorderChangeListener() {
             @Override
             public void onBorderSizeSet(WorldBorder p_11321_, double p_11322_) {
@@ -295,22 +_,22 @@
 
             @Override
             public void onBorderSizeLerping(WorldBorder p_11328_, double p_11329_, double p_11330_, long p_11331_) {
-                PlayerList.this.broadcastAll(new ClientboundSetBorderLerpSizePacket(p_11328_));
+                PlayerList.this.broadcastAll(new ClientboundSetBorderLerpSizePacket(p_11328_), p_11328_.world); // CraftBukkit
             }
 
             @Override
             public void onBorderCenterSet(WorldBorder p_11324_, double p_11325_, double p_11326_) {
-                PlayerList.this.broadcastAll(new ClientboundSetBorderCenterPacket(p_11324_));
+                PlayerList.this.broadcastAll(new ClientboundSetBorderCenterPacket(p_11324_), p_11324_.world); // CraftBukkit
             }
 
             @Override
             public void onBorderSetWarningTime(WorldBorder p_11333_, int p_11334_) {
-                PlayerList.this.broadcastAll(new ClientboundSetBorderWarningDelayPacket(p_11333_));
+                PlayerList.this.broadcastAll(new ClientboundSetBorderWarningDelayPacket(p_11333_), p_11333_.world); // CraftBukkit
             }
 
             @Override
             public void onBorderSetWarningBlocks(WorldBorder p_11339_, int p_11340_) {
-                PlayerList.this.broadcastAll(new ClientboundSetBorderWarningDistancePacket(p_11339_));
+                PlayerList.this.broadcastAll(new ClientboundSetBorderWarningDistancePacket(p_11339_), p_11339_.world); // CraftBukkit
             }
 
             @Override
@@ -330,6 +_,7 @@
             optional = Optional.of(compoundtag);
             p_11225_.load(compoundtag);
             LOGGER.debug("loading single player");
+            net.neoforged.neoforge.event.EventHooks.firePlayerLoadingEvent(p_11225_, this.playerIo, p_11225_.getUUID().toString());
         } else {
             optional = this.playerIo.load(p_11225_);
         }
@@ -338,6 +_,9 @@
     }
 
     protected void save(ServerPlayer p_11277_) {
+        if (!p_11277_.getBukkitEntity().isPersistent()) return; // CraftBukkit
+        if (p_11277_.connection == null) return;
+        p_11277_.lastSave = MinecraftServer.currentTick; // Paper - Incremental chunk and player saving
         this.playerIo.save(p_11277_);
         ServerStatsCounter serverstatscounter = this.stats.get(p_11277_.getUUID());
         if (serverstatscounter != null) {
@@ -350,23 +_,74 @@
         }
     }
 
+    public net.kyori.adventure.text.Component quitMessage;
+    public net.kyori.adventure.text.Component remove$leaveMessage;
     public void remove(ServerPlayer p_11287_) {
+        org.purpurmc.purpur.task.BossBarTask.removeFromAll(p_11287_.getBukkitEntity()); // Purpur
+        net.neoforged.neoforge.event.EventHooks.firePlayerLoggedOut(p_11287_);
         ServerLevel serverlevel = p_11287_.serverLevel();
         p_11287_.awardStat(Stats.LEAVE_GAME);
+
+        // CraftBukkit start - Quitting must be before we do final save of data, in case plugins need to modify it
+        // See SPIGOT-5799, SPIGOT-6145
+        if (p_11287_.containerMenu != p_11287_.inventoryMenu) {
+            InventoryOwner.setClose$Reason(org.bukkit.event.inventory.InventoryCloseEvent.Reason.DISCONNECT); // Paper - Inventory close reason
+            p_11287_.closeContainer();
+        }
+        if (remove$leaveMessage == null) {
+            remove$leaveMessage = net.kyori.adventure.text.Component.translatable("multiplayer.player.left", net.kyori.adventure.text.format.NamedTextColor.YELLOW, io.papermc.paper.configuration.GlobalConfiguration.get().messages.useDisplayNameInQuitMessage ? p_11287_.getBukkitEntity().displayName() : io.papermc.paper.adventure.PaperAdventure.asAdventure(p_11287_.getDisplayName()));
+        }
+        PlayerQuitEvent playerQuitEvent = new PlayerQuitEvent(p_11287_.getBukkitEntity(), remove$leaveMessage, p_11287_.quitReason); // Paper - Adventure & Add API for quit reason
+        remove$leaveMessage = null; // Youer
+        cserver.getPluginManager().callEvent(playerQuitEvent);
+        p_11287_.getBukkitEntity().disconnect(playerQuitEvent.getQuitMessage());
+        if (server.isSameThread()) p_11287_.doTick(); // SPIGOT-924
+        // CraftBukkit end
+
+        // Paper start - Configurable player collision; Remove from collideRule team if needed
+        if (this.collideRuleTeamName != null) {
+            final net.minecraft.world.scores.Scoreboard scoreBoard = this.server.getLevel(Level.OVERWORLD).getScoreboard();
+            final PlayerTeam team = scoreBoard.getPlayersTeam(this.collideRuleTeamName);
+            if (p_11287_.getTeam() == team && team != null) {
+                scoreBoard.removePlayerFromTeam(p_11287_.getScoreboardName(), team);
+            }
+        }
+        // Paper end - Configurable player collision
+
+        // Paper - Drop carried item when player has disconnected
+        if (!p_11287_.containerMenu.getCarried().isEmpty()) {
+            net.minecraft.world.item.ItemStack carried = p_11287_.containerMenu.getCarried();
+            p_11287_.containerMenu.setCarried(net.minecraft.world.item.ItemStack.EMPTY);
+            p_11287_.drop(carried, false);
+        }
+        // Paper end - Drop carried item when player has disconnected
+
         this.save(p_11287_);
         if (p_11287_.isPassenger()) {
             Entity entity = p_11287_.getRootVehicle();
             if (entity.hasExactlyOnePlayerPassenger()) {
                 LOGGER.debug("Removing player mount");
                 p_11287_.stopRiding();
-                entity.getPassengersAndSelf().forEach(p_215620_ -> p_215620_.setRemoved(Entity.RemovalReason.UNLOADED_WITH_PLAYER));
+                entity.getPassengersAndSelf().forEach(p_215620_ -> {
+                    // Paper start - Fix villager boat exploit
+                    if (p_215620_ instanceof net.minecraft.world.entity.npc.AbstractVillager villager) {
+                        final net.minecraft.world.entity.player.Player human = villager.getTradingPlayer();
+                        if (human != null) {
+                            villager.setTradingPlayer(null);
+                        }
+                    }
+                    // Paper end - Fix villager boat exploit
+                    p_215620_.setRemovedCB(Entity.RemovalReason.UNLOADED_WITH_PLAYER, org.bukkit.event.entity.EntityRemoveEvent.Cause.PLAYER_QUIT);
+                });
             }
         }
 
         p_11287_.unRide();
         serverlevel.removePlayerImmediately(p_11287_, Entity.RemovalReason.UNLOADED_WITH_PLAYER);
+        p_11287_.retireScheduler(); // Paper - Folia schedulers
         p_11287_.getAdvancements().stopListening();
         this.players.remove(p_11287_);
+        this.playersByName.remove(p_11287_.getScoreboardName().toLowerCase(java.util.Locale.ROOT)); // Spigot
         this.server.getCustomBossEvents().onPlayerDisconnect(p_11287_);
         UUID uuid = p_11287_.getUUID();
         ServerPlayer serverplayer = this.playersByUUID.get(uuid);
@@ -376,13 +_,70 @@
             this.advancements.remove(uuid);
         }
 
-        this.broadcastAll(new ClientboundPlayerInfoRemovePacket(List.of(p_11287_.getUUID())));
-    }
-
-    @Nullable
+        // CraftBukkit start
+        // this.broadcastAll(new ClientboundPlayerInfoRemovePacket(List.of(p_11287_.getUUID())));
+        ClientboundPlayerInfoRemovePacket packet = new ClientboundPlayerInfoRemovePacket(List.of(p_11287_.getUUID()));
+        for (int i = 0; i < players.size(); i++) {
+            ServerPlayer entityplayer2 = (ServerPlayer) this.players.get(i);
+            if (entityplayer2.getBukkitEntity().canSee(p_11287_.getBukkitEntity())) {
+                entityplayer2.connection.send(packet);
+            } else {
+                entityplayer2.getBukkitEntity().onEntityRemove(p_11287_);
+            }
+        }
+        // This removes the scoreboard (and player reference) for the specific player in the manager
+        cserver.getScoreboardManager().removePlayer(p_11287_.getBukkitEntity());
+        // CraftBukkit end
+
+        quitMessage = playerQuitEvent.quitMessage();
+    }
+
+    // Mohist start
+    public final AtomicReference<ServerPlayer> youer$canPlayerLogin$entity = new AtomicReference<>(null);
+    private final AtomicReference<ServerLoginPacketListenerImpl> handler = new AtomicReference<>(null);
+
+    public void youer$putHandler(ServerLoginPacketListenerImpl handler) {
+        this.handler.set(handler);
+    }
+    // CraftBukkit start - Whole method, SocketAddress to LoginListener, added hostname to signature, return EntityPlayer
     public Component canPlayerLogin(SocketAddress p_11257_, GameProfile p_11258_) {
-        if (this.bans.isBanned(p_11258_)) {
-            UserBanListEntry userbanlistentry = this.bans.get(p_11258_);
+        // Moved from processLogin
+        UUID uuid = p_11258_.getId();
+        List<ServerPlayer> list = Lists.newArrayList();
+
+        ServerPlayer entityplayer;
+
+        for (int i = 0; i < this.players.size(); ++i) {
+            entityplayer = (ServerPlayer) this.players.get(i);
+            if (entityplayer.getUUID().equals(uuid)) {
+                list.add(entityplayer);
+            }
+        }
+
+        java.util.Iterator iterator = list.iterator();
+
+        while (iterator.hasNext()) {
+            entityplayer = (ServerPlayer) iterator.next();
+            save(entityplayer); // CraftBukkit - Force the player's inventory to be saved
+            entityplayer.connection.disconnect(Component.translatable("multiplayer.disconnect.duplicate_login"), org.bukkit.event.player.PlayerKickEvent.Cause.DUPLICATE_LOGIN); // Paper - kick event cause
+        }
+        // Instead of kicking then returning, we need to store the kick reason
+        // in the event, check with plugins to see if it's ok, and THEN kick
+        // depending on the outcome.
+        ServerPlayer entity = new ServerPlayer(this.server, this.server.getLevel(Level.OVERWORLD), p_11258_, ClientInformation.createDefault());
+        youer$canPlayerLogin$entity.set(entity);
+
+        ServerLoginPacketListenerImpl handleR = handler.getAndSet(null);
+        String hostname = handleR == null ? "" : handleR.connection.hostname;
+        InetAddress realAddress = handleR == null ? ((InetSocketAddress) p_11257_).getAddress() : ((InetSocketAddress) handleR.connection.channel.remoteAddress()).getAddress();
+
+        entity.transferCookieConnection = handleR;
+        org.bukkit.entity.Player player = entity.getBukkitEntity();
+        org.bukkit.event.player.PlayerLoginEvent event = new org.bukkit.event.player.PlayerLoginEvent(player, hostname, ((java.net.InetSocketAddress) p_11257_).getAddress(), realAddress);
+
+        // Paper start - Fix MC-158900
+        UserBanListEntry userbanlistentry;
+        if (this.bans.isBanned(p_11258_) && (userbanlistentry = this.bans.get(p_11258_)) != null) {
             MutableComponent mutablecomponent1 = Component.translatable("multiplayer.disconnect.banned.reason", userbanlistentry.getReason());
             if (userbanlistentry.getExpires() != null) {
                 mutablecomponent1.append(
@@ -390,10 +_,11 @@
                 );
             }
 
-            return mutablecomponent1;
-        } else if (!this.isWhiteListed(p_11258_)) {
-            return Component.translatable("multiplayer.disconnect.not_whitelisted");
-        } else if (this.ipBans.isBanned(p_11257_)) {
+            event.disallow(org.bukkit.event.player.PlayerLoginEvent.Result.KICK_BANNED, io.papermc.paper.adventure.PaperAdventure.asAdventure(mutablecomponent1)); // Paper - Adventure
+        } else if (!this.isWhiteListed(p_11258_, event)) { // Paper - ProfileWhitelistVerifyEvent
+            //MutableComponent ichatmutablecomponent = Component.translatable("multiplayer.disconnect.not_whitelisted");
+            //event.disallow(PlayerLoginEvent.Result.KICK_WHITELIST, net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().deserialize(org.spigotmc.SpigotConfig.whitelistMessage)); // Spigot // Paper - Adventure
+        } else if (this.getIpBans().isBanned(p_11257_) && !this.getIpBans().get(p_11257_).hasExpired()) {
             IpBanListEntry ipbanlistentry = this.ipBans.get(p_11257_);
             MutableComponent mutablecomponent = Component.translatable("multiplayer.disconnect.banned_ip.reason", ipbanlistentry.getReason());
             if (ipbanlistentry.getExpires() != null) {
@@ -402,19 +_,30 @@
                 );
             }
 
-            return mutablecomponent;
+            event.disallow(org.bukkit.event.player.PlayerLoginEvent.Result.KICK_BANNED, io.papermc.paper.adventure.PaperAdventure.asAdventure(mutablecomponent)); // Paper - Adventure
         } else {
-            return this.players.size() >= this.maxPlayers && !this.canBypassPlayerLimit(p_11258_)
-                ? Component.translatable("multiplayer.disconnect.server_full")
-                : null;
-        }
-    }
-
-    public ServerPlayer getPlayerForLogin(GameProfile p_215625_, ClientInformation p_302018_) {
-        return new ServerPlayer(this.server, this.server.overworld(), p_215625_, p_302018_);
-    }
-
-    public boolean disconnectAllPlayersWithProfile(GameProfile p_295670_) {
+            if (this.players.size() >= this.maxPlayers && !this.canBypassPlayerLimit(p_11258_)) {
+                event.disallow(org.bukkit.event.player.PlayerLoginEvent.Result.KICK_FULL, ColorAPI.colorize(org.spigotmc.SpigotConfig.serverFullMessage)); // Spigot // Paper - Adventure
+            }
+        }
+
+        cserver.getPluginManager().callEvent(event);
+        if (event.getResult() != org.bukkit.event.player.PlayerLoginEvent.Result.ALLOWED) {
+            youer$canPlayerLogin$entity.set(null);
+            return io.papermc.paper.adventure.PaperAdventure.asVanilla(event.kickMessage());
+        }
+        return null;
+    }
+
+    // CraftBukkit start - added ServerPlayer
+    public ServerPlayer getPlayerForLogin(GameProfile p_215625_, ClientInformation p_302018_, ServerPlayer player) {
+        player.updateOptions(p_302018_);
+        return player;
+        // CraftBukkit end
+    }
+
+    public boolean disconnectAllPlayersWithProfile(GameProfile p_295670_, ServerPlayer player) { // CraftBukkit - added EntityPlayer
+      /* CraftBukkit startMoved up
         UUID uuid = p_295670_.getId();
         Set<ServerPlayer> set = Sets.newIdentityHashSet();
 
@@ -434,72 +_,272 @@
         }
 
         return !set.isEmpty();
+        */
+        return player == null;
+        // CraftBukkit end
     }
 
+    // CraftBukkit start
+    org.bukkit.event.player.PlayerRespawnEvent.RespawnReason reason = null;
+    org.bukkit.Location location = null;
     public ServerPlayer respawn(ServerPlayer p_11237_, boolean p_11238_, Entity.RemovalReason p_348558_) {
+        p_11237_.stopRiding();
         this.players.remove(p_11237_);
+        this.playersByName.remove(p_11237_.getScoreboardName().toLowerCase(java.util.Locale.ROOT)); // Spigot
         p_11237_.serverLevel().removePlayerImmediately(p_11237_, p_348558_);
-        DimensionTransition dimensiontransition = p_11237_.findRespawnPositionAndUseSpawnBlock(p_11238_, DimensionTransition.DO_NOTHING);
+        p_11237_.reason = reason;
+        DimensionTransition dimensiontransition;
+        if (location == null) {
+            dimensiontransition = p_11237_.findRespawnPositionAndUseSpawnBlock(p_11238_, DimensionTransition.DO_NOTHING, reason);
+
+            if (!p_11238_) p_11237_.reset(); // SPIGOT-4785
+        } else {
+            dimensiontransition = new DimensionTransition(((CraftWorld) location.getWorld()).getHandle(), CraftLocation.toVec3D(location), Vec3.ZERO, location.getYaw(), location.getPitch(), DimensionTransition.DO_NOTHING);
+        }
+        // Neo: Allow changing the respawn position of players. The local dimension transition is updated with the new target.
+        var event = net.neoforged.neoforge.event.EventHooks.firePlayerRespawnPositionEvent(p_11237_, dimensiontransition, p_11238_);
+        dimensiontransition = event.getDimensionTransition();
+
         ServerLevel serverlevel = dimensiontransition.newLevel();
         ServerPlayer serverplayer = new ServerPlayer(this.server, serverlevel, p_11237_.getGameProfile(), p_11237_.clientInformation());
+        serverplayer.wonGame = false;
         serverplayer.connection = p_11237_.connection;
         serverplayer.restoreFrom(p_11237_, p_11238_);
         serverplayer.setId(p_11237_.getId());
         serverplayer.setMainArm(p_11237_.getMainArm());
-        if (!dimensiontransition.missingRespawnBlock()) {
+
+        // Neo: Allow the event to control if the original spawn position is copied
+        if (event.copyOriginalSpawnPosition()) {
             serverplayer.copyRespawnPosition(p_11237_);
         }
 
         for (String s : p_11237_.getTags()) {
             serverplayer.addTag(s);
         }
+        serverplayer.spawnIn(serverlevel);
+        serverplayer.unsetRemoved();;
+        serverplayer.setShiftKeyDown(false);
 
         Vec3 vec3 = dimensiontransition.pos();
-        serverplayer.moveTo(vec3.x, vec3.y, vec3.z, dimensiontransition.yRot(), dimensiontransition.xRot());
+        serverplayer.forceSetPositionRotation(vec3.x, vec3.y, vec3.z, dimensiontransition.yRot(), dimensiontransition.xRot());
+        serverlevel.getChunkSource().addRegionTicket(net.minecraft.server.level.TicketType.POST_TELEPORT, new net.minecraft.world.level.ChunkPos(net.minecraft.util.Mth.floor(vec3.x()) >> 4, net.minecraft.util.Mth.floor(vec3.z()) >> 4), 1, p_11237_.getId()); // Paper
         if (dimensiontransition.missingRespawnBlock()) {
             serverplayer.connection.send(new ClientboundGameEventPacket(ClientboundGameEventPacket.NO_RESPAWN_BLOCK_AVAILABLE, 0.0F));
+            serverplayer.setRespawnPosition$setSpawnCause(PlayerSetSpawnEvent.Cause.PLAYER_RESPAWN);
+            serverplayer.setRespawnPosition(null, null, 0f, false, false); // CraftBukkit - SPIGOT-5988: Clear respawn location when obstructed // Paper - PlayerSetSpawnEvent
         }
 
         byte b0 = (byte)(p_11238_ ? 1 : 0);
         ServerLevel serverlevel1 = serverplayer.serverLevel();
         LevelData leveldata = serverlevel1.getLevelData();
         serverplayer.connection.send(new ClientboundRespawnPacket(serverplayer.createCommonSpawnInfo(serverlevel1), b0));
-        serverplayer.connection.teleport(serverplayer.getX(), serverplayer.getY(), serverplayer.getZ(), serverplayer.getYRot(), serverplayer.getXRot());
+        serverplayer.connection.send(new ClientboundSetChunkCacheRadiusPacket(serverlevel1.spigotConfig.viewDistance)); // Spigot
+        serverplayer.connection.send(new ClientboundSetSimulationDistancePacket(serverlevel1.spigotConfig.simulationDistance)); // Spigot
+        serverplayer.connection.teleport(CraftLocation.toBukkit(serverplayer.position(), serverlevel1.getWorld(), serverplayer.getYRot(), serverplayer.getXRot())); // CraftBukkit
         serverplayer.connection.send(new ClientboundSetDefaultSpawnPositionPacket(serverlevel.getSharedSpawnPos(), serverlevel.getSharedSpawnAngle()));
         serverplayer.connection.send(new ClientboundChangeDifficultyPacket(leveldata.getDifficulty(), leveldata.isDifficultyLocked()));
         serverplayer.connection
-            .send(new ClientboundSetExperiencePacket(serverplayer.experienceProgress, serverplayer.totalExperience, serverplayer.experienceLevel));
+                .send(new ClientboundSetExperiencePacket(serverplayer.experienceProgress, serverplayer.totalExperience, serverplayer.experienceLevel));
         this.sendActivePlayerEffects(serverplayer);
         this.sendLevelInfo(serverplayer, serverlevel);
         this.sendPlayerPermissionLevel(serverplayer);
-        serverlevel.addRespawnedPlayer(serverplayer);
-        this.players.add(serverplayer);
-        this.playersByUUID.put(serverplayer.getUUID(), serverplayer);
+        if (!p_11237_.connection.isDisconnected()) {
+            serverlevel.addRespawnedPlayer(serverplayer);
+            this.players.add(serverplayer);
+            this.playersByName.put(serverplayer.getScoreboardName().toLowerCase(java.util.Locale.ROOT), serverplayer); // Spigot
+            this.playersByUUID.put(serverplayer.getUUID(), serverplayer);
+        }
         serverplayer.initInventoryMenu();
         serverplayer.setHealth(serverplayer.getHealth());
+        net.neoforged.neoforge.attachment.AttachmentSync.syncInitialPlayerAttachments(serverplayer);
+        net.neoforged.neoforge.event.EventHooks.firePlayerRespawnEvent(serverplayer, p_11238_);
         if (!p_11238_) {
             BlockPos blockpos = BlockPos.containing(dimensiontransition.pos());
             BlockState blockstate = serverlevel.getBlockState(blockpos);
             if (blockstate.is(Blocks.RESPAWN_ANCHOR)) {
                 serverplayer.connection
-                    .send(
-                        new ClientboundSoundPacket(
-                            SoundEvents.RESPAWN_ANCHOR_DEPLETE,
-                            SoundSource.BLOCKS,
-                            (double)blockpos.getX(),
-                            (double)blockpos.getY(),
-                            (double)blockpos.getZ(),
-                            1.0F,
-                            1.0F,
-                            serverlevel.getRandom().nextLong()
-                        )
-                    );
+                        .send(
+                                new ClientboundSoundPacket(
+                                        SoundEvents.RESPAWN_ANCHOR_DEPLETE,
+                                        SoundSource.BLOCKS,
+                                        (double)blockpos.getX(),
+                                        (double)blockpos.getY(),
+                                        (double)blockpos.getZ(),
+                                        1.0F,
+                                        1.0F,
+                                        serverlevel.getRandom().nextLong()
+                                )
+                        );
             }
         }
-
+        // Added from changeDimension
+        this.sendAllPlayerInfo(serverplayer); // Update health, etc...
+        serverplayer.onUpdateAbilities();
+        for (MobEffectInstance mobEffect : serverplayer.getActiveEffects()) {
+            serverplayer.connection.send(new ClientboundUpdateMobEffectPacket(serverplayer.getId(), mobEffect, false)); // blend = false
+        }
+
+        // Fire advancement trigger
+        serverplayer.triggerDimensionChangeTriggers(serverlevel);
+        Level fromWorld = p_11237_.level();
+        // Don't fire on respawn
+        if (fromWorld != serverlevel) {
+            PlayerChangedWorldEvent eventCWE = new PlayerChangedWorldEvent(p_11237_.getBukkitEntity(), fromWorld.getWorld());
+            this.server.server.getPluginManager().callEvent(eventCWE);
+        }
+
+        // Save player file again if they were disconnected
+        if (serverplayer.connection.isDisconnected()) {
+            this.save(serverplayer);
+        }
+        reason = null;
+        location = null;
         return serverplayer;
     }
 
+    public ServerPlayer respawn(ServerPlayer entityplayer, boolean flag, Entity.RemovalReason entity_removalreason, PlayerRespawnEvent.RespawnReason reason) {
+        return this.respawn(entityplayer, flag, entity_removalreason, reason, null);
+    }
+
+    public ServerPlayer respawn(ServerPlayer entityplayer, boolean flag, Entity.RemovalReason entity_removalreason, PlayerRespawnEvent.RespawnReason reason, Location location) {
+        entityplayer.stopRiding(); // CraftBukkit
+        this.players.remove(entityplayer);
+        this.playersByName.remove(entityplayer.getScoreboardName().toLowerCase(java.util.Locale.ROOT)); // Spigot
+        entityplayer.serverLevel().removePlayerImmediately(entityplayer, entity_removalreason);
+        /* CraftBukkit start
+        DimensionTransition dimensiontransition = entityplayer.findRespawnPositionAndUseSpawnBlock(flag, DimensionTransition.DO_NOTHING);
+        WorldServer worldserver = dimensiontransition.newLevel();
+        EntityPlayer entityplayer1 = new EntityPlayer(this.server, worldserver, entityplayer.getGameProfile(), entityplayer.clientInformation());
+        // */
+        ServerPlayer entityplayer1 = entityplayer;
+        Level fromWorld = entityplayer.level();
+        entityplayer.wonGame = false;
+        // CraftBukkit end
+
+        entityplayer1.connection = entityplayer.connection;
+        entityplayer1.restoreFrom(entityplayer, flag);
+        entityplayer1.setId(entityplayer.getId());
+        entityplayer1.setMainArm(entityplayer.getMainArm());
+        // CraftBukkit - not required, just copies old location into reused entity
+        /*
+        if (!dimensiontransition.missingRespawnBlock()) {
+            entityplayer1.copyRespawnPosition(entityplayer);
+        }
+         */
+        // CraftBukkit end
+
+        Iterator iterator = entityplayer.getTags().iterator();
+
+        while (iterator.hasNext()) {
+            String s = (String) iterator.next();
+
+            entityplayer1.addTag(s);
+        }
+        // Paper start - Add PlayerPostRespawnEvent
+        boolean isBedSpawn = false;
+        boolean isRespawn = false;
+        // Paper end - Add PlayerPostRespawnEvent
+
+        // CraftBukkit start - fire PlayerRespawnEvent
+        DimensionTransition dimensiontransition;
+        if (location == null) {
+            dimensiontransition = entityplayer.findRespawnPositionAndUseSpawnBlock(flag, DimensionTransition.DO_NOTHING, reason);
+
+            if (!flag) entityplayer.reset(); // SPIGOT-4785
+            // Paper start - Add PlayerPostRespawnEvent
+            if (dimensiontransition == null) return entityplayer; // Early exit, mirrors belows early return for disconnected players in respawn event
+            isRespawn = true;
+            location = CraftLocation.toBukkit(dimensiontransition.pos(), dimensiontransition.newLevel().getWorld(), dimensiontransition.yRot(), dimensiontransition.xRot());
+            // Paper end - Add PlayerPostRespawnEvent
+        } else {
+            dimensiontransition = new DimensionTransition(((CraftWorld) location.getWorld()).getHandle(), CraftLocation.toVec3D(location), Vec3.ZERO, location.getYaw(), location.getPitch(), DimensionTransition.DO_NOTHING);
+        }
+        // Spigot Start
+        if (dimensiontransition == null) { // Paper - Add PlayerPostRespawnEvent - diff on change - spigot early returns if respawn pos is null, that is how they handle disconnected player in respawn event
+            return entityplayer;
+        }
+        // Spigot End
+        ServerLevel worldserver = dimensiontransition.newLevel();
+        entityplayer1.spawnIn(worldserver);
+        entityplayer1.unsetRemoved();
+        entityplayer1.setShiftKeyDown(false);
+        Vec3 vec3d = dimensiontransition.pos();
+
+        entityplayer1.forceSetPositionRotation(vec3d.x, vec3d.y, vec3d.z, dimensiontransition.yRot(), dimensiontransition.xRot());
+        worldserver.getChunkSource().addRegionTicket(net.minecraft.server.level.TicketType.POST_TELEPORT, new net.minecraft.world.level.ChunkPos(net.minecraft.util.Mth.floor(vec3d.x()) >> 4, net.minecraft.util.Mth.floor(vec3d.z()) >> 4), 1, entityplayer.getId()); // Paper
+        // CraftBukkit end
+        if (dimensiontransition.missingRespawnBlock()) {
+            entityplayer1.connection.send(new ClientboundGameEventPacket(ClientboundGameEventPacket.NO_RESPAWN_BLOCK_AVAILABLE, 0.0F));
+            entityplayer1.setRespawnPosition(null, null, 0f, false, false, com.destroystokyo.paper.event.player.PlayerSetSpawnEvent.Cause.PLAYER_RESPAWN); // CraftBukkit - SPIGOT-5988: Clear respawn location when obstructed // Paper - PlayerSetSpawnEvent
+        }
+
+        int i = flag ? 1 : 0;
+        ServerLevel worldserver1 = entityplayer1.serverLevel();
+        LevelData worlddata = worldserver1.getLevelData();
+
+        entityplayer1.connection.send(new ClientboundRespawnPacket(entityplayer1.createCommonSpawnInfo(worldserver1), (byte) i));
+        entityplayer1.connection.send(new ClientboundSetChunkCacheRadiusPacket(worldserver1.spigotConfig.viewDistance)); // Spigot
+        entityplayer1.connection.send(new ClientboundSetSimulationDistancePacket(worldserver1.spigotConfig.simulationDistance)); // Spigot
+        entityplayer1.connection.teleport(CraftLocation.toBukkit(entityplayer1.position(), worldserver1.getWorld(), entityplayer1.getYRot(), entityplayer1.getXRot())); // CraftBukkit
+        entityplayer1.connection.send(new ClientboundSetDefaultSpawnPositionPacket(worldserver.getSharedSpawnPos(), worldserver.getSharedSpawnAngle()));
+        entityplayer1.connection.send(new ClientboundChangeDifficultyPacket(worlddata.getDifficulty(), worlddata.isDifficultyLocked()));
+        entityplayer1.connection.send(new ClientboundSetExperiencePacket(entityplayer1.experienceProgress, entityplayer1.totalExperience, entityplayer1.experienceLevel));
+        this.sendActivePlayerEffects(entityplayer1);
+        this.sendLevelInfo(entityplayer1, worldserver);
+        this.sendPlayerPermissionLevel(entityplayer1);
+        if (!entityplayer.connection.isDisconnected()) {
+            worldserver.addRespawnedPlayer(entityplayer1);
+            this.players.add(entityplayer1);
+            this.playersByName.put(entityplayer1.getScoreboardName().toLowerCase(java.util.Locale.ROOT), entityplayer1); // Spigot
+            this.playersByUUID.put(entityplayer1.getUUID(), entityplayer1);
+        }
+        // entityplayer1.initInventoryMenu();
+        entityplayer1.setHealth(entityplayer1.getHealth());
+        if (!flag) {
+            BlockPos blockposition = BlockPos.containing(dimensiontransition.pos());
+            BlockState iblockdata = worldserver.getBlockState(blockposition);
+
+            if (iblockdata.is(Blocks.RESPAWN_ANCHOR)) {
+                entityplayer1.connection.send(new ClientboundSoundPacket(SoundEvents.RESPAWN_ANCHOR_DEPLETE, SoundSource.BLOCKS, (double) blockposition.getX(), (double) blockposition.getY(), (double) blockposition.getZ(), 1.0F, 1.0F, worldserver.getRandom().nextLong()));
+            }
+            // Paper start - Add PlayerPostRespawnEvent
+            if (iblockdata.is(net.minecraft.tags.BlockTags.BEDS) && !dimensiontransition.missingRespawnBlock()) {
+                isBedSpawn = true;
+            }
+            // Paper end - Add PlayerPostRespawnEvent
+        }
+        // Added from changeDimension
+        this.sendAllPlayerInfo(entityplayer); // Update health, etc...
+        entityplayer.onUpdateAbilities();
+        for (MobEffectInstance mobEffect : entityplayer.getActiveEffects()) {
+            entityplayer.connection.send(new ClientboundUpdateMobEffectPacket(entityplayer.getId(), mobEffect, false)); // blend = false
+        }
+
+        // Fire advancement trigger
+        entityplayer.triggerDimensionChangeTriggers(worldserver);
+
+        // Don't fire on respawn
+        if (fromWorld != worldserver) {
+            PlayerChangedWorldEvent event = new PlayerChangedWorldEvent(entityplayer.getBukkitEntity(), fromWorld.getWorld());
+            this.server.server.getPluginManager().callEvent(event);
+        }
+
+        // Save player file again if they were disconnected
+        if (entityplayer.connection.isDisconnected()) {
+            this.save(entityplayer);
+        }
+
+        // Paper start - Add PlayerPostRespawnEvent
+        if (isRespawn) {
+            cserver.getPluginManager().callEvent(new com.destroystokyo.paper.event.player.PlayerPostRespawnEvent(entityplayer.getBukkitEntity(), location, isBedSpawn));
+        }
+        // Paper end - Add PlayerPostRespawnEvent
+
+        // CraftBukkit end
+
+        return entityplayer1;
+    }
+
     public void sendActivePlayerEffects(ServerPlayer p_348494_) {
         this.sendActiveEffects(p_348494_, p_348494_.connection);
     }
@@ -510,15 +_,45 @@
         }
     }
 
+    public void sendActiveEffects(LivingEntity entity, java.util.function.Consumer<Packet<? super net.minecraft.network.protocol.game.ClientGamePacketListener>> packetConsumer) {
+        // Paper end - collect packets
+        Iterator iterator = entity.getActiveEffects().iterator();
+
+        while (iterator.hasNext()) {
+            MobEffectInstance mobeffect = (MobEffectInstance) iterator.next();
+
+            packetConsumer.accept(new ClientboundUpdateMobEffectPacket(entity.getId(), mobeffect, false)); // Paper - collect packets
+        }
+
+    }
+
     public void sendPlayerPermissionLevel(ServerPlayer p_11290_) {
         GameProfile gameprofile = p_11290_.getGameProfile();
         int i = this.server.getProfilePermissions(gameprofile);
         this.sendPlayerPermissionLevel(p_11290_, i);
     }
 
+    public void sendPlayerPermissionLevel(ServerPlayer player, boolean recalculatePermissions) {
+        // Paper end - avoid recalculating permissions if possible
+        GameProfile gameprofile = player.getGameProfile();
+        int i = this.server.getProfilePermissions(gameprofile);
+
+        this.sendPlayerPermissionLevel(player, i, recalculatePermissions); // Paper - avoid recalculating permissions if possible
+    }
+
     public void tick() {
         if (++this.sendAllPlayerInfoIn > 600) {
-            this.broadcastAll(new ClientboundPlayerInfoUpdatePacket(EnumSet.of(ClientboundPlayerInfoUpdatePacket.Action.UPDATE_LATENCY), this.players));
+            // CraftBukkit start
+            for (int i = 0; i < this.players.size(); ++i) {
+                final ServerPlayer target = (ServerPlayer) this.players.get(i);
+                target.connection.send(new ClientboundPlayerInfoUpdatePacket(EnumSet.of(ClientboundPlayerInfoUpdatePacket.Action.UPDATE_LATENCY), this.players.stream().filter(new Predicate<ServerPlayer>() {
+                    @Override
+                    public boolean test(ServerPlayer input) {
+                        return target.getBukkitEntity().canSee(input.getBukkitEntity());
+                    }
+                }).collect(java.util.stream.Collectors.toList())));
+            }
+            // CraftBukkit end
             this.sendAllPlayerInfoIn = 0;
         }
     }
@@ -529,6 +_,38 @@
         }
     }
 
+    // CraftBukkit start - add a world/entity limited version
+    public void broadcastAll(Packet packet, Player entityhuman) {
+        for (int i = 0; i < this.players.size(); ++i) {
+            ServerPlayer entityplayer =  this.players.get(i);
+            if (entityhuman != null && !entityplayer.getBukkitEntity().canSee(entityhuman.getBukkitEntity())) {
+                continue;
+            }
+            ((ServerPlayer) this.players.get(i)).connection.send(packet);
+        }
+    }
+
+    public void broadcastAll(Packet packet, Level world) {
+        for (int i = 0; i < world.players().size(); ++i) {
+            ((ServerPlayer) world.players().get(i)).connection.send(packet);
+        }
+    }
+    // CraftBukkit end
+
+    // Purpur Start
+    public void broadcastMiniMessage(@Nullable String message, boolean overlay) {
+        if (message != null && !message.isEmpty()) {
+            this.broadcastMessage(net.kyori.adventure.text.minimessage.MiniMessage.miniMessage().deserialize(message), overlay);
+        }
+    }
+
+    public void broadcastMessage(@Nullable net.kyori.adventure.text.Component message, boolean overlay) {
+        if (message != null) {
+            this.broadcastSystemMessage(io.papermc.paper.adventure.PaperAdventure.asVanilla(message), overlay);
+        }
+    }
+    // Purpur end
+
     public void broadcastAll(Packet<?> p_11271_, ResourceKey<Level> p_11272_) {
         for (ServerPlayer serverplayer : this.players) {
             if (serverplayer.level().dimension() == p_11272_) {
@@ -582,6 +_,7 @@
     }
 
     public void op(GameProfile p_11254_) {
+        if (net.neoforged.neoforge.event.EventHooks.onPermissionChanged(p_11254_, this.server.getOperatorUserPermissionLevel(), this)) return;
         this.ops.add(new ServerOpListEntry(p_11254_, this.server.getOperatorUserPermissionLevel(), this.ops.canBypassPlayerLimit(p_11254_)));
         ServerPlayer serverplayer = this.getPlayer(p_11254_.getId());
         if (serverplayer != null) {
@@ -590,6 +_,7 @@
     }
 
     public void deop(GameProfile p_11281_) {
+        if (net.neoforged.neoforge.event.EventHooks.onPermissionChanged(p_11281_, 0, this)) return;
         this.ops.remove(p_11281_);
         ServerPlayer serverplayer = this.getPlayer(p_11281_.getId());
         if (serverplayer != null) {
@@ -598,6 +_,11 @@
     }
 
     private void sendPlayerPermissionLevel(ServerPlayer p_11227_, int p_11228_) {
+        // Paper start - Add sendOpLevel API
+        this.sendPlayerPermissionLevel(p_11227_, p_11228_, true);
+    }
+    public void sendPlayerPermissionLevel(ServerPlayer p_11227_, int p_11228_, boolean recalculatePermissions) {
+        // Paper end - Add sendOpLevel API
         if (p_11227_.connection != null) {
             byte b0;
             if (p_11228_ <= 0) {
@@ -611,11 +_,32 @@
             p_11227_.connection.send(new ClientboundEntityEventPacket(p_11227_, b0));
         }
 
-        this.server.getCommands().sendCommands(p_11227_);
+        if (recalculatePermissions) { // Paper - Add sendOpLevel API
+            p_11227_.getBukkitEntity().recalculatePermissions(); // CraftBukkit
+            this.server.getCommands().sendCommands(p_11227_);
+        } // Paper - Add sendOpLevel API
     }
 
     public boolean isWhiteListed(GameProfile p_11294_) {
-        return !this.doWhiteList || this.ops.contains(p_11294_) || this.whitelist.contains(p_11294_);
+        // Paper start - ProfileWhitelistVerifyEvent
+        return this.isWhiteListed(p_11294_, null);
+    }
+    public boolean isWhiteListed(GameProfile gameprofile, @Nullable org.bukkit.event.player.PlayerLoginEvent loginEvent) {
+        boolean isOp = this.ops.contains(gameprofile);
+        boolean isWhitelisted = !this.doWhiteList || isOp || this.whitelist.contains(gameprofile);
+        final com.destroystokyo.paper.event.profile.ProfileWhitelistVerifyEvent event;
+
+        final net.kyori.adventure.text.Component configuredMessage = ColorAPI.colorize(org.spigotmc.SpigotConfig.whitelistMessage);
+        event = new com.destroystokyo.paper.event.profile.ProfileWhitelistVerifyEvent(com.destroystokyo.paper.profile.CraftPlayerProfile.asBukkitMirror(gameprofile), this.doWhiteList, isWhitelisted, isOp, configuredMessage);
+        event.callEvent();
+        if (!event.isWhitelisted()) {
+            if (loginEvent != null) {
+                loginEvent.disallow(PlayerLoginEvent.Result.KICK_WHITELIST, event.kickMessage() == null ? configuredMessage : event.kickMessage());
+            }
+            return false;
+        }
+        return true;
+        // Paper end - ProfileWhitelistVerifyEvent
     }
 
     public boolean isOp(GameProfile p_11304_) {
@@ -626,16 +_,7 @@
 
     @Nullable
     public ServerPlayer getPlayerByName(String p_11256_) {
-        int i = this.players.size();
-
-        for (int j = 0; j < i; j++) {
-            ServerPlayer serverplayer = this.players.get(j);
-            if (serverplayer.getGameProfile().getName().equalsIgnoreCase(p_11256_)) {
-                return serverplayer;
-            }
-        }
-
-        return null;
+        return this.playersByName.get(p_11256_.toLowerCase(java.util.Locale.ROOT)); // Spigot
     }
 
     public void broadcast(
@@ -643,6 +_,13 @@
     ) {
         for (int i = 0; i < this.players.size(); i++) {
             ServerPlayer serverplayer = this.players.get(i);
+
+            // CraftBukkit start - Test if player receiving packet can see the source of the packet
+            if (p_11242_ != null && !serverplayer.getBukkitEntity().canSee(p_11242_.getBukkitEntity())) {
+                continue;
+            }
+            // CraftBukkit end
+
             if (serverplayer != p_11242_ && serverplayer.level().dimension() == p_11247_) {
                 double d0 = p_11243_ - serverplayer.getX();
                 double d1 = p_11244_ - serverplayer.getY();
@@ -655,11 +_,24 @@
     }
 
     public void saveAll() {
-        for (int i = 0; i < this.players.size(); i++) {
-            this.save(this.players.get(i));
-        }
+        // Paper start - Incremental chunk and player saving
+        this.saveAll(-1);
     }
 
+    public void saveAll(int interval) {
+        io.papermc.paper.util.MCUtil.ensureMain("Save Players" , () -> { // Paper - Ensure main
+            int numSaved = 0;
+            long now = MinecraftServer.currentTick;
+            for (int i = 0; i < this.players.size(); ++i) {
+                ServerPlayer entityplayer = this.players.get(i);
+                if (interval == -1 || now - entityplayer.lastSave >= interval) {
+                    this.save(entityplayer);
+                    if (interval != -1 && ++numSaved >= io.papermc.paper.configuration.GlobalConfiguration.get().playerAutoSave.maxPerTick()) { break; }
+                }
+                // Paper end - Incremental chunk and player saving
+            }
+            return null; }); // Paper - ensure main
+    }
     public UserWhiteList getWhiteList() {
         return this.whitelist;
     }
@@ -682,23 +_,36 @@
     public void sendLevelInfo(ServerPlayer p_11230_, ServerLevel p_11231_) {
         WorldBorder worldborder = this.server.overworld().getWorldBorder();
         p_11230_.connection.send(new ClientboundInitializeBorderPacket(worldborder));
+        if (p_11230_.connection.hasChannel(net.neoforged.neoforge.network.payload.ClientboundCustomSetTimePayload.TYPE)) {
+            p_11230_.connection.send(new net.neoforged.neoforge.network.payload.ClientboundCustomSetTimePayload(p_11231_.getGameTime(), p_11231_.getDayTime(), p_11231_.getGameRules().getBoolean(GameRules.RULE_DAYLIGHT), p_11231_.getDayTimeFraction(), p_11231_.getDayTimePerTick()));
+        } else {
         p_11230_.connection
             .send(new ClientboundSetTimePacket(p_11231_.getGameTime(), p_11231_.getDayTime(), p_11231_.getGameRules().getBoolean(GameRules.RULE_DAYLIGHT)));
+        }
         p_11230_.connection.send(new ClientboundSetDefaultSpawnPositionPacket(p_11231_.getSharedSpawnPos(), p_11231_.getSharedSpawnAngle()));
         if (p_11231_.isRaining()) {
-            p_11230_.connection.send(new ClientboundGameEventPacket(ClientboundGameEventPacket.START_RAINING, 0.0F));
-            p_11230_.connection.send(new ClientboundGameEventPacket(ClientboundGameEventPacket.RAIN_LEVEL_CHANGE, p_11231_.getRainLevel(1.0F)));
-            p_11230_.connection.send(new ClientboundGameEventPacket(ClientboundGameEventPacket.THUNDER_LEVEL_CHANGE, p_11231_.getThunderLevel(1.0F)));
+            // CraftBukkit start - handle player weather
+            p_11230_.setPlayerWeather(org.bukkit.WeatherType.DOWNFALL, false);
+            p_11230_.updateWeather(-p_11231_.rainLevel, p_11231_.rainLevel, -p_11231_.thunderLevel, p_11231_.thunderLevel);
+            // CraftBukkit end
         }
 
         p_11230_.connection.send(new ClientboundGameEventPacket(ClientboundGameEventPacket.LEVEL_CHUNKS_LOAD_START, 0.0F));
         this.server.tickRateManager().updateJoiningPlayer(p_11230_);
+        net.neoforged.neoforge.attachment.AttachmentSync.syncInitialLevelAttachments(p_11231_, p_11230_);
     }
 
     public void sendAllPlayerInfo(ServerPlayer p_11293_) {
         p_11293_.inventoryMenu.sendAllDataToRemote();
-        p_11293_.resetSentInfo();
+        p_11293_.getBukkitEntity().updateScaledHealth(); // CraftBukkit - Update scaled health on respawn and worldchange
+        p_11293_.refreshEntityData(p_11293_); // CraftBukkkit - SPIGOT-7218: sync metadata
         p_11293_.connection.send(new ClientboundSetCarriedItemPacket(p_11293_.getInventory().selected));
+        // CraftBukkit start - from GameRules
+        int i = p_11293_.level().getGameRules().getBoolean(GameRules.RULE_REDUCEDDEBUGINFO) ? 22 : 23;
+        p_11293_.connection.send(new ClientboundEntityEventPacket(p_11293_, (byte) i));
+        float immediateRespawn = p_11293_.level().getGameRules().getBoolean(GameRules.RULE_DO_IMMEDIATE_RESPAWN) ? 1.0F: 0.0F;
+        p_11293_.connection.send(new ClientboundGameEventPacket(ClientboundGameEventPacket.IMMEDIATE_RESPAWN, immediateRespawn));
+        // CraftBukkit end
     }
 
     public int getPlayerCount() {
@@ -714,6 +_,7 @@
     }
 
     public void setUsingWhiteList(boolean p_11276_) {
+        new WhitelistToggleEvent(p_11276_).callEvent(); // Paper - WhitelistToggleEvent
         this.doWhiteList = p_11276_;
     }
 
@@ -752,9 +_,25 @@
 
     public void removeAll() {
         for (int i = 0; i < this.players.size(); i++) {
-            this.players.get(i).connection.disconnect(Component.translatable("multiplayer.disconnect.server_shutdown"));
-        }
-    }
+            this.players.get(i).connection.disconnect(java.util.Objects.requireNonNullElseGet(this.server.server.shutdownMessage(), net.kyori.adventure.text.Component::empty)); // CraftBukkit - add custom shutdown message // Paper - Adventure
+        }
+
+        // Paper start - Configurable player collision; Remove collideRule team if it exists
+        if (this.collideRuleTeamName != null) {
+            final net.minecraft.world.scores.Scoreboard scoreboard = this.getServer().getLevel(Level.OVERWORLD).getScoreboard();
+            final PlayerTeam team = scoreboard.getPlayersTeam(this.collideRuleTeamName);
+            if (team != null) scoreboard.removePlayerTeam(team);
+        }
+        // Paper end - Configurable player collision
+    }
+
+    // CraftBukkit start
+    public void broadcastMessage(Component[] iChatBaseComponents) {
+        for (Component component : iChatBaseComponents) {
+            broadcastSystemMessage(component, false);
+        }
+    }
+    // CraftBukkit end
 
     public void broadcastSystemMessage(Component p_240618_, boolean p_240644_) {
         this.broadcastSystemMessage(p_240618_, p_215639_ -> p_240618_, p_240644_);
@@ -776,20 +_,39 @@
     }
 
     public void broadcastChatMessage(PlayerChatMessage p_243264_, ServerPlayer p_243234_, ChatType.Bound p_243204_) {
-        this.broadcastChatMessage(p_243264_, p_243234_::shouldFilterMessageTo, p_243234_, p_243204_);
-    }
-
-    private void broadcastChatMessage(
-        PlayerChatMessage p_249952_, Predicate<ServerPlayer> p_250784_, @Nullable ServerPlayer p_249623_, ChatType.Bound p_250276_
+        // Paper start
+        this.broadcastChatMessage(p_243264_, p_243234_, p_243204_, null);
+    }
+
+    public void broadcastChatMessage(PlayerChatMessage p_243264_, ServerPlayer p_243234_, ChatType.Bound p_243204_, @Nullable Function<net.kyori.adventure.audience.Audience, Component> unsignedFunction) {
+        // Paper end
+        this.broadcastChatMessage(p_243264_, p_243234_::shouldFilterMessageTo, p_243234_, p_243204_, unsignedFunction);
+    }
+
+    // Youer start
+    AtomicReference<Function<net.kyori.adventure.audience.Audience, Component>> broadcastChatMessage$unsignedFunction = new AtomicReference<>(null);
+    public void broadcastChatMessage(
+            PlayerChatMessage p_249952_, Predicate<ServerPlayer> p_250784_, @Nullable ServerPlayer p_249623_, ChatType.Bound p_250276_
     ) {
+        // Paper end
         boolean flag = this.verifyChatTrusted(p_249952_);
-        this.server.logChatMessage(p_249952_.decoratedContent(), p_250276_, flag ? null : "Not Secure");
+        Function<net.kyori.adventure.audience.Audience, Component> unsignedFunction = broadcastChatMessage$unsignedFunction.getAndSet(null);
+        this.server.logChatMessage((unsignedFunction == null ? p_249952_.decoratedContent() : unsignedFunction.apply(this.server.console)), p_250276_, flag ? null : "Not Secure"); // Paper
         OutgoingChatMessage outgoingchatmessage = OutgoingChatMessage.create(p_249952_);
         boolean flag1 = false;
+        Packet<?> disguised = p_249623_ != null && unsignedFunction == null ? new net.minecraft.network.protocol.game.ClientboundDisguisedChatPacket(outgoingchatmessage.content(), p_250276_) : null; // Paper - don't send player chat packets from vanished players
 
         for (ServerPlayer serverplayer : this.players) {
             boolean flag2 = p_250784_.test(serverplayer);
-            serverplayer.sendChatMessage(outgoingchatmessage, flag2, p_250276_);
+            // Paper start - don't send player chat packets from vanished players
+            if (p_249623_ != null && !serverplayer.getBukkitEntity().canSee(p_249623_.getBukkitEntity())) {
+                serverplayer.connection.send(unsignedFunction != null
+                        ? new net.minecraft.network.protocol.game.ClientboundDisguisedChatPacket(unsignedFunction.apply(serverplayer.getBukkitEntity()), p_250276_)
+                        : disguised);
+                continue;
+            }
+            // Paper end
+            serverplayer.sendChatMessage(outgoingchatmessage, flag2, p_250276_, unsignedFunction == null ? null : unsignedFunction.apply(serverplayer.getBukkitEntity())); // Paper
             flag1 |= flag2 && p_249952_.isFullyFiltered();
         }
 
@@ -797,27 +_,32 @@
             p_249623_.sendSystemMessage(CHAT_FILTERED_FULL);
         }
     }
+    public void broadcastChatMessage(PlayerChatMessage p_249952_, Predicate<ServerPlayer> p_250784_, @Nullable ServerPlayer p_249623_, ChatType.Bound p_250276_, @Nullable Function<net.kyori.adventure.audience.Audience, Component> unsignedFunction) {
+        broadcastChatMessage$unsignedFunction.set(unsignedFunction);
+        broadcastChatMessage(p_249952_, p_250784_, p_249623_, p_250276_);
+    }
+    // Youer end
 
-    private boolean verifyChatTrusted(PlayerChatMessage p_251384_) {
+    public boolean verifyChatTrusted(PlayerChatMessage p_251384_) {  // Paper - private -> public
         return p_251384_.hasSignature() && !p_251384_.hasExpiredServer(Instant.now());
     }
 
-    public ServerStatsCounter getPlayerStats(Player p_11240_) {
-        UUID uuid = p_11240_.getUUID();
-        ServerStatsCounter serverstatscounter = this.stats.get(uuid);
+    // CraftBukkit start
+    public ServerStatsCounter getPlayerStats(ServerPlayer p_11240_) {
+        ServerStatsCounter serverstatisticmanager = p_11240_.getStats();
+        return serverstatisticmanager == null ? getPlayerStats(p_11240_.getUUID(), p_11240_.getGameProfile().getName()) : serverstatisticmanager; // Paper - use username and not display name
+    }
+
+    public ServerStatsCounter getPlayerStats(UUID uuid, String displayName) {
+        ServerPlayer entityhuman = this.getPlayer(uuid);
+        ServerStatsCounter serverstatscounter = entityhuman == null ? null : (ServerStatsCounter) entityhuman.getStats();
+        // CraftBukkit end
         if (serverstatscounter == null) {
             File file1 = this.server.getWorldPath(LevelResource.PLAYER_STATS_DIR).toFile();
-            File file2 = new File(file1, uuid + ".json");
-            if (!file2.exists()) {
-                File file3 = new File(file1, p_11240_.getName().getString() + ".json");
-                Path path = file3.toPath();
-                if (FileUtil.isPathNormalized(path) && FileUtil.isPathPortable(path) && path.startsWith(file1.getPath()) && file3.isFile()) {
-                    file3.renameTo(file2);
-                }
-            }
+            File file2 = new File(file1, displayName + ".json"); // CraftBukkit
 
             serverstatscounter = new ServerStatsCounter(this.server, file2);
-            this.stats.put(uuid, serverstatscounter);
+            this.stats.put(uuid, serverstatscounter);  // CraftBukkit
         }
 
         return serverstatscounter;
@@ -832,6 +_,8 @@
             this.advancements.put(uuid, playeradvancements);
         }
 
+        // Forge: don't overwrite active player with a fake one.
+        if (!(p_11297_ instanceof net.neoforged.neoforge.common.util.FakePlayer))
         playeradvancements.setPlayer(p_11297_);
         return playeradvancements;
     }
@@ -859,7 +_,7 @@
     }
 
     public List<ServerPlayer> getPlayers() {
-        return this.players;
+        return this.playersView; //Unmodifiable view, we don't want people removing things without us knowing.
     }
 
     @Nullable
@@ -876,6 +_,11 @@
             playeradvancements.reload(this.server.getAdvancements());
         }
 
+        for (ServerPlayer player: this.players) {
+            player.getAdvancements().flushDirty(player); // CraftBukkit - trigger immediate flush of advancements
+        }
+
+        net.neoforged.neoforge.common.NeoForge.EVENT_BUS.post(new net.neoforged.neoforge.event.OnDatapackSyncEvent(this, null));
         this.broadcastAll(new ClientboundUpdateTagsPacket(TagNetworkSerialization.serializeTagsToNetwork(this.registries)));
         ClientboundUpdateRecipesPacket clientboundupdaterecipespacket = new ClientboundUpdateRecipesPacket(this.server.getRecipeManager().getOrderedRecipes());
 
@@ -883,6 +_,30 @@
             serverplayer.connection.send(clientboundupdaterecipespacket);
             serverplayer.getRecipeBook().sendInitialRecipeBook(serverplayer);
         }
+    }
+
+    public void reloadAdvancementData() {
+        for (ServerPlayer player : this.players) {
+            player.getAdvancements().reload(this.server.getAdvancements());
+            player.getAdvancements().flushDirty(player); // CraftBukkit - trigger immediate flush of advancements
+        }
+    }
+
+    public void reloadTagData() {
+        // Paper end - API for updating recipes on clients
+        net.neoforged.neoforge.common.NeoForge.EVENT_BUS.post(new net.neoforged.neoforge.event.OnDatapackSyncEvent(this, null));
+        this.broadcastAll(new ClientboundUpdateTagsPacket(TagNetworkSerialization.serializeTagsToNetwork(this.registries)));
+        // Paper start - API for updating recipes on clients
+    }
+    public void reloadRecipeData() {
+        // Paper end - API for updating recipes on clients
+        ClientboundUpdateRecipesPacket packetplayoutrecipeupdate = new ClientboundUpdateRecipesPacket(this.server.getRecipeManager().getOrderedRecipes());
+
+        for (ServerPlayer entityplayer : this.players) {
+            entityplayer.connection.send(packetplayoutrecipeupdate);
+            entityplayer.getRecipeBook().sendInitialRecipeBook(entityplayer);
+        }
+
     }
 
     public boolean isAllowCommandsForAllPlayers() {
