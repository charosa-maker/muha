--- a/net/minecraft/world/inventory/AbstractContainerMenu.java
+++ b/net/minecraft/world/inventory/AbstractContainerMenu.java
@@ -1,5 +_,6 @@
 package net.minecraft.world.inventory;
 
+import com.mohistmc.youer.bukkit.inventory.YouerModsInventory;
 import com.google.common.base.Suppliers;
 import com.google.common.collect.HashBasedTable;
 import com.google.common.collect.Lists;
@@ -8,7 +_,9 @@
 import com.mojang.logging.LogUtils;
 import it.unimi.dsi.fastutil.ints.IntArrayList;
 import it.unimi.dsi.fastutil.ints.IntList;
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
 import java.util.Optional;
 import java.util.OptionalInt;
 import java.util.Set;
@@ -17,9 +_,11 @@
 import net.minecraft.CrashReport;
 import net.minecraft.CrashReportCategory;
 import net.minecraft.ReportedException;
-import net.minecraft.core.BlockPos;
 import net.minecraft.core.NonNullList;
 import net.minecraft.core.registries.BuiltInRegistries;
+import net.minecraft.network.chat.Component;
+import net.minecraft.network.protocol.game.ClientboundContainerSetSlotPacket;
+import net.minecraft.resources.ResourceLocation;
 import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.util.Mth;
 import net.minecraft.world.Container;
@@ -28,9 +_,16 @@
 import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.flag.FeatureFlagSet;
 import net.minecraft.world.item.ItemStack;
-import net.minecraft.world.level.Level;
 import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.block.entity.BlockEntity;
+import org.bukkit.craftbukkit.entity.CraftHumanEntity;
+import org.bukkit.craftbukkit.inventory.CraftInventory;
+import org.bukkit.craftbukkit.inventory.CraftInventoryView;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
+import org.bukkit.event.Event;
+import org.bukkit.event.inventory.InventoryDragEvent;
+import org.bukkit.event.inventory.InventoryType;
+import org.bukkit.inventory.InventoryView;
 import org.slf4j.Logger;
 
 public abstract class AbstractContainerMenu {
@@ -45,22 +_,94 @@
     public static final int CARRIED_SLOT_SIZE = Integer.MAX_VALUE;
     public NonNullList<ItemStack> lastSlots = NonNullList.create();
     public NonNullList<Slot> slots = NonNullList.create();
-    private final List<DataSlot> dataSlots = Lists.newArrayList();
+    public List<DataSlot> dataSlots = Lists.newArrayList();
     private ItemStack carried = ItemStack.EMPTY;
     public NonNullList<ItemStack> remoteSlots = NonNullList.create();
-    private final IntList remoteDataSlots = new IntArrayList();
+    public IntList remoteDataSlots = new IntArrayList();
     private ItemStack remoteCarried = ItemStack.EMPTY;
     private int stateId;
     @Nullable
     private final MenuType<?> menuType;
     public final int containerId;
-    private int quickcraftType = -1;
-    private int quickcraftStatus;
-    private final Set<Slot> quickcraftSlots = Sets.newHashSet();
+    public int quickcraftType = -1;
+    public int quickcraftStatus;
+    public final Set<Slot> quickcraftSlots = Sets.newHashSet();
     private final List<ContainerListener> containerListeners = Lists.newArrayList();
     @Nullable
     private ContainerSynchronizer synchronizer;
     private boolean suppressRemoteUpdates;
+    @Nullable protected ItemStack activeQuickItem = null; // Purpur - Anvil API
+
+    // CraftBukkit start
+    public boolean checkReachable = true;
+    // Youer start
+    public InventoryView bukkitView ;
+    public Player containerOwner = null;
+
+    public InventoryView getBukkitView(){
+        if (bukkitView == null && containerOwner != null) {
+            org.bukkit.inventory.Inventory view = new CraftInventory(new YouerModsInventory(this, containerOwner));
+            view.getType().setMods(true);
+            bukkitView = new CraftInventoryView<>(containerOwner.getBukkitEntity(), view, this);
+        }
+        return bukkitView;
+    }
+
+    public InventoryView getBukkitView(AbstractContainerMenu other){
+        if (other.bukkitView == null && other.containerOwner != null) {
+            org.bukkit.inventory.Inventory view = new CraftInventory(new YouerModsInventory(other, containerOwner));
+            view.getType().setMods(true);
+            return new CraftInventoryView<>(other.containerOwner.getBukkitEntity(), view, other);
+        }
+        return other.bukkitView;
+    }
+
+    public void transferTo(AbstractContainerMenu other, CraftHumanEntity player) {
+        other.containerOwner = player.getHandle();
+        this.containerOwner = player.getHandle();
+        InventoryView source = this.getBukkitView(), destination = other.getBukkitView();
+        if (destination == null) {
+            destination = this.getBukkitView(other);
+        }
+        if (source == null) {
+            org.bukkit.inventory.Inventory view = new CraftInventory(new YouerModsInventory(this, containerOwner));
+            view.getType().setMods(true);
+            source = new CraftInventoryView<>(containerOwner.getBukkitEntity(), view, this);
+        }
+        ((CraftInventory) source.getTopInventory()).getInventory().onClose(player);
+        ((CraftInventory) source.getBottomInventory()).getInventory().onClose(player);
+        ((CraftInventory) destination.getTopInventory()).getInventory().onOpen(player);
+        ((CraftInventory) destination.getBottomInventory()).getInventory().onOpen(player);
+    }
+
+    private Component title = null;
+    public Component getTitle() {
+        // Youer: null title -> empty title
+        if (this.title == null) {
+            if (this.menuType != null) {
+                ResourceLocation key = BuiltInRegistries.MENU.getKey(this.menuType);
+                if (key == null) {
+                    this.title = Component.literal(this.toString());
+                } else {
+                    this.title = Component.translatable(key.toString());
+                }
+            } else {
+                this.title = Component.literal(this.toString());
+            }
+        }
+        return this.title;
+    }
+    public void setTitle(Component title) {
+        if (this.title == null) {
+            if (title == null) {
+                this.title = getTitle();
+            } else {
+                this.title = title;
+            }
+        }
+    }
+    // CraftBukkit end
+    // Youer end
 
     protected AbstractContainerMenu(@Nullable MenuType<?> p_38851_, int p_38852_) {
         this.menuType = p_38851_;
@@ -150,6 +_,15 @@
         }
     }
 
+    // CraftBukkit start
+    public void broadcastCarriedItem() {
+        this.remoteCarried = this.getCarried().copy();
+        if (this.synchronizer != null) {
+            this.synchronizer.sendCarriedChange(this, this.remoteCarried);
+        }
+    }
+    // CraftBukkit end
+
     public void removeSlotListener(ContainerListener p_38944_) {
         this.containerListeners.remove(p_38944_);
     }
@@ -214,7 +_,7 @@
             this.lastSlots.set(p_150408_, itemstack1);
 
             for (ContainerListener containerlistener : this.containerListeners) {
-                containerlistener.slotChanged(this, p_150408_, itemstack1);
+                containerlistener.slotChanged(this, p_150408_, itemstack, itemstack1); // Paper - Add PlayerInventorySlotChangeEvent
             }
         }
     }
@@ -222,7 +_,16 @@
     private void synchronizeSlotToRemote(int p_150436_, ItemStack p_150437_, Supplier<ItemStack> p_150438_) {
         if (!this.suppressRemoteUpdates) {
             ItemStack itemstack = this.remoteSlots.get(p_150436_);
-            if (!ItemStack.matches(itemstack, p_150437_)) {
+            // Youer start - fix mixin issue #geckolib$forceGeckolibIdSync
+            boolean flag;
+            if (this.synchronizer != null && this.synchronizer.player() != null && this.synchronizer.player().getBukkitEntity().simplifyContainerDesyncCheck()) {
+                // Only check the item type and count
+                flag =  (p_150437_ == p_150437_ || (p_150437_.getCount() == p_150437_.getCount() && ItemStack.isSameItem(p_150437_, p_150437_)));
+            } else {
+                flag = ItemStack.matches(itemstack, p_150437_);
+            }
+            if (!flag) {  // Paper - add flag to simplify remote matching logic
+                // Youer end - fix mixin issue
                 ItemStack itemstack1 = p_150438_.get();
                 this.remoteSlots.set(p_150436_, itemstack1);
                 if (this.synchronizer != null) {
@@ -232,6 +_,16 @@
         }
     }
 
+    // Paper start - add flag to simplify remote matching logic
+    private boolean matchesRemote(final ItemStack stack, final ItemStack other) {
+        if (this.synchronizer != null && this.synchronizer.player() != null && this.synchronizer.player().getBukkitEntity().simplifyContainerDesyncCheck()) {
+            // Only check the item type and count
+            return stack == other || (stack.getCount() == other.getCount() && ItemStack.isSameItem(stack, other));
+        }
+        return ItemStack.matches(stack, other);
+    }
+    // Paper end - add flag to simplify remote matching logic
+
     private void synchronizeDataSlotToRemote(int p_150441_, int p_150442_) {
         if (!this.suppressRemoteUpdates) {
             int i = this.remoteDataSlots.getInt(p_150441_);
@@ -246,7 +_,7 @@
 
     private void synchronizeCarriedToRemote() {
         if (!this.suppressRemoteUpdates) {
-            if (!ItemStack.matches(this.getCarried(), this.remoteCarried)) {
+            if (!this.matchesRemote(this.getCarried(), this.remoteCarried)) { // Paper - add flag to simplify remote matching logic
                 this.remoteCarried = this.getCarried().copy();
                 if (this.synchronizer != null) {
                     this.synchronizer.sendCarriedChange(this, this.remoteCarried);
@@ -315,6 +_,7 @@
                     this.resetQuickCraft();
                 }
             } else if (this.quickcraftStatus == 1) {
+                if (p_150431_ < 0) return; // Paper - Add slot sanity checks to container clicks
                 Slot slot = this.slots.get(p_150431_);
                 ItemStack itemstack = this.getCarried();
                 if (canItemQuickReplace(slot, itemstack, true)
@@ -325,7 +_,7 @@
                 }
             } else if (this.quickcraftStatus == 2) {
                 if (!this.quickcraftSlots.isEmpty()) {
-                    if (this.quickcraftSlots.size() == 1) {
+                    if (this.quickcraftSlots.size() == 1) { // Paper - Fix CraftBukkit drag system
                         int i1 = this.quickcraftSlots.iterator().next().index;
                         this.resetQuickCraft();
                         this.doClick(i1, this.quickcraftType, ClickType.PICKUP, p_150434_);
@@ -340,6 +_,7 @@
 
                     int k1 = this.getCarried().getCount();
 
+                    Map<Integer, ItemStack> draggedSlots = new HashMap<Integer, ItemStack>(); // CraftBukkit - Store slots from drag in map (raw slot id -> new stack)
                     for (Slot slot1 : this.quickcraftSlots) {
                         ItemStack itemstack1 = this.getCarried();
                         if (slot1 != null
@@ -351,12 +_,48 @@
                             int k = Math.min(itemstack3.getMaxStackSize(), slot1.getMaxStackSize(itemstack3));
                             int l = Math.min(getQuickCraftPlaceCount(this.quickcraftSlots, this.quickcraftType, itemstack3) + j, k);
                             k1 -= l - j;
-                            slot1.setByPlayer(itemstack3.copyWithCount(l));
-                        }
-                    }
-
-                    itemstack3.setCount(k1);
-                    this.setCarried(itemstack3);
+                            //slot1.setByPlayer(itemstack3.copyWithCount(l));
+                            draggedSlots.put(slot1.index, itemstack1.copyWithCount(l)); // CraftBukkit - Put in map instead of setting
+                        }
+                    }
+
+                    // CraftBukkit start - InventoryDragEvent
+                    InventoryView view = getBukkitView();
+                    org.bukkit.inventory.ItemStack newcursor = CraftItemStack.asCraftMirror(itemstack3);
+                    newcursor.setAmount(k1);
+                    Map<Integer, org.bukkit.inventory.ItemStack> eventmap = new HashMap<Integer, org.bukkit.inventory.ItemStack>();
+                    for (Map.Entry<Integer, ItemStack> ditem : draggedSlots.entrySet()) {
+                        eventmap.put(ditem.getKey(), CraftItemStack.asBukkitCopy(ditem.getValue()));
+                    }
+
+                    // It's essential that we set the cursor to the new value here to prevent item duplication if a plugin closes the inventory.
+                    ItemStack oldCursor = this.getCarried();
+                    this.setCarried(CraftItemStack.asNMSCopy(newcursor));
+
+                    InventoryDragEvent event = new InventoryDragEvent(view, (newcursor.getType() != org.bukkit.Material.AIR ? newcursor : null), CraftItemStack.asBukkitCopy(oldCursor), this.quickcraftType == 1, eventmap);
+                    p_150434_.level().getCraftServer().getPluginManager().callEvent(event);
+
+                    // Whether or not a change was made to the inventory that requires an update.
+                    boolean needsUpdate = event.getResult() != Event.Result.DEFAULT;
+
+                    if (event.getResult() != Event.Result.DENY) {
+                        for (Map.Entry<Integer, ItemStack> dslot : draggedSlots.entrySet()) {
+                            view.setItem(dslot.getKey(), CraftItemStack.asBukkitCopy(dslot.getValue()));
+                        }
+                        // The only time the carried item will be set to null is if the inventory is closed by the server.
+                        // If the inventory is closed by the server, then the cursor items are dropped.  This is why we change the cursor early.
+                        if (this.getCarried() != null) {
+                            this.setCarried(CraftItemStack.asNMSCopy(event.getCursor()));
+                            needsUpdate = true;
+                        }
+                    } else {
+                        this.setCarried(oldCursor);
+                    }
+
+                    if (needsUpdate && p_150434_ instanceof ServerPlayer) {
+                        this.sendAllDataToRemote();
+                    }
+                    // CraftBukkit end
                 }
 
                 this.resetQuickCraft();
@@ -370,7 +_,8 @@
             if (p_150431_ == -999) {
                 if (!this.getCarried().isEmpty()) {
                     if (clickaction == ClickAction.PRIMARY) {
-                        p_150434_.drop(this.getCarried(), true);
+                        ItemStack carried = this.getCarried();
+                        p_150434_.drop(carried, true);
                         this.setCarried(ItemStack.EMPTY);
                     } else {
                         p_150434_.drop(this.getCarried().split(1), true);
@@ -435,8 +_,18 @@
                 }
 
                 slot7.setChanged();
+                // CraftBukkit start - Make sure the client has the right slot contents
+                if (p_150434_ instanceof ServerPlayer serverPlayer && slot7.getMaxStackSize() != 64) {
+                    serverPlayer.connection.send(new ClientboundContainerSetSlotPacket(this.containerId, this.incrementStateId(), slot7.index, slot7.getItem()));
+                    // Updating a crafting inventory makes the client reset the result slot, have to send it again
+                    if (this.getBukkitView().getType() == InventoryType.WORKBENCH || this.getBukkitView().getType() == InventoryType.CRAFTING) {
+                        serverPlayer.connection.send(new ClientboundContainerSetSlotPacket(this.containerId, this.incrementStateId(), 0, this.getSlot(0).getItem()));
+                    }
+                }
+                // CraftBukkit end
             }
         } else if (p_150433_ == ClickType.SWAP && (p_150432_ >= 0 && p_150432_ < 9 || p_150432_ == 40)) {
+            if (p_150431_ < 0) return; // Paper - Add slot sanity checks to container clicks
             ItemStack itemstack2 = inventory.getItem(p_150432_);
             Slot slot5 = this.slots.get(p_150431_);
             ItemStack itemstack7 = slot5.getItem();
@@ -511,6 +_,12 @@
     }
 
     private boolean tryItemClickBehaviourOverride(Player p_249615_, ClickAction p_250300_, Slot p_249384_, ItemStack p_251073_, ItemStack p_252026_) {
+        // Neo: Fire the ItemStackedOnOtherEvent, and return true if it was cancelled (meaning the event was handled). Returning true will trigger the container to stop processing further logic.
+        // The first parameter to onItemStackedOn is the "carried" (under-mouse) item, which is the second ItemStack parameter to this method.
+        if (net.neoforged.neoforge.common.CommonHooks.onItemStackedOn(p_252026_, p_251073_, p_249384_, p_250300_, p_249615_, createCarriedSlotAccess())) {
+            return true;
+        }
+
         FeatureFlagSet featureflagset = p_249615_.level().enabledFeatures();
         return p_252026_.isItemEnabled(featureflagset) && p_252026_.overrideStackedOnOther(p_249384_, p_250300_, p_249615_)
             ? true
@@ -541,13 +_,14 @@
         if (p_38940_ instanceof ServerPlayer) {
             ItemStack itemstack = this.getCarried();
             if (!itemstack.isEmpty()) {
+                this.setCarried(ItemStack.EMPTY); // CraftBukkit - SPIGOT-4556 - from below
                 if (p_38940_.isAlive() && !((ServerPlayer)p_38940_).hasDisconnected()) {
                     p_38940_.getInventory().placeItemBackInInventory(itemstack);
                 } else {
                     p_38940_.drop(itemstack, false);
                 }
 
-                this.setCarried(ItemStack.EMPTY);
+                // this.setCarried(ItemStack.EMPTY); // CraftBukkit - moved up
             }
         }
     }
@@ -592,6 +_,14 @@
     public abstract boolean stillValid(Player p_38874_);
 
     protected boolean moveItemStackTo(ItemStack p_38904_, int p_38905_, int p_38906_, boolean p_38907_) {
+        // Paper start - Add PlayerTradeEvent and PlayerPurchaseEvent
+        return this.moveItemStackTo(p_38904_, p_38905_, p_38906_, p_38907_, false);
+    }
+    protected boolean moveItemStackTo(ItemStack p_38904_, int p_38905_, int p_38906_, boolean p_38907_, boolean isCheck) {
+        if (isCheck) {
+            p_38904_ = p_38904_.copy();
+        }
+        // Paper end - Add PlayerTradeEvent and PlayerPurchaseEvent
         boolean flag = false;
         int i = p_38905_;
         if (p_38907_) {
@@ -602,18 +_,27 @@
             while (!p_38904_.isEmpty() && (p_38907_ ? i >= p_38905_ : i < p_38906_)) {
                 Slot slot = this.slots.get(i);
                 ItemStack itemstack = slot.getItem();
+                // Paper start - Add PlayerTradeEvent and PlayerPurchaseEvent; clone if only a check
+                if (isCheck) {
+                    itemstack = itemstack.copy();
+                }
+                // Paper end - Add PlayerTradeEvent and PlayerPurchaseEvent
                 if (!itemstack.isEmpty() && ItemStack.isSameItemSameComponents(p_38904_, itemstack)) {
                     int j = itemstack.getCount() + p_38904_.getCount();
                     int k = slot.getMaxStackSize(itemstack);
                     if (j <= k) {
                         p_38904_.setCount(0);
                         itemstack.setCount(j);
-                        slot.setChanged();
+                        if (!isCheck) { // Paper - Add PlayerTradeEvent and PlayerPurchaseEvent
+                            slot.setChanged();
+                        } // Paper - Add PlayerTradeEvent and PlayerPurchaseEvent
                         flag = true;
                     } else if (itemstack.getCount() < k) {
                         p_38904_.shrink(k - itemstack.getCount());
                         itemstack.setCount(k);
-                        slot.setChanged();
+                        if (!isCheck) { // Paper - Add PlayerTradeEvent and PlayerPurchaseEvent
+                            slot.setChanged();
+                        } // Paper - Add PlayerTradeEvent and PlayerPurchaseEvent
                         flag = true;
                     }
                 }
@@ -636,10 +_,21 @@
             while (p_38907_ ? i >= p_38905_ : i < p_38906_) {
                 Slot slot1 = this.slots.get(i);
                 ItemStack itemstack1 = slot1.getItem();
+                // Paper start - Add PlayerTradeEvent and PlayerPurchaseEvent
+                if (isCheck) {
+                    itemstack1 = itemstack1.copy();
+                }
+                // Paper end - Add PlayerTradeEvent and PlayerPurchaseEvent
                 if (itemstack1.isEmpty() && slot1.mayPlace(p_38904_)) {
                     int l = slot1.getMaxStackSize(p_38904_);
-                    slot1.setByPlayer(p_38904_.split(Math.min(p_38904_.getCount(), l)));
-                    slot1.setChanged();
+                    // Paper start - Add PlayerTradeEvent and PlayerPurchaseEvent
+                    if (isCheck) {
+                        p_38904_.shrink(Math.min(p_38904_.getCount(), l));
+                    } else {
+                        // Paper end - Add PlayerTradeEvent and PlayerPurchaseEvent
+                        slot1.setByPlayer(p_38904_.split(Math.min(p_38904_.getCount(), l)));
+                        slot1.setChanged();
+                    }// Paper - Add PlayerTradeEvent and PlayerPurchaseEvent
                     flag = true;
                     break;
                 }
@@ -675,7 +_,7 @@
         }
     }
 
-    protected void resetQuickCraft() {
+    public void resetQuickCraft() {
         this.quickcraftStatus = 0;
         this.quickcraftSlots.clear();
     }
@@ -727,6 +_,11 @@
     }
 
     public ItemStack getCarried() {
+        // CraftBukkit start
+        if (this.carried.isEmpty()) {
+            this.setCarried(ItemStack.EMPTY);
+        }
+        // CraftBukkit end
         return this.carried;
     }
 
