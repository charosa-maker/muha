--- a/net/minecraft/world/level/block/Block.java
+++ b/net/minecraft/world/level/block/Block.java
@@ -8,6 +_,7 @@
 import com.mojang.serialization.MapCodec;
 import it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap;
 import java.util.List;
+import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.Function;
 import java.util.function.Supplier;
 import javax.annotation.Nullable;
@@ -65,7 +_,7 @@
     public static final MapCodec<Block> CODEC = simpleCodec(Block::new);
     private static final Logger LOGGER = LogUtils.getLogger();
     private final Holder.Reference<Block> builtInRegistryHolder = BuiltInRegistries.BLOCK.createIntrusiveHolder(this);
-    public static final IdMapper<BlockState> BLOCK_STATE_REGISTRY = new IdMapper<>();
+    public static final IdMapper<BlockState> BLOCK_STATE_REGISTRY = net.neoforged.neoforge.registries.GameData.getBlockStateIDMap();
     private static final LoadingCache<VoxelShape, Boolean> SHAPE_FULL_BLOCK_CACHE = CacheBuilder.newBuilder()
         .maximumSize(512L)
         .weakKeys()
@@ -89,6 +_,24 @@
     public static final int UPDATE_LIMIT = 512;
     protected final StateDefinition<Block, BlockState> stateDefinition;
     private BlockState defaultBlockState;
+    // Purpur start
+    public float fallDamageMultiplier = 1.0F;
+    public float fallDistanceMultiplier = 1.0F;
+    // Purpur end
+    // Paper start
+    public final boolean isDestroyable() {
+        return io.papermc.paper.configuration.GlobalConfiguration.get().unsupportedSettings.allowPermanentBlockBreakExploits ||
+                this != Blocks.BARRIER &&
+                        this != Blocks.BEDROCK &&
+                        this != Blocks.END_PORTAL_FRAME &&
+                        this != Blocks.END_PORTAL &&
+                        this != Blocks.END_GATEWAY &&
+                        this != Blocks.COMMAND_BLOCK &&
+                        this != Blocks.REPEATING_COMMAND_BLOCK &&
+                        this != Blocks.CHAIN_COMMAND_BLOCK &&
+                        this != Blocks.STRUCTURE_BLOCK &&
+                        this != Blocks.JIGSAW;
+    }
     @Nullable
     private String descriptionId;
     @Nullable
@@ -186,7 +_,7 @@
         this.createBlockStateDefinition(builder);
         this.stateDefinition = builder.create(Block::defaultBlockState, BlockState::new);
         this.registerDefaultState(this.stateDefinition.any());
-        if (SharedConstants.IS_RUNNING_IN_IDE) {
+        if (SharedConstants.IS_RUNNING_IN_IDE && false) {
             String s = this.getClass().getSimpleName();
             if (!s.endsWith("Block")) {
                 LOGGER.error("Block classes should end with Block and {} doesn't.", s);
@@ -208,6 +_,8 @@
         BlockState blockstate = p_152446_.getBlockState(p_152449_);
         if (p_152445_.skipRendering(blockstate, p_152448_)) {
             return false;
+        } else if (blockstate.hidesNeighborFace(p_152446_, p_152449_, p_152445_, p_152448_.getOpposite()) && p_152445_.supportsExternalFaceHiding()) {
+            return false;
         } else if (blockstate.canOcclude()) {
             Block.BlockStatePairKey block$blockstatepairkey = new Block.BlockStatePairKey(p_152445_, blockstate, p_152448_);
             Object2ByteLinkedOpenHashMap<Block.BlockStatePairKey> object2bytelinkedopenhashmap = OCCLUSION_CACHE.get();
@@ -281,24 +_,39 @@
 
     public static void dropResources(BlockState p_49951_, Level p_49952_, BlockPos p_49953_) {
         if (p_49952_ instanceof ServerLevel) {
+            beginCapturingDrops();
             getDrops(p_49951_, (ServerLevel)p_49952_, p_49953_, null).forEach(p_152406_ -> popResource(p_49952_, p_49953_, p_152406_));
-            p_49951_.spawnAfterBreak((ServerLevel)p_49952_, p_49953_, ItemStack.EMPTY, true);
+            List<ItemEntity> captured = stopCapturingDrops();
+            net.neoforged.neoforge.common.CommonHooks.handleBlockDrops((ServerLevel) p_49952_, p_49953_, p_49951_, null, captured, null, ItemStack.EMPTY);
         }
     }
 
     public static void dropResources(BlockState p_49893_, LevelAccessor p_49894_, BlockPos p_49895_, @Nullable BlockEntity p_49896_) {
         if (p_49894_ instanceof ServerLevel) {
+            beginCapturingDrops();
             getDrops(p_49893_, (ServerLevel)p_49894_, p_49895_, p_49896_).forEach(p_49859_ -> popResource((ServerLevel)p_49894_, p_49895_, p_49859_));
-            p_49893_.spawnAfterBreak((ServerLevel)p_49894_, p_49895_, ItemStack.EMPTY, true);
+            List<ItemEntity> captured = stopCapturingDrops();
+            net.neoforged.neoforge.common.CommonHooks.handleBlockDrops((ServerLevel) p_49894_, p_49895_, p_49893_, p_49896_, captured, null, ItemStack.EMPTY);
         }
     }
+
+    // Paper start - Add BlockBreakBlockEvent TODO Youer hook neoforge event
+    public static AtomicReference<BlockPos> dropResources$paperSource = new AtomicReference<>(null);
+    public static boolean dropResources(BlockState p_49893_, LevelAccessor p_49894_, BlockPos p_49895_, @Nullable BlockEntity p_49896_, BlockPos source) {
+        dropResources$paperSource.set(source);
+        dropResources(p_49893_, p_49894_, p_49895_, p_49896_);
+        return true;
+    }
+    // Paper end - Add BlockBreakBlockEvent
 
     public static void dropResources(
-        BlockState p_49882_, Level p_49883_, BlockPos p_49884_, @Nullable BlockEntity p_49885_, @Nullable Entity p_49886_, ItemStack p_49887_
+            BlockState p_49882_, Level p_49883_, BlockPos p_49884_, @Nullable BlockEntity p_49885_, @Nullable Entity p_49886_, ItemStack p_49887_
     ) {
         if (p_49883_ instanceof ServerLevel) {
+            beginCapturingDrops();
             getDrops(p_49882_, (ServerLevel)p_49883_, p_49884_, p_49885_, p_49886_, p_49887_).forEach(p_49944_ -> popResource(p_49883_, p_49884_, p_49944_));
-            p_49882_.spawnAfterBreak((ServerLevel)p_49883_, p_49884_, p_49887_, true);
+            List<ItemEntity> captured = stopCapturingDrops();
+            net.neoforged.neoforge.common.CommonHooks.handleBlockDrops((ServerLevel) p_49883_, p_49884_, p_49882_, p_49885_, captured, p_49886_, p_49887_);
         }
     }
 
@@ -326,19 +_,31 @@
     }
 
     private static void popResource(Level p_152441_, Supplier<ItemEntity> p_152442_, ItemStack p_152443_) {
-        if (!p_152441_.isClientSide && !p_152443_.isEmpty() && p_152441_.getGameRules().getBoolean(GameRules.RULE_DOBLOCKDROPS)) {
+        if (!p_152441_.isClientSide && !p_152443_.isEmpty() && p_152441_.getGameRules().getBoolean(GameRules.RULE_DOBLOCKDROPS) && !p_152441_.restoringBlockSnapshots) {
             ItemEntity itementity = p_152442_.get();
             itementity.setDefaultPickUpDelay();
-            p_152441_.addFreshEntity(itementity);
+            // Neo: Add drops to the captured list if capturing is enabled.
+            if (capturedDrops != null) {
+                capturedDrops.add(itementity);
+            }
+            else {
+                p_152441_.addFreshEntity(itementity);
+            }
         }
     }
 
     public void popExperience(ServerLevel p_49806_, BlockPos p_49807_, int p_49808_) {
-        if (p_49806_.getGameRules().getBoolean(GameRules.RULE_DOBLOCKDROPS)) {
-            ExperienceOrb.award(p_49806_, Vec3.atCenterOf(p_49807_), p_49808_);
+        if (p_49806_.getGameRules().getBoolean(GameRules.RULE_DOBLOCKDROPS) && !p_49806_.restoringBlockSnapshots) {
+            ExperienceOrb.award(p_49806_, Vec3.atCenterOf(p_49807_), p_49808_); // Paper
         }
     }
 
+    public void popExperiencePaper(ServerLevel p_49806_, BlockPos p_49807_, int p_49808_, net.minecraft.world.entity.Entity entity) {
+        ExperienceOrb.awardPaper(org.bukkit.entity.ExperienceOrb.SpawnReason.BLOCK_BREAK, entity, null); // Paper
+        popExperience(p_49806_, p_49807_, p_49808_);
+    }
+
+    @Deprecated //Forge: Use more sensitive version
     public float getExplosionResistance() {
         return this.explosionResistance;
     }
@@ -356,12 +_,23 @@
 
     public void playerDestroy(Level p_49827_, Player p_49828_, BlockPos p_49829_, BlockState p_49830_, @Nullable BlockEntity p_49831_, ItemStack p_49832_) {
         p_49828_.awardStat(Stats.BLOCK_MINED.get(this));
-        p_49828_.causeFoodExhaustion(0.005F);
+        // CraftBukkit start - EntityExhaustionEvent
+        p_49828_.causeFoodExhaustion(0.005F, org.bukkit.event.entity.EntityExhaustionEvent.ExhaustionReason.BLOCK_MINED);
+        // CraftBukkit end
         dropResources(p_49830_, p_49827_, p_49829_, p_49831_, p_49828_, p_49832_);
     }
 
+    // Purpur start
+    @Nullable protected LivingEntity placer = null;
+
     public void setPlacedBy(Level p_49847_, BlockPos p_49848_, BlockState p_49849_, @Nullable LivingEntity p_49850_, ItemStack p_49851_) {
-    }
+        this.placer = p_49850_;
+    }
+
+    public void forgetPlacer() {
+        this.placer = null;
+    }
+    // Purpur end
 
     public boolean isPossibleToRespawnInThis(BlockState p_279289_) {
         return !p_279289_.isSolid() && !p_279289_.liquid();
@@ -380,13 +_,15 @@
     }
 
     public void fallOn(Level p_152426_, BlockState p_152427_, BlockPos p_152428_, Entity p_152429_, float p_152430_) {
-        p_152429_.causeFallDamage(p_152430_, 1.0F, p_152429_.damageSources().fall());
+        p_152429_.causeFallDamage(p_152430_ * fallDistanceMultiplier, fallDamageMultiplier, p_152429_.damageSources().fall()); // Purpur
     }
 
     public void updateEntityAfterFallOn(BlockGetter p_49821_, Entity p_49822_) {
         p_49822_.setDeltaMovement(p_49822_.getDeltaMovement().multiply(1.0, 0.0, 1.0));
+        p_49822_.setDeltaMovement(p_49822_.getDeltaMovement().multiply(1.0D, 0.0D, 1.0D));
     }
 
+    @Deprecated //Forge: Use more sensitive version
     public ItemStack getCloneItemStack(LevelReader p_304395_, BlockPos p_49824_, BlockState p_49825_) {
         return new ItemStack(this);
     }
@@ -420,6 +_,7 @@
     public void handlePrecipitation(BlockState p_152450_, Level p_152451_, BlockPos p_152452_, Biome.Precipitation p_152453_) {
     }
 
+    @Deprecated //Forge: Use more sensitive version
     public boolean dropFromExplosion(Explosion p_49826_) {
         return true;
     }
@@ -485,17 +_,70 @@
         return this.stateDefinition.getPossibleStates().stream().collect(ImmutableMap.toImmutableMap(Function.identity(), p_152459_));
     }
 
+    /**
+     * Neo: Short-lived holder of dropped item entities. Used mainly for Neo hooks and event logic.
+     * <p>
+     * When not null, records all item entities from {@link #popResource(Level, Supplier, ItemStack)} instead of adding them to the world.
+     */
+    @Nullable
+    private static List<ItemEntity> capturedDrops = null;
+
+    /**
+     * Initializes {@link #capturedDrops}, starting the drop capture process.
+     * <p>
+     * Must only be called on the server thread.
+     */
+    private static void beginCapturingDrops() {
+        capturedDrops = new java.util.ArrayList<>();
+    }
+
+    /**
+     * Ends the drop capture process by setting {@link #capturedDrops} to null and returning the old list.
+     * <p>
+     * Must only be called on the server thread.
+     */
+    private static List<ItemEntity> stopCapturingDrops() {
+        List<ItemEntity> drops = capturedDrops;
+        capturedDrops = null;
+        return drops;
+    }
+
+    /**
+     * Neo: Allowing mods to define client behavior for their Blocks
+     * @deprecated Use {@link net.neoforged.neoforge.client.extensions.common.RegisterClientExtensionsEvent} instead
+     */
+    @Deprecated(forRemoval = true, since = "1.21")
+    public void initializeClient(java.util.function.Consumer<net.neoforged.neoforge.client.extensions.common.IClientBlockExtensions> consumer) {
+    }
+
+    /** @deprecated */
     @Deprecated
     public Holder.Reference<Block> builtInRegistryHolder() {
         return this.builtInRegistryHolder;
     }
 
+    public int getExpDrop(BlockState p_220827_, ServerLevel p_220828_, BlockPos p_220829_, ItemStack p_220830_, boolean flag) {
+        return 0;
+    }
+
     protected void tryDropExperience(ServerLevel p_220823_, BlockPos p_220824_, ItemStack p_220825_, IntProvider p_220826_) {
         int i = EnchantmentHelper.processBlockExperience(p_220823_, p_220825_, p_220826_.sample(p_220823_.getRandom()));
         if (i > 0) {
             this.popExperience(p_220823_, p_220824_, i);
         }
     }
+
+    // Spigot start
+    public static float range(float min, float value, float max) {
+        if (value < min) {
+            return min;
+        }
+        if (value > max) {
+            return max;
+        }
+        return value;
+    }
+    // Spigot end
 
     public static final class BlockStatePairKey {
         private final BlockState first;
