--- a/net/minecraft/network/Connection.java
+++ b/net/minecraft/network/Connection.java
@@ -32,7 +_,6 @@
 import io.netty.handler.flow.FlowControlHandler;
 import io.netty.handler.timeout.ReadTimeoutHandler;
 import io.netty.handler.timeout.TimeoutException;
-import io.netty.util.concurrent.Future;
 import java.net.InetSocketAddress;
 import java.net.SocketAddress;
 import java.nio.channels.ClosedChannelException;
@@ -63,6 +_,7 @@
 import net.minecraft.util.Mth;
 import net.minecraft.util.debugchart.LocalSampleLogger;
 import org.apache.commons.lang3.Validate;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
 import org.slf4j.Logger;
 import org.slf4j.Marker;
 import org.slf4j.MarkerFactory;
@@ -107,7 +_,48 @@
     private volatile DisconnectionDetails delayedDisconnect;
     @Nullable
     BandwidthDebugMonitor bandwidthDebugMonitor;
+    public String hostname = ""; // CraftBukkit - add field
+    @Nullable
+    private ProtocolInfo<?> inboundProtocol;
+    // Spigot Start
+    public java.util.UUID spoofedUUID;
+    public com.mojang.authlib.properties.Property[] spoofedProfile;
+    public boolean preparing = true;
+    // Spigot End
+    private volatile boolean mohist$isClosing; //mohist
+    // Paper start - NetworkClient implementation
+    public int protocolVersion;
+    public java.net.InetSocketAddress virtualHost;
+    private static boolean enableExplicitFlush = Boolean.getBoolean("paper.explicit-flush"); // Paper - Disable explicit network manager flushing
+    // Paper end
+    // Paper start - add utility methods
+    public final net.minecraft.server.level.ServerPlayer getPlayer() {
+        if (this.packetListener instanceof net.minecraft.server.network.ServerGamePacketListenerImpl impl) {
+            return impl.player;
+        } else if (this.packetListener instanceof net.minecraft.server.network.ServerCommonPacketListenerImpl impl) {
+            CraftPlayer player = impl.getCraftPlayer();
+            return player == null ? null : player.getHandle();
+        }
+        return null;
+    }
+    // Paper end - add utility methods
+    @Nullable public SocketAddress haProxyAddress; // Paper - Add API to get player's proxy address
+    // Paper start - packet limiter
+    protected final Object PACKET_LIMIT_LOCK = new Object();
+    protected final @Nullable io.papermc.paper.util.IntervalledCounter allPacketCounts = io.papermc.paper.configuration.GlobalConfiguration.get().packetLimiter.allPackets.isEnabled() ? new io.papermc.paper.util.IntervalledCounter(
+            (long)(io.papermc.paper.configuration.GlobalConfiguration.get().packetLimiter.allPackets.interval() * 1.0e9)
+    ) : null;
+    protected final java.util.Map<Class<? extends net.minecraft.network.protocol.Packet<?>>, io.papermc.paper.util.IntervalledCounter> packetSpecificLimits = new java.util.HashMap<>();
 
+    private boolean stopReadingPackets;
+    private void killForPacketSpam() {
+        this.sendPacket(new ClientboundDisconnectPacket(io.papermc.paper.adventure.PaperAdventure.asVanilla(io.papermc.paper.configuration.GlobalConfiguration.get().packetLimiter.kickMessage)), PacketSendListener.thenRun(() -> {
+            this.disconnect(io.papermc.paper.adventure.PaperAdventure.asVanilla(io.papermc.paper.configuration.GlobalConfiguration.get().packetLimiter.kickMessage));
+        }), true);
+        this.setReadOnly();
+        this.stopReadingPackets = true;
+    }
+    // Paper end - packet limiter
     public Connection(PacketFlow p_129482_) {
         this.receiving = p_129482_;
     }
@@ -117,30 +_,59 @@
         super.channelActive(p_129525_);
         this.channel = p_129525_.channel();
         this.address = this.channel.remoteAddress();
+        // Spigot Start
+        this.preparing = false;
+        // Spigot End
         if (this.delayedDisconnect != null) {
             this.disconnect(this.delayedDisconnect);
         }
+        net.neoforged.neoforge.network.connection.ConnectionUtils.setConnection(p_129525_, this);
     }
 
     @Override
     public void channelInactive(ChannelHandlerContext p_129527_) {
         this.disconnect(Component.translatable("disconnect.endOfStream"));
+        net.neoforged.neoforge.network.connection.ConnectionUtils.removeConnection(p_129527_);
     }
 
     @Override
     public void exceptionCaught(ChannelHandlerContext p_129533_, Throwable p_129534_) {
+        // Paper start - Handle large packets disconnecting client
+        if (p_129534_ instanceof io.netty.handler.codec.EncoderException && p_129534_.getCause() instanceof PacketEncoder.PacketTooLargeException packetTooLargeException) {
+            final Packet<?> packet = packetTooLargeException.getPacket();
+            if (packet.packetTooLarge(this)) {
+                ProtocolSwapHandler.handleOutboundTerminalPacket(p_129533_, packet);
+                return;
+            } else if (packet.isSkippable()) {
+                Connection.LOGGER.debug("Skipping packet due to errors", p_129534_.getCause());
+                ProtocolSwapHandler.handleOutboundTerminalPacket(p_129533_, packet);
+                return;
+            } else {
+                p_129534_ = p_129534_.getCause();
+            }
+        }
+        // Paper end - Handle large packets disconnecting client
         if (p_129534_ instanceof SkipPacketException) {
             LOGGER.debug("Skipping packet due to errors", p_129534_.getCause());
         } else {
             boolean flag = !this.handlingFault;
             this.handlingFault = true;
-            if (this.channel.isOpen()) {
+            if (this.channel.isOpen() && !this.mohist$isClosing) {
+                net.minecraft.server.level.ServerPlayer player = this.getPlayer(); // Paper - Add API for quit reason
                 if (p_129534_ instanceof TimeoutException) {
                     LOGGER.debug("Timeout", p_129534_);
+                    if (player != null) player.quitReason = org.bukkit.event.player.PlayerQuitEvent.QuitReason.TIMED_OUT; // Paper - Add API for quit reason
                     this.disconnect(Component.translatable("disconnect.timeout"));
                 } else {
                     Component component = Component.translatable("disconnect.genericReason", "Internal Exception: " + p_129534_);
                     PacketListener packetlistener = this.packetListener;
+                    if (packetlistener != null) {
+                        ConnectionProtocol protocol = packetlistener.protocol();
+                        if (protocol == ConnectionProtocol.CONFIGURATION || protocol == ConnectionProtocol.PLAY) {
+                            // Neo: Always log critical network exceptions for config and play packets
+                            LOGGER.error("Exception caught in connection", p_129534_);
+                        }
+                    }
                     DisconnectionDetails disconnectiondetails;
                     if (packetlistener != null) {
                         disconnectiondetails = packetlistener.createDisconnectionInfo(component, p_129534_);
@@ -148,9 +_,11 @@
                         disconnectiondetails = new DisconnectionDetails(component);
                     }
 
+                    if (player != null) player.quitReason = org.bukkit.event.player.PlayerQuitEvent.QuitReason.ERRONEOUS_STATE; // Paper - Add API for quit reason
                     if (flag) {
                         LOGGER.debug("Failed to sent packet", p_129534_);
-                        if (this.getSending() == PacketFlow.CLIENTBOUND) {
+                        boolean doesDisconnectExist = this.packetListener.protocol() != ConnectionProtocol.STATUS && this.packetListener.protocol() != ConnectionProtocol.HANDSHAKING; // Paper
+                        if (this.getSending() == PacketFlow.CLIENTBOUND && doesDisconnectExist) { // Paper
                             Packet<?> packet = (Packet<?>)(this.sendLoginDisconnect
                                 ? new ClientboundLoginDisconnectPacket(component)
                                 : new ClientboundDisconnectPacket(component));
@@ -170,15 +_,65 @@
     }
 
     protected void channelRead0(ChannelHandlerContext p_129487_, Packet<?> p_129488_) {
-        if (this.channel.isOpen()) {
+        if (this.channel.isOpen() && !this.mohist$isClosing) {
             PacketListener packetlistener = this.packetListener;
             if (packetlistener == null) {
                 throw new IllegalStateException("Received a packet before the packet listener was initialized");
             } else {
+                // Paper start - packet limiter
+                if (this.stopReadingPackets) {
+                    return;
+                }
+                if (this.allPacketCounts != null ||
+                        io.papermc.paper.configuration.GlobalConfiguration.get().packetLimiter.overrides.containsKey(p_129488_.getClass())) {
+                    long time = System.nanoTime();
+                    synchronized (PACKET_LIMIT_LOCK) {
+                        if (this.allPacketCounts != null) {
+                            this.allPacketCounts.updateAndAdd(1, time);
+                            if (this.allPacketCounts.getRate() >= io.papermc.paper.configuration.GlobalConfiguration.get().packetLimiter.allPackets.maxPacketRate()) {
+                                this.killForPacketSpam();
+                                return;
+                            }
+                        }
+
+                        for (Class<?> check = p_129488_.getClass(); check != Object.class; check = check.getSuperclass()) {
+                            io.papermc.paper.configuration.GlobalConfiguration.PacketLimiter.PacketLimit packetSpecificLimit =
+                                    io.papermc.paper.configuration.GlobalConfiguration.get().packetLimiter.overrides.get(check);
+                            if (packetSpecificLimit == null || !packetSpecificLimit.isEnabled()) {
+                                continue;
+                            }
+                            io.papermc.paper.util.IntervalledCounter counter = this.packetSpecificLimits.computeIfAbsent((Class)check, (clazz) -> {
+                                return new io.papermc.paper.util.IntervalledCounter((long)(packetSpecificLimit.interval() * 1.0e9));
+                            });
+                            counter.updateAndAdd(1, time);
+                            if (counter.getRate() >= packetSpecificLimit.maxPacketRate()) {
+                                switch (packetSpecificLimit.action()) {
+                                    case DROP:
+                                        return;
+                                    case KICK:
+                                        String deobfedPacketName = io.papermc.paper.util.ObfHelper.INSTANCE.deobfClassName(check.getName());
+
+                                        String playerName;
+                                        if (this.packetListener instanceof net.minecraft.server.network.ServerCommonPacketListenerImpl impl) {
+                                            playerName = impl.getOwner().getName();
+                                        } else {
+                                            playerName = this.getLoggableAddress(net.minecraft.server.MinecraftServer.getServer().logIPs());
+                                        }
+
+                                        Connection.LOGGER.warn("{} kicked for packet spamming: {}", playerName, deobfedPacketName.substring(deobfedPacketName.lastIndexOf(".") + 1));
+                                        this.killForPacketSpam();
+                                        return;
+                                }
+                            }
+                        }
+                    }
+                }
+                // Paper end - packet limiter
                 if (packetlistener.shouldHandleMessage(p_129488_)) {
                     try {
                         genericsFtw(p_129488_, packetlistener);
                     } catch (RunningOnDifferentThreadException runningondifferentthreadexception) {
+                    } catch (io.papermc.paper.util.ServerStopRejectedExecutionException ignored) { // Paper - do not prematurely disconnect players on stop
                     } catch (RejectedExecutionException rejectedexecutionexception) {
                         this.disconnect(Component.translatable("multiplayer.disconnect.server_shutdown"));
                     } catch (ClassCastException classcastexception) {
@@ -226,6 +_,7 @@
         if (p_320903_.flow() != this.getReceiving()) {
             throw new IllegalStateException("Invalid inbound protocol: " + p_320903_.id());
         } else {
+            this.inboundProtocol = p_320903_;
             this.packetListener = p_320940_;
             this.disconnectListener = null;
             UnconfiguredPipelineHandler.InboundConfigurationTask unconfiguredpipelinehandler$inboundconfigurationtask = UnconfiguredPipelineHandler.setupInboundProtocol(
@@ -254,7 +_,12 @@
             if (bundlerinfo != null) {
                 PacketBundleUnpacker packetbundleunpacker = new PacketBundleUnpacker(bundlerinfo);
                 unconfiguredpipelinehandler$outboundconfigurationtask = unconfiguredpipelinehandler$outboundconfigurationtask.andThen(
-                    p_319516_ -> p_319516_.pipeline().addAfter("encoder", "unbundler", packetbundleunpacker)
+                    p_319516_ -> {
+                        p_319516_.pipeline().addAfter("encoder", "unbundler", packetbundleunpacker);
+                        // Neo: our handlers must be between the encoder and the unbundler, so re-inject them
+                        // Note, this call must be inside the .andThen lambda, or it will actually run before the unbundler gets added.
+                        net.neoforged.neoforge.network.filters.NetworkFilters.injectIfNecessary(this);
+                    }
                 );
             }
 
@@ -389,10 +_,26 @@
         }
     }
 
+    private static final int MAX_PER_TICK = io.papermc.paper.configuration.GlobalConfiguration.get().misc.maxJoinsPerTick; // Paper - Buffer joins to world
+    private static int joinAttemptsThisTick; // Paper - Buffer joins to world
+    private static int currTick; // Paper - Buffer joins to world
     public void tick() {
         this.flushQueue();
-        if (this.packetListener instanceof TickablePacketListener tickablepacketlistener) {
-            tickablepacketlistener.tick();
+        // Paper start - Buffer joins to world
+        if (Connection.currTick != net.minecraft.server.MinecraftServer.currentTick) {
+            Connection.currTick = net.minecraft.server.MinecraftServer.currentTick;
+            Connection.joinAttemptsThisTick = 0;
+        }
+        // Paper end - Buffer joins to world
+        PacketListener packetlistener = this.packetListener;
+
+        if (packetlistener instanceof TickablePacketListener tickablepacketlistener) {
+            // Paper start - Buffer joins to world
+            if (!(this.packetListener instanceof net.minecraft.server.network.ServerLoginPacketListenerImpl loginPacketListener)
+                    || loginPacketListener.state != net.minecraft.server.network.ServerLoginPacketListenerImpl.State.VERIFYING
+                    || Connection.joinAttemptsThisTick++ < MAX_PER_TICK) {
+                tickablepacketlistener.tick();
+            } // Paper end - Buffer joins to world
         }
 
         if (!this.isConnected() && !this.disconnectionHandled) {
@@ -400,7 +_,7 @@
         }
 
         if (this.channel != null) {
-            this.channel.flush();
+            if (enableExplicitFlush) this.channel.eventLoop().execute(() -> this.channel.flush()); // Paper - Disable explicit network manager flushing; we don't need to explicit flush here, but allow opt in incase issues are found to a better version
         }
 
         if (this.tickCount++ % 20 == 0) {
@@ -427,7 +_,7 @@
         if (this.address == null) {
             return "local";
         } else {
-            return p_295875_ ? this.address.toString() : "IP hidden";
+            return p_295875_ ? net.neoforged.neoforge.network.DualStackUtils.getAddressString(this.address) : "IP hidden";
         }
     }
 
@@ -436,12 +_,15 @@
     }
 
     public void disconnect(DisconnectionDetails p_350867_) {
+        // Spigot Start
+        this.preparing = false;
+        // Spigot End
         if (this.channel == null) {
             this.delayedDisconnect = p_350867_;
         }
 
         if (this.isConnected()) {
-            this.channel.close().awaitUninterruptibly();
+            this.channel.close(); // We can't wait as this may be called from an event loop.
             this.disconnectionDetails = p_350867_;
         }
     }
@@ -470,6 +_,7 @@
     }
 
     public static ChannelFuture connect(InetSocketAddress p_290034_, boolean p_290035_, final Connection p_290031_) {
+        net.neoforged.neoforge.network.DualStackUtils.checkIPv6(p_290034_.getAddress());
         Class<? extends SocketChannel> oclass;
         EventLoopGroup eventloopgroup;
         if (Epoll.isAvailable() && p_290035_) {
@@ -552,11 +_,21 @@
         return connection;
     }
 
-    public void setEncryptionKey(Cipher p_129496_, Cipher p_129497_) {
-        this.encrypted = true;
-        this.channel.pipeline().addBefore("splitter", "decrypt", new CipherDecoder(p_129496_));
-        this.channel.pipeline().addBefore("prepender", "encrypt", new CipherEncoder(p_129497_));
+    public void setupEncryption(javax.crypto.SecretKey key) throws net.minecraft.util.CryptException {
+        if (!this.encrypted) {
+            try {
+                com.velocitypowered.natives.encryption.VelocityCipher decryption = com.velocitypowered.natives.util.Natives.cipher.get().forDecryption(key);
+                com.velocitypowered.natives.encryption.VelocityCipher encryption = com.velocitypowered.natives.util.Natives.cipher.get().forEncryption(key);
+
+                this.encrypted = true;
+                this.channel.pipeline().addBefore("splitter", "decrypt", new CipherDecoder(decryption));
+                this.channel.pipeline().addBefore("prepender", "encrypt", new CipherEncoder(encryption));
+            } catch (java.security.GeneralSecurityException e) {
+                throw new net.minecraft.util.CryptException(e);
+            }
+        }
     }
+    // Paper end - Use Velocity cipher
 
     public boolean isEncrypted() {
         return this.encrypted;
@@ -586,10 +_,19 @@
         }
     }
 
+    // Paper start - add proper async disconnect
+    public void enableAutoRead() {
+        if (this.channel != null) {
+            this.channel.config().setAutoRead(true);
+        }
+    }
+    // Paper end - add proper async disconnect
+
     public void setupCompression(int p_129485_, boolean p_182682_) {
         if (p_129485_ >= 0) {
+            com.velocitypowered.natives.compression.VelocityCompressor compressor = com.velocitypowered.natives.util.Natives.compress.get().create(io.papermc.paper.configuration.GlobalConfiguration.get().misc.compressionLevel.or(-1)); // Paper - Use Velocity cipher
             if (this.channel.pipeline().get("decompress") instanceof CompressionDecoder compressiondecoder) {
-                compressiondecoder.setThreshold(p_129485_, p_182682_);
+                compressiondecoder.setThreshold(compressor, p_129485_, p_182682_);
             } else {
                 this.channel.pipeline().addAfter("splitter", "decompress", new CompressionDecoder(p_129485_, p_182682_));
             }
@@ -597,8 +_,9 @@
             if (this.channel.pipeline().get("compress") instanceof CompressionEncoder compressionencoder) {
                 compressionencoder.setThreshold(p_129485_);
             } else {
-                this.channel.pipeline().addAfter("prepender", "compress", new CompressionEncoder(p_129485_));
+                this.channel.pipeline().addAfter("prepender", "compress", new CompressionEncoder(compressor, p_129485_));
             }
+            this.channel.pipeline().fireUserEventTriggered(io.papermc.paper.network.ConnectionEvent.COMPRESSION_THRESHOLD_SET); // Paper - Add Channel initialization listeners
         } else {
             if (this.channel.pipeline().get("decompress") instanceof CompressionDecoder) {
                 this.channel.pipeline().remove("decompress");
@@ -607,13 +_,14 @@
             if (this.channel.pipeline().get("compress") instanceof CompressionEncoder) {
                 this.channel.pipeline().remove("compress");
             }
+            this.channel.pipeline().fireUserEventTriggered(io.papermc.paper.network.ConnectionEvent.COMPRESSION_DISABLED); // Paper - Add Channel initialization listeners
         }
     }
 
     public void handleDisconnection() {
         if (this.channel != null && !this.channel.isOpen()) {
             if (this.disconnectionHandled) {
-                LOGGER.warn("handleDisconnection() called twice");
+                // LOGGER.warn("handleDisconnection() called twice");
             } else {
                 this.disconnectionHandled = true;
                 PacketListener packetlistener = this.getPacketListener();
@@ -624,6 +_,26 @@
                     );
                     packetlistener1.onDisconnect(disconnectiondetails);
                 }
+                // Paper start - Add PlayerConnectionCloseEvent
+                final PacketListener packetListener = this.getPacketListener();
+                if (packetListener instanceof net.minecraft.server.network.ServerCommonPacketListenerImpl commonPacketListener) {
+                    /* Player was logged in, either game listener or configuration listener */
+                    final com.mojang.authlib.GameProfile profile = commonPacketListener.getOwner();
+                    new com.destroystokyo.paper.event.player.PlayerConnectionCloseEvent(profile.getId(),
+                            profile.getName(), ((InetSocketAddress) this.address).getAddress(), false).callEvent();
+                } else if (packetListener instanceof net.minecraft.server.network.ServerLoginPacketListenerImpl loginListener) {
+                    /* Player is login stage */
+                    switch (loginListener.state) {
+                        case VERIFYING:
+                        case WAITING_FOR_DUPE_DISCONNECT:
+                        case PROTOCOL_SWITCHING:
+                        case ACCEPTED:
+                            final com.mojang.authlib.GameProfile profile = loginListener.authenticatedProfile; /* Should be non-null at this stage */
+                            new com.destroystokyo.paper.event.player.PlayerConnectionCloseEvent(profile.getId(), profile.getName(),
+                                    ((InetSocketAddress) this.address).getAddress(), false).callEvent();
+                    }
+                }
+                // Paper end - Add PlayerConnectionCloseEvent
             }
         }
     }
@@ -638,5 +_,17 @@
 
     public void setBandwidthLogger(LocalSampleLogger p_323799_) {
         this.bandwidthDebugMonitor = new BandwidthDebugMonitor(p_323799_);
+    }
+
+    public Channel channel() {
+        return this.channel;
+    }
+
+    public PacketFlow getDirection() {
+        return this.receiving;
+    }
+
+    public ProtocolInfo<?> getInboundProtocol() {
+        return Objects.requireNonNull(this.inboundProtocol, "Inbound protocol not set?");
     }
 }
